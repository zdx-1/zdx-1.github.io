[{"title":"[数据结构与算法]递推与递归","url":"/2024/03/10/DSA-Recurrence-Relation-and-Recursion/","content":"递推法与递归法递推法：\n递推法是一种在数学和其他领域广泛应用的重要方法，它在计算机科学中被用作一种关键的数值求解算法。\n知识点：\n\n递推算法\n递归算法\n\n递推算法的特点递推法的核心在于找到递推关系式。这种方法可以将复杂的计算过程转化为简单的重复步骤，充分利用计算机在运行程序时的时间局部性和空间局部性。\n递推算法的思想：\n\n首先找到各个相邻数据项之间的递推关系；\n递推关系避开了求通项公式的麻烦，尤其是对于那些难以或无法求解通项公式的题目；\n将复杂问题分解为若干步骤的简单运算；\n一般来说，递推算法可以视为一种特殊的迭代算法。\n\n递推算法解题的基本思路：\n\n将复杂计算转换为简单重复运算；\n通过找到递推关系式进行简化运算；\n利用计算机的特性，减少运行时间。\n\n递推算法的一般步骤：\n\n根据题目确定数据项，并找到符合要求的递推关系式；\n根据递推关系式设计递推程序；\n根据题目找到递推的终点；\n单次查询可以不进行存储，多次查询都要进行存储；\n按要求输出答案即可。\n\n递归算法：\n递归算法是一种自顶向下的算法，它通过不断地直接或间接调用自身的函数，通过每次改变变量完成多个过程的重复计算，直到到达边界之后，结束调用。\n与递推法相似的是，递归与递推都是将一个复杂过程分解为几个简单重复步骤进行计算。\n递归算法的实现的核心是分治策略，即分而治之，将复杂过程分解为规模较小的同类问题，通过解决若干个小问题，进而解决整个复杂问题。\n递归算法的思想：\n\n将复杂计算过程转换为简单重复子过程；\n找到递归公式，即能够将大问题转化为小问题的公式；\n自上而下计算，在返回完成递归过程。\n\n递归算法设计的一般步骤：\n\n根据题目设计递归函数中的运算部分；\n根据题目找到递归公式，题目可能会隐含给出，也可能需要自己进行推导；\n找到递归出口，即递归的终止条件。\n\n递归法和递推法的思路已经给大家讲解得差不多了，接下来我们将结合真实的大赛题目进行讲解。这将有助于我们更好地理解和应用这两种方法。\n斐波纳契数列 fibonacci 问题在一定情况下，同一个问题可以使用用递归也可以使用递推解答。一般一个问题的递推关系和递归关系都好求的话就都可以解题。\n当然如果题目只有一个关系好求，那就最好采用关系好求的办法。\n题目描述:\n斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。\n指的是这样一个数列：、、、、、、、、、、\n在数学上，斐波那契数列以如下被以递推的方法定义：，，（，）\n请求出该数列中第  个数字（ 从开始计数）是多少。\n样例:\n输入样例样例1输入6样例2输入4输出样例样例1输出8样例2输出3\n\n对于上面的样例我们进行了如下计算；\n[0]=0[1]=1[2]=0+1[3]=1+1=2[4]=1+2=3[5]=2+3=5[6]=5+3=8 \n\n运行限制:\n1. 最大运行时间：1s2. 最大运行内存：128M\n\n题目解析：\n\n这个题给出递推式 \n转化为可用的递推关系，即\n\n这一通过从  开始循环即可完成递推，当然也可以使用递归法。\n首先我们写找出递归式，。\nF(n)= F(n-1) + F(n-2)    = F(n-2)+F(n-3)+F(n-3)+F(n-4)//重复调用\n\n这样我们找到了递归式，然后我们应该找到递归出口。\n我们可以知道  这就是递归出口，能让递归停止的条件。\n递归算法的通用框架如下：\ndo(a,b,c...){    //递归终止条件，即出口    if(a==? ,b==? ,....) return    //递归条件    if(条件1)        do(参数1)    else(条件2)        do(参数2)}如本题，各子式间存在计算关系，可以化为：do(a){    if(a==0) return 0;    if(a==1) return 1;    return do(a-1)+do(a-2);}\n\n这道题不是多次询问问题，不需要存储直接计算的复杂度是最低的。\n答案解析C++ 代码：\n\n递推算法代码\n\n#include &lt;iostream&gt;using namespace std;int main(){    int n; //第几个数    int x=0; //F(n)    int y=1; //F(n+1)    int ans; //F(n+2）    cin&gt;&gt;n;    if(n==0) ans=0;    else if(n==1) ans=1;    else {        for(int i=2;i&lt;=n;i++)        {            ans=x+y;            x=y;            y=ans;        }    }    cout&lt;&lt;ans&lt;&lt;endl;}\n\n\n递归算法代码\n\n#include &lt;iostream&gt;using namespace std;int fn(int n){    //递归出口1    if(n==0)        return 0;    //递归出口2    else if(n==1 )        return 1;    else        return fn(n-1)+fn(n-2); //递归关系式}int main(){    int n; //第几个数    int ans;    cin&gt;&gt;n;    ans=fn(n);    cout&lt;&lt;ans&lt;&lt;endl;}\n\nPython 解题代码\n\n递推算法代码：\n\nif __name__ == '__main__':    n =int( input())    x=0 # F(n)    y=1 #F(n+1)    ans=0 #F(n+2）    if n==0 :        ans=0    elif n==1:        ans=1    else:        for i in range (n-1):            ans=x+y            x=y            y=ans    print(ans)\n\n\n递归算法代码：\n\ndef f(n):    # 递归出口1    if n == 0:        return 0    # 递归出口2    elif n == 1:        return 1    else:        return f(n - 1) + f(n - 2)  # 递归关系式if __name__ == '__main__':    n = int(input())    ans = f(n)    print(ans)\n\nJava 解题代码\n递推算法：\nimport java.util.Scanner;public class Main {    public static void main(String[] args) {        int n; //第几个数        int x=0; //F(n)        int y=1; //F(n+1)        int ans = 0; //F(n+2）        Scanner in = new Scanner(System.in);        n = in.nextInt();        if(n==0) ans=0;        else if(n==1) ans=1;        else {            for(int i=2;i&lt;=n;i++)            {                ans=x+y;                x=y;                y=ans;            }        }        System.out.println(ans);    }}\n\n递归算法代码：\nimport java.util.Scanner;public class Main {    static  int fn(int n)    {        if(n==0)            return 0;            //递归出口2        else if(n==1 )            return 1;        else            return fn(n-1)+fn(n-2); //递归关系式    }    public static void main(String[] args) {        int n; //第几个数        int ans = 0;        Scanner in = new Scanner(System.in);        n = in.nextInt();        ans=fn(n);        System.out.println(ans);    }}\n\n存储型的递推与递归我们在开始就讲过题目十分存储和非存储的，上面那个题目就是此询问，如果改为多次询问我们该怎么办，我们会采用存储的方式，存储的方式适用于大部分的的多次查询问题。\n我们看一下修改后的题目。\n题目描述：\n斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。\n指的是这样一个数列：、、、、、、、、、、\n在数学上，斐波那契数列以如下被以递推的方法定义：，，（，）\n我们将进行M次查询，每次输入一个，其中小于。\n请求出该数列中第个数字（从开始计数）是多少?\n样例:\n输入样例样例1输入：64278810样例2输入：81323141724161011输出样例样例1输出：3113212155样例2输出：233286573771597463689875589\n\n运行限制:\n1. 最大运行时间：1s 2. 最大运行内存：128M\n\n题目解析：\n这道题跟上面一道题的算法原理相同，只是增加了多次查询的复杂度，所以仅需修改这一点即可。\n再有的是有的同学担心自己的输入输出是在一个屏幕上的，评测的时候会不会出现问题。\n\n类似这样的情况，这一点是不用担心的，只要不是交互题，评测机的输入与输出是分开的，只有你的输出会用来跟答案比较，所以我们只用关心我们的输出即可。\n比如有一道题让你计算  的值，如果你知道每答案，就可以直接输出，都不用进行读入。\n然后我们来看一下需要多次询问的题目该怎么解决。\n答案解析C++ 代码：\n\n递推算法代码\n\n#include &lt;iostream&gt;using namespace std;int F[35];void init(){    F[0]=0;    F[1]=1;    for(int i=2;i&lt;=30;i++)    {        F[i]=F[i-1]+F[i-2];    }}int main(){    int m; //m次查询    int n; //第几个数    init();    cin&gt;&gt;m;    while(m&gt;0){        m-=1;        cin&gt;&gt;n;        cout&lt;&lt;F[n]&lt;&lt;endl;    }}\n\n存储答案的递推法，才是最常使用的递推法。\n\n递归算法代码\n\n#include &lt;iostream&gt;using namespace std;int F[35];int fn(int n){    //递归出口1    if(n==0)    {        F[0]=0;        return 0;    }    //递归出口2    else if(n==1 )    {        F[1]=1;        return 1;    }    else    {        F[n]=fn(n-1)+fn(n-2);        return F[n]; //递归关系式    }}int main(){    int m; //m次查询    int n; //第几个数    fn(30);    cin&gt;&gt;m;    while(m&gt;0){        m-=1;        cin&gt;&gt;n;        cout&lt;&lt;F[n]&lt;&lt;endl;    }}\n\nPython 解题代码\n递推算法代码：\nF = [0]*35def init():    F[0] = 0    F[1] = 1    for i in range(2, 30):        F[i] = F[i-1]+F[i-2]if __name__ == '__main__':    m = int(input())    init()    while m &gt; 0:        m -= 1        n = int(input())        print(F[n])    # print(F)\n\n递归算法代码：\nF = [0] * 35def f(n):    # 递归出口1    if n == 0:        F[0] = 0        return 0    # 递归出口2    elif n == 1:        F[1] = 1        return 1    else:        F[n] = f(n - 1) + f(n - 2) # 递归关系式        return F[n]if __name__ == '__main__':    m = int(input())    f(30)    while m &gt; 0:        m -= 1        n = int(input())        print(F[n])    # print(F)\n\nJava 解题代码\n递推算法：\nimport java.util.Scanner;public class Main {    static int []F=new int [35];    static  void init()    {        F[0]=0;        F[1]=1;        for(int i=2;i&lt;=30;i++)        {            F[i]=F[i-1]+F[i-2];        }    }    public static void main(String[] args) {        int m; //m次查询        int n; //第几个数        init();        Scanner in = new Scanner(System.in);        m = in.nextInt();        while(m&gt;0){            m-=1;            n= in.nextInt();            System.out.println(F[n]);        }    }}\n\n递归算法代码：\npackage com.company;import java.util.Scanner;public class Main {    static int []F=new int [35];    static int fn(int n)    {        //递归出口1        if(n==0)        {            F[0]=0;            return 0;        }        //递归出口2        else if(n==1 )        {            F[1]=1;            return 1;        }        else        {            F[n]=fn(n-1)+fn(n-2);            return F[n]; //递归关系式        }    }    public static void main(String[] args) {        int m; //m次查询        int n; //第几个数        fn(30);        Scanner in = new Scanner(System.in);        m = in.nextInt();        while(m&gt;0){            m-=1;            n= in.nextInt();            System.out.println(F[n]);        }    }}\n\n数字三角形问题题目描述:\n如图数字三角形。如下所示为一个数字三角形。请编一个程序计算从顶到底的某处的一条路径，使该路径所经过的数字总和最大。只要求输出总和。 　\n\n一步可沿左斜线向下或右斜线向下走；\n三角形行数小于等于 ；\n三角形中的数字为 ，，，；\n\n测试数据通过键盘逐行输入。\n如上例数据应以样例所示格式输入：\n样例:\n输入：573 88 1 02 7 4 44 5 2 6 5\n\n输出：30\n\n运行限制:\n1. 最大运行时间：1s2. 最大运行内存：128M\n\n题目分析:\n解决该题目的方式有很多，包括动态规划， 枚举都可以解决这个问题。\n我们从递推的思想出发，假设我们从顶层沿着某条路径已经走到了第  层，正向着  层前进， 两条可行路径中我们肯定会选择最大的方向前进，为此我们可以采用递推中的反向递推，即逆推的方式解决，设  存放从  出发到达第  层的最大值。\n我们可以写出递推式：\na[i][j] = max{a[i][j]+a[i+1][j]，a[i][j]+a[i+1][j+1]}\n\n则 逆推到出发点  为题目所求答案，即第一层到第  层的最大值。\n答案解析C++ 代码：\n#include&lt;iostream&gt;using namespace std;int main(){    int n; //n层    int a[101][101]; //路径矩阵    cin&gt;&gt;n;    //输入数字三角形的值    for (int i=1; i&lt;=n; i++)    {        for (int j=1; j&lt;=i; j++)        {        cin&gt;&gt;a[i][j]; //输入原始数据        }    }    //递推开始    for (int i=n-1; i&gt;=1; i--)//从最后一层逆推    {        for (int j=1; j&lt;=i; j++)        {            if (a[i+1][j]&gt;=a[i+1][j+1])                a[i][j]+=a[i+1][j];     //路径选择            else                a[i][j]+=a[i+1][j+1];        }    }    cout&lt;&lt;a[1][1]&lt;&lt;endl;}\n\nPython 解题代码\na = [[0] * 101] * 101if __name__ == '__main__':  n = int(input())  # 输入数字三角形的值  for i in range(1, n+1):      a[i] = input().split()      a[i] = list(map(int, a[i]))  # split 分割后都是 字符 这里是转化成数字  #  # for i in range(1, n + 1):  #     print(a[i]) # a = list(map(int, a)) # split 分割后都是 字符 这里是转化成数字  # 递推开始  for i in range(n - 1, 0, -1):      # 最后一层逆推      for j in range(0, i):          # 路径选择          if a[i + 1][j] &gt;= a[i + 1][j + 1]:              a[i][j] += a[i + 1][j]          else:              a[i][j] += a[i + 1][j + 1]  # for i in range(1, n + 1):  #     print(a[i])  print(a[1][0])\n\nJava 解题代码\npackage com.company;import java.util.Scanner;public class Main {  static int [][]a=new int [101][101];  public static void main(String[] args) {      int n;      Scanner in = new Scanner(System.in);      n = in.nextInt();      //输入数字三角形的值      for (int i=1; i&lt;=n; i++)      {          for (int j=1; j&lt;=i; j++)          {              a[i][j]=in.nextInt(); //输入原始数据          }      }      //递推开始      for (int i=n-1; i&gt;=1; i--)//从最后一层逆推      {          for (int j=1; j&lt;=i; j++)          {              if (a[i+1][j]&gt;=a[i+1][j+1])                  a[i][j]+=a[i+1][j];     //路径选择              else  a[i][j]+=a[i+1][j+1];          }      }      System.out.println(a[1][1]);  }}\n\n总结我们这节课讲了递推与递归的知识点，并且也讲了何时采用递归设计程序，何时采用递推设计程序。对于多次询问的题目，也为大家展示了一种解决方法。\n对于递推算法，我们覆盖了正推和逆推两种方式。无论是递推和递归的关键在于找到关系式。\n希望同学能够独立完成题目进行练习。并且在后面的学习中会多次用到递归与递推设计其他算法。\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]二分","url":"/2024/03/11/DSA-Binary/","content":"二分查找算法知识点\n二分查找原理讲解\n在单调递增序列 a 中查找 x 或 x 的后继\n在单调递增序列 a 中查找 x 或 x 的前驱\n\n二分查找算法讲解枚举查找即顺序查找，实现原理是逐个比较数组 a[0:n-1] 中的元素，直到找到元素 x 或搜索整个数组后确定 x 不在其中。最坏情况下需要比较 N 次，时间复杂度是 O(n)，属于线性阶算法。\nclass Solution {      public int search(int[] nums, int target) {          int left = 0, right = nums.length;          while (left &lt; right) {              int mid = left + ((right - left) &gt;&gt; 1); // 无符号右移等同于除以2取整              if (nums[mid] == target)                  return mid;              else if (nums[mid] &lt; target)                  left = mid + 1;              else if (nums[mid] &gt; target)                  right = mid - 1; // 修改这里，应该是 mid - 1          }          return -1; // 如果循环结束还没有找到，说明目标值不存在于数组中      }  }\n\n折半查找的基本思想：\n在有序表中（low, high, low&lt;=high），取中间记录即 a[(high+low)/2] 作为比较对象。\n\n若给定值与中间记录的关键码相等，则查找成功。\n若给定值小于中间记录的关键码，则在中间记录的左半区继续查找。\n若给定值大于中间记录的关键码，则在中间记录的右半区继续查找。\n\n不断重复上述过程，直到查找成功或所查找的区域无记录，查找失败。\n二分查找的特征：\n\n答案具有单调性。\n二分答案的问题往往有固定的问法，例如：令最大值最小（最小值最大），求满足条件的最大（小）值等。\n\n折半查找一般过程：\n\nStep 1:假设存在一个有序数组：下标[ 0   1   2   3   4   5   6   7   8    9    10   11   12 ]数据[ 7   14  18  21  23  29  31  35   38   42   46   49  52 ]      ↑                                                   ↑    low=0                                              high=12                            mid=(low+high)/2                            mid=(0+12)/2                            mid=6                            [mid]=31 &gt; 14，所以选择左半部分操作：    此时令low不变，high=mid-1=5Step 2:下标[ 0   1   2   3   4   5   6   7   8    9    10   11   12 ]数据[ 7   14  18  21  23  29  31  35   38   42   46   49  52 ]      ↑                   ↑   low=0                 high=5            mid=(low+high)/2            mid=(0+6)/2            mid=3            [mid]=21 &gt; 14，所以选择左半部分操作：    此时令low不变，high=mid-1=2Step 3:下标[ 0   1   2   3   4   5   6   7   8    9    10   11   12 ]数据[ 7   14  18  21  23  29  31  35   38   42   46   49  52 ]      ↑       ↑   low=0    high=2            mid=(low+high)/2            mid=(0+2)/2            mid=1            [mid]=14 = 14  找到答案操作：    返回下标\n\n这个文本看起来更加清晰，修正了一些不规范的表达。\n整数二分法常用算法模板C++ 语言描述// 在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继）while (low &lt; high){    int mid = (low + high) / 2;    if (a[mid] &gt;= x)        high = mid;    else        low = mid + 1;}// 在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前驱）while (low &lt; high){    int mid = (low + high + 1) / 2;    if (a[mid] &lt;= x)        low = mid;    else        high = mid - 1;}\n\nPython 语言描述\n#在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继）while low&lt;high:  mid=(low+high)/2  if(a[mid]&gt;=x):      high=mid  else:      low=mid+1#在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前驱）while low&lt;high:  mid=(low+high+1)/2  if(a[mid]&lt;=x):      low=mid  else:      high = mid-1\n\nJava 语言描述\n// 在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继）while (low &lt; high) {    int mid = (low + high) / 2;    if (a[mid] &gt;= x)      high= mid;  else      low = mid + 1;}// 在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前驱）while (low &lt; high) {    int mid = (low + high + 1) / 2;    if (a[mid] &lt;= x)      low = mid;  else      high = mid - 1;}\n\n此处我们先分整数的二分查找法的常用模版，关于实数的部分，我们后面再讲。\n\n下面可能会有同学会疑问道：为什么采用这一套代码的而不是采用查找等于的 X？\n是因为这样的适用范围更广，当有 X 时这套代码就返回 X 的位置。如果没有 X，就返回 &lt;=x 的数中最大的一个或者 &gt;=x 的数中最小的一个。\n\n分巧克力2017 年省赛真题链接。\n题目描述: 儿童节那天有 K 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。\n小明一共有  块巧克力，其中第  块是  的方格组成的长方形。为了公平起见，\n小明需要从这  块巧克力中切出 K 块巧克力分给小朋友们。切出的巧克力需要满足：\n\n形状是正方形，边长是整数;\n大小相同;\n\n例如一块 6x5 的巧克力可以切出 6 块 2x2 的巧克力或者 2 块 3x3 的巧克力。\n当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？\n输入描述:\n第一行包含两个整数  ()。\n以下 N 行每行包含两个整数  ()。\n输入保证每位小朋友至少能获得一块 1x1 的巧克力。\n输出描述:\n输出切出的正方形巧克力最大可能的边长。\n输入输出样例:\n示例:\n\n输入\n\n2 10 6 5 5 6\n\n\n输出\n\n2\n\n运行限制:\n\n最大运行时间：2s\n最大运行内存: 256M\n\n注意：\n\n请严格按要求输出，不要画蛇添足地打印类似：“请您输入…”的多余内容。\n不要调用依赖于编译环境或操作系统的特殊函数。\n所有依赖的函数必须明确地在源文件中\n不能通过工程设置而省略常用头文件。\n\n题目分析简单思路，边长的最大规模为 ；我们可以枚举出所有的情况。按从大到小的顺序进行切割，直到找到满足要求的巧克力边长。\n在判断边长是否满足条件时：求一块长方形（）最多被分成的正方形（）巧克力个数为：\n\nimport osimport sysimport heapqa = []b = []n, k = map(int, input().split())for _ in range(n):    x, y = map(int, input().split())    a.append(x)    b.append(y)q = []for i in range(n - 1):    heapq.heappush(q, (a[i], i))t = kans = 0while t &gt; 0:    w, i = heapq.heappop(q)    heapq.heappush(q, (b[i], i))    ans += w    t -= 1ans2 = 0if k &gt;= n:    ans2 += sum(a) + (k - n) * min(b)if k &gt;= n:    print(min(ans, ans2))else:    print(ans)\n\n即用在单调递增序列  中查找  的数中最大的一个（即  或  的前驱）即可，原本这里的条件是  ，我们将其换成验证即可。\n代码解答C++ 实现：\n#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100010;int n,k;int h[MAXN],w[MAXN];bool pd(int l){    int sum=0;    for(int i=0; i&lt;n; i++)    {        sum+=(h[i]/l)*(w[i]/l);        if(sum&gt;=k)        {            return true;        }    }    return false;}int main(){    cin&gt;&gt;n&gt;&gt;k;    for(int i=0; i&lt;n; i++)        cin&gt;&gt;h[i]&gt;&gt;w[i];    //找到二分查找的上界    int high=0;    for(int i=0; i&lt;n; i++)    {        high=max(high,h[i]);        high=max(high,w[i]);    }    // 二分下届由题意可得至少为1    int low=1;    // 由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边    int mid=0;    while(low&lt;high)    {        mid = (low + high+1) / 2;        if(pd(mid))            low=mid;        else            high = mid - 1;//        cout&lt;&lt;low&lt;&lt;\" \"&lt;&lt;high&lt;&lt;endl;    }    //因为low=high所以输出哪一个都一样    cout&lt;&lt;low;    return 0;}\n\n查找上界这里可以直接输入的时候查询，这道题实际上是可以少次操作的，代码如下。\nPython 实现\nN=K=0h=[]w=[]def pd(l): sum1=0 for i in range(N):   sum1+= (h[i]//l)* (w[i]//l)   # Java C++ 的除法都是自己取整，Python会换成小数，Python的取整除法是//   if sum1&gt;=K :       return True return Falseif __name__ == '__main__':   inFor = input().split()   N=int(inFor[0])   K=int(inFor[1])   #找到二分查找的上界   high=0   for _ in range(N):       wi, hi = map(int, input().split())       w.append(wi)       h.append(hi)       high=max(high,max((hi,wi)))   # 二分下届由题意可得至少为1   low=1   #由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边   mid=0   while low&lt;high :       mid= int ( (low+high+1)//2)       if pd(mid):           low=mid       else:           high=mid-1   #因为low=high所以输出哪一个都一样   print(low)\n\nJava 实现\nimport java.util.Scanner;import static java.lang.Integer.max;public class Main {  static int n, k;  static int h[] = new int[100005];  static int w[] = new int[100005];  static boolean pd(int l) {      int sum = 0;      for (int i = 1; i &lt;= n; i++) {          sum += (h[i] / l) * (w[i] / l);          if (sum &gt;= k) {              return true;          }      }      return false;  }  public static void main(String[] args) {      Scanner in = new Scanner(System.in);      n = in.nextInt();      k = in.nextInt();      //找到二分查找的上界      int high = 0;      for (int i = 1; i &lt;= n; i++) {          h[i] = in.nextInt();          w[i] = in.nextInt();          high = max(high, h[i]);          high = max(high, w[i]);      }      // 二分下届由题意可得至少为1      int low = 1;      // 由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边      int mid = 0;      while (low &lt; high) {          mid = (low + high + 1) / 2;          if (pd(mid))              low = mid;          else              high = mid - 1;          //        cout&lt;&lt;low&lt;&lt;\" \"&lt;&lt;high&lt;&lt;endl      }      //因为low=high所以输出哪一个都一样      System.out.println(low);  }}\n\n模板中的 &lt;= 和 =&gt; 都可以换成其他判定条件，像上面根据题目分析即可。\nM 次方根题目描述:\n小 A 最近在学高等数学，他发现了一道题，求 。现在已知，小 A 开始计算， 的三次方得， 的三次方得， 的三次方得，然后他很高兴的填上了。\n接着他要求 。然后他开始 的三次方得， 的三次方得， 的三次方得…\n直到他算到了秃头，也没有找到答案。\n这时一旁的小 B 看不下去了，说这题答案又不是个整数。小 A 震惊，原来如此。作为程序高手的小 A，打算设计一个程序用于求解  次根下的值。\n但是由于要考虑精度范围，答案必须要保留  位小数，连三次根号下都要掰手指的小 A 又怎么会设计呢。请你帮小 A 设计一个程序用于求解  次根号。\n数据范围：\n  且 \n要求输入:\n输入描述:第一行输入整数 N 和 M，数据间用空格隔开。\n\n要求输出：\n输出描述: 输出一个整数，并保留 7 位小数。\n\n样例:\n输入样例：27 3输出样例：3.000000\n\n运行限制:\n最大运行时间：1s最大运行内存: 256M注意：1. 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。2. 不要调用依赖于编译环境或操作系统的特殊函数。3. 所有依赖的函数必须明确地在源文件中。4. 不能通过工程设置而省略常用头文件。\n\n题目分析前面讲的都是整数二分，其实二分法还是可以用于实数。这个题目比较难，很多同学可能想不明白，想不明白就多读题，写写画画理解一下。这个题还有很多解法，现在告诉你了这道理用二分可以解答，请设计一个二分程序。\n首先是这道题我们怎么下手：\n根据前面的知识，我们要找到一个具有单调性的数列，去二分。这个题的关键是我们要去二分什么，这里可以二分的是  中的 ，所以我们要先想办法设计出用于处理实数二分的代码。\n这里给大家两个模板，都可以大家选择一个使用即可：\nC++ 模版：\n//模版一：实数域二分，设置eps法//令 eps 为小于题目精度一个数即可。比如题目说保留4位小数，0.0001 这种的。那么 eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。//一般为了保证精度我们选取精度/100 的那个小数，即设置 eps= 0.0001/100 =1e-6while (l + eps &lt; r){    double mid = (l + r) / 2;    if (pd(mid))        r = mid;    else        l = mid;}//模版二：实数域二分，规定循环次数法//通过循环一定次数达到精度要求，这个一般 log2N &lt; 精度即可。N 为循环次数，在不超过时间复杂度的情况下，可以选择给 N 乘一个系数使得精度更高。    for (int i = 0; i &lt; 100; i++){    double mid = (l + r) / 2;    if (pd(mid))        r = mid;    else        l = mid;}\n\nPython 模版:\n# 实数域二分，设置eps法# 令eps 为小于题目精度一个数即可，比如题目说保留4位小数，0.0001 这种的。那么eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。一般为了保证精度我们选取精度/100 的那个小数eps = 1e-6while l + eps &lt; r:  mid = (l + r) / 2  if (pd(mid)):      r = mid  else:      l = mid# 实数域二分，规定循环次数法# 通过循环一定次数达到精度要求，这个一般 log2N&lt; 精度即可。N 为循环次数，在不超过时间复杂度的情况下，可以选择给N乘一个系数使得精度更高。for _ in range(100):  mid = (l + r) / 2  if (pd(mid)):      r = mid  else:      l = mid\n\nJava 模版:\n//令eps 为小于题目精度一个数即可。//比如题目说保留4位小数，0.0001 这种的。那么eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。一般为了保证精度我们选取精度 /100 的那个小数，即设置  eps= 0.0001/100 =1e-6。while (l + eps &lt; r) {    double mid = (l + r) / 2;    if (pd(mid))      r = mid;  else      l = mid;}// 实数域二分，规定循环次数法//通过循环一定次数达到精度要求，这个一般log2N&lt; 精度即可。N为循环次数，在不超过时间复杂度的情况下，可以选择给N乘一个系数使得精度更高。for (int i = 0; i &lt; 100; i++) {    double mid = (l + r) / 2;    if (pd(mid))      r = mid;  else      l = mid;}\n\n模板讲完了，然后我们就要考虑判定条件了，怎样判定是否存在满足大于平均值的区间。当然这个题你可以使用语言中自带开方软件，但是我们还是联系一下实数的二分代码。\n关于判定条件，我们应该设计一个代码用于比较  和  的大小关系。\n在我们代码中：\nif (pd(mid))    r = mid;else    l = mid;\n\n 成功的情况，一定是  的  符合条件，且小于  的一定符合条件。因此我们要在大于  中继续查找，找到更大的 。\n所以我们可以设计出如下判定条件:\ndouble pd(double a,int m){    double c=1;    while(m&gt;0)    {        c=c*a;        m--;    }    if(c&gt;=n)        return true;    else        return false;}\n\n代码解答C++ 实现：\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;iomanip&gt; //用于浮点数输出using namespace std;double n,l,r,mid;double eps=1e-8;bool pd(double a,int m){    double c=1;    while(m&gt;0)    {        c=c*a;        m--;    }    if(c&gt;=n)        return true;    else        return false;}int main(){    int m;    cin&gt;&gt;n&gt;&gt;m;//设置二分边界    l=0,r=n;//实数二分    while (l + eps &lt; r)    {        double mid = (l + r) / 2;        if (pd(mid,m))            r = mid;        else            l = mid;    }    cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l;    //一般使用print    //printf(\"%x.yf\",n)    //其中X是固定整数长度，小数点前的整数位数不够，会在前面补0    //y是保留小数位数，不够补零    //printf(\"%.7f\",l);    return 0;}\n\n查找上界这里可以直接输入的时候查询，这道题实际上是可以少次操作的，代码如下。\nPython 实现\nn = 0.0m = 0l = 0.0r = 0.0mid = 0.0eps = 0.00000001def pd(a, m):  c = 1.0  cnt = int(m)  while cnt &gt; 0:      c = c * a      cnt -= 1  if c &gt;= n:      return True  else:      return Falseif __name__ == '__main__':  n, m = input().split()  l = 0  r=n=int(n)  while l + eps &lt; r:      mid = (l + r) / 2      if (pd(mid, m)):          r = mid      else:          l = midprint(\"%.7f\" % l)\n\nJava 实现\npackage com.company;import java.util.Scanner;public class Main {  static double n, l, r, mid;  static double eps = 1e-8;  static boolean pd(double a, int m) {      double c = 1;      while (m &gt; 0) {          c = c * a;          m--;      }      if (c &gt;= n)          return true;      else          return false;  }  public static void main(String[] args) {      int m;      Scanner in =new Scanner(System.in);      n=in.nextDouble();      m=in.nextInt();//设置二分边界      l = 0;      r = n;//实数二分      while (l + eps &lt; r) {          double mid = (l + r) / 2;          if (pd(mid, m))              r = mid;          else              l = mid;      }      System.out.println(String.format(\"%.7f\",l));  /*   关于string.format 的应用  double num = 123.4567899;  System.out.print(String.format(\"%f %n\", num)); // 123.456790  System.out.print(String.format(\"%a %n\", num)); // 0x1.edd3c0bb46929p6  System.out.print(String.format(\"%g %n\", num)); // 123.457  可用标识：        -，在最小宽度内左对齐,不可以与0标识一起使用。        0，若内容长度不足最小宽度，则在左边用0来填充。        #，对8进制和16进制，8进制前添加一个0,16进制前添加0x。        +，结果总包含一个+或-号。        空格，正数前加空格，负数前加-号。        ,，只用与十进制，每3位数字间用,分隔。        (，若结果为负数，则用括号括住，且不显示符号。  可用转换符：        b，布尔类型，只要实参为非false的布尔类型，均格式化为字符串true，否则为字符串false。        n，平台独立的换行符, 也可通过System.getProperty(\"line.separator\")获取。        f，浮点数型（十进制）。显示9位有效数字，且会进行四舍五入。如99.99。        a，浮点数型（十六进制）。        e，指数类型。如9.38e+5。        g，浮点数型（比%f，%a长度短些，显示6位有效数字，且会进行四舍五入）   */  }}\n\n总结二分的题目主要是必须要求是单调的，一般会有条件等字眼。做这种题目主要还是找到递增或者递减的序列，然后关于序列的判定条件。或者通过观察时间复杂度来看是否可以使用二分，二分法的题目相对来说比较明显，设计起来也比较简单，模板不用死记硬背，理解一下，很快就可以独立写出来。\n二分法的使用场景：前提：有序数组，也就是需要排序，且数组中没有重复元素区间的定义：    左闭右闭[left,right]    左闭右开[left,right]针对上面两种区间，以下是两种二分的写法实现\n二分法的第一种写法定义target在一个左闭右闭[left,right]区间中满足：    while(left&lt;=right)    if(nums[middle]&gt;target)  right要赋值为middle-1\n# 定义 Solution 类class Solution:    def search(self, nums, target):        left = 0        right = len(nums) - 1        while left &lt;= right:            middle = left + (right - left) // 2            if nums[middle] &gt; target:                right = middle - 1            elif nums[middle] &lt; target:                left = middle + 1            else:                return middle        return -1# 创建 Solution 实例solution = Solution()# 调用 search 方法进行二分查找a = [-1, 0, 3, 5, 9, 10]target = 0result = solution.search(a, target)print(\"目标值在列表中的索引为:\", result)\n\nclass Solution {public:    int search(vector&lt;int&gt;&amp; nums, int target) {        int left = 0;        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]        while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;=            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2            if (nums[middle] &gt; target) {                right = middle - 1; // target 在左区间，所以[left, middle - 1]            } else if (nums[middle] &lt; target) {                left = middle + 1; // target 在右区间，所以[middle + 1, right]            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }};\n\nclass Solution {    public int search(int[] nums, int target) {        // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) {            return -1;        }        int left = 0, right = nums.length - 1;        while (left &lt;= right) {            int mid = left + ((right - left) &gt;&gt; 1);            if (nums[mid] == target)                return mid;            else if (nums[mid] &lt; target)                left = mid + 1;            else if (nums[mid] &gt; target)                right = mid - 1;        }        return -1;    }}\n\n二分法的第二种写法定义target在一个左闭右开[left,right]区间中满足：    while(left&lt;right)    if(nums[middle]&gt;target)  right要赋值为middle\n# 定义 Solution 类class Solution:    def search(self, nums, target):        left = 0        right = len(nums) - 1        while left &lt; right:            middle = left + (right - left) // 2            if nums[middle] &gt; target:                right = middle            elif nums[middle] &lt; target:                left = middle + 1            else:                return middle        return -1# 创建 Solution 实例solution = Solution()# 调用 search 方法进行二分查找a = [-1, 0, 3, 5, 9, 10]target = 0result = solution.search(a, target)print(\"目标值在列表中的索引为:\", result)\n\nclass Solution {public:    int search(vector&lt;int&gt;&amp; nums, int target) {        int left = 0;        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)        while (left &lt; right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;            int middle = left + ((right - left) &gt;&gt; 1);            if (nums[middle] &gt; target) {                right = middle; // target 在左区间，在[left, middle)中            } else if (nums[middle] &lt; target) {                left = middle + 1; // target 在右区间，在[middle + 1, right)中            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }};\n\nclass Solution {    public int search(int[] nums, int target) {        int left = 0, right = nums.length;        while (left &lt; right) {            int mid = left + ((right - left) &gt;&gt; 1);            if (nums[mid] == target)                return mid;            else if (nums[mid] &lt; target)                left = mid + 1;            else if (nums[mid] &gt; target)                right = mid;        }        return -1;    }}\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]手算与思维题","url":"/2024/03/10/DSA-MM-and-BT/","content":"手算与思维题课程伊始，我们先要讲一下蓝桥杯相关的注意事项。\n比赛流程赛程：\n省赛\n决赛\n\n省赛一等奖参加决赛\n比赛时长  小时\n竞赛形式：\n个人赛，一人一机，全程机考\n答题过程中无法访问互联网\n不允许携带任何电子、纸质资料\n\n参赛选手机器环境\nX86 兼容机器，内存不小于 1G，硬盘不小于 60G 操作系统：Windows7、Windows8 或 Windows10。\nC/C++ 开发环境：Dev-cpp 5.4.0 C/C++ API 帮助文档\nJava 开发环境：JDK 1.8 Eclipse-java-2020-06 API 帮助文档\nPython 环境：Python 3.8.6 IDLE（Python 自带编辑器）\n\n题型\n结果填空 把答案直接通过网页提交，不要书写多余的内容。填空题每题  分。\n\n程序设计 每道题目多个测试数据， 是弱测试数据，其他是强测试数据。 题量大、时间紧张，难题往往不会做或来不及用高效算法编码，此时可以用暴力方法编程得  的分数。 程序设计题每题  分。\n\n\n评分方式评分：全部使用机器自动评分\n对于结果填空题，题目保证只有唯一解，选手的结果只有和解完全相同才得分，出现格式错误或有多余内容时不得分。\n对于编程大题，评测系统将使用多个评测数据来测试程序。每个评测数据有对应的分数。选手所提交的程序将分别用每个评测数据作为输入来运行。对于某个评测数据，如果选手程序的输出与正确答案是匹配的，则选手获得该评测数据的分数。\n知识点梳理（1）思维题（杂题）：不需要算法和数据结构，只需要逻辑、推理的题目，难度可难可易。考察思维能力和编码能力，只能通过大量做题来提高。\n（2）BFS 搜索和 DFS 搜索：也就是暴力搜索。这是非常基本的算法，是基础中的基础。\n（3）动态规划：线性 DP，以及一些 DP 应用，例如状态压缩 DP、树形 DP 等。\n（4）简单数学和简单数论。\n（5）简单的字符串处理、输入输出，简单图论。\n（6）基本算法：例如排序、排列、二分、倍增、差分、贪心。\n（7）基本数据结构：队列、栈、链表、二叉树等。\n技巧：手算\n应用场合：填空题\n手算的目的：减少做题时间，省下时间做编程题。\n\n手段：\n\n不编码，或者只做部分编码\n用推理获得答案\n用软件工具帮助计算\n\n方法：\n\n巧用编辑器\n心算手数\n巧用 Excel\n巧用 Python\n\n例题1. 门牌制作 2020 年第十一届蓝桥杯省赛，填空题问题描述： 从  到  的所有数字中，共有多少个 ？\n\n先编码连续打印出    这  个数字\n然后粘贴到任何一个编辑器中\n选查询或替换功能，查找或替换字符 “”，共  次，就是答案。\n\n简单直接，不用思考\n2. 迷宫 2017 年第八届蓝桥杯省赛，填空题问题描述： 给出一个迷宫，问迷宫内的人有多少能走出来。迷宫如右图所示：每个位置上有一个人，共  人。每个位置有指示牌， 表示向左走， 表示向右走， 表示向上走， 表示向下走。\nUDDLUULRUL   UURLLLRRRU    RRUURLDLRD    RUDDDDUUUU    URUDLLRRUU    DURLRLDLRL    ULLURLLRDU    RDLULLRDDD    UUDDUDUDLL    ULRDLUURRR\n\n\n正解：DFS 搜索，编码 10 分钟。\n技巧：直接用手画图标记 3-5 分钟。\n\n3. 星期一 2017 年第八届蓝桥杯省赛，填空题问题描述： 整个 20 世纪（ 年  月  日至  年  月  日之间），一共有多少个星期一？\n思路： 用 Excel，在一个格子里输入日期  年  月  日，另一个格子输入  年  月  日，然后两个格子相减得  天，除以  得  周。\n再看  年  月  日是星期几。\n用 Excel 点  年  月  日这一格的“设置单元格式-数字-日期-星期三”，点击“确定”，得“星期二”，即  年  月  日是星期二， 是  周多几天，最后几天没有星期一，说明答案就是 。\n也可以直接利用 Excel“单元格格式”对话框得出  年  月  日刚好是星期天，从星期二至星期天之间没有星期一。\n巧用 Python填空题遇到字符、大数字、日期问题，Python 是首选。\n•即使参加 C/C++、Java 组比赛，也要学一些 Python，以方便手算，或用来做对比测试。\n•这几种语言的编译器，在比赛机器上都有。\n•写 Python 代码既简单又快，代码长度一般比 C/C++、Java 短很多。例如 30 行的 C++代码，用 Python 写只需要 20 行。\n3. 星期一 2017 年第八届蓝桥杯省赛，填空题\n问题描述： 整个 20 世纪(1901 年 1 月 1 日至 2000 年 12 月 31 日之间)，一共有多少个星期一？\n直接用 Python datetime 库求解，第 4 行可以输出某个日期是星期几。\nfrom datetime import* dt1=datetime(1901,1,1) dt2=datetime(2000,12,31) print(dt1.weekday()) # 周一为0，周二为1... td=dt2-dt1 print(td.days//7)\n\n相对应的使用 C++同样可以完成，但是编码复杂：\n#include &lt;iostream&gt; using namespace std; int res; //先判断润年 bool is_r(int n){     if((n % 4 == 0 &amp;&amp; n % 100 != 0) || n % 400 == 0) return true; return false; } int main(){     for(int i = 1901;i &lt;= 2000;i ++)         if(is_r(i)) res += 366;     else res += 365;     int x = res / 7;     cout &lt;&lt; x &lt;&lt; endl;    return 0; }\n\n4. 乘积尾零 2018 年第九届蓝桥杯省赛\n【问题描述】 给出  个整数（这里省略题目给的  个数），问它们乘积的末尾有多少个零。\n最简单题解：\n\n直接连乘：几千位的大数\n然后统计末尾的 \n\n\n但是 C++ 装不下这么大的数字，所以要进行处理：\n#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int cnt2=0,cnt5=0;    for (int i=1;i&lt;=10;i++) {        for (int j=1;j&lt;=10;j++) {             int x;             cin&gt;&gt;x;            while (x%2==0) cnt2++,x/=2;             while (x%5==0) cnt5++,x/=5;         }     }     cout&lt;&lt;min(cnt2,cnt5)&lt;&lt;'\\n';    return 0; }\n\n发现编码时间变长了，如果填空题且 Java 学的好一点的，可以直接 Python 编程出结果。\n思维题\n不需要涉及某种算法的题目。\n只要学过编程语言，就能够解答。\n主要考核学生的思维、逻辑和编码能力，强调脑筋急转弯的解决方式。\n这类题目包括模拟题、构造题、思维题以及找规律题，统称为“思维题（杂题）”。\n每年蓝桥杯都会设置这类题目，而且可能有多道，是考试中的重要得分点。\n杂题涵盖了各种难度，有些可能相对简单，而另一些可能相对较难。\n\n5. 付账问题 2018 年第九届蓝桥杯省赛，lanqiaoOJ 题号 174\n【题目描述】\n现在有  个人出去吃饭，他们总共消费了  元。其中第  个人带了 元。幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？\n为了公平起见，我们希望在总付钱量恰好为  的前提下，最后每个人付的钱的标准差最小。这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 1 分钱的整数倍。你需要输出最小的标准差是多少。\n标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的”偏差有多大”。形式化地说，设第  个人付的钱为  元，那么标准差为 :\n\n解决思路：\n如果每个人携带的钱足够多，每个人平均支付相同的金额，即 ，那么标准差  为 。\n然而，总会有人的钱不够，这时我们考虑两种情况：\n（1）第  个人携带的钱不足以达到平均数 ，那么他只能支付他所携带的全部钱 。\n（2）第  个人携带的钱超过平均数 ，那么他可以支付多一些。\n解决步骤：\n（1）对  进行从小到大的排序；\n（2）前一部分人的钱不足以支付平均数，因此他们每个人支付所有携带的钱；\n（3）从总支付数中减去前一部分人支付的钱，得到剩余金额 ，以及后一部分人的平均支付数 。\n（4）后一部分人携带的钱较多，他们可以支付多一些。这部分人又可以分为两类：\n\n（i）相对富裕但仍然不足以支付  的人，他们需要支付所有携带的钱；\n（ii）非常富裕的人，无论如何摊分，他们都有余额。\n\n由于前面一部分人不足以支付 ，因此后面足够支付  的人不能只支付 。相反，他们应该尽可能地每个人支付相同的金额。\n因为有人支付不足，总有人支付过多，由于是标准差（方差的平方根），因此每个人支付的金额差距越小越好。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 5e5;long long a[M];int main(){    int n;  long long s;    scanf(\"%d %lld\",&amp;n,&amp;s);    for(int i=1;i&lt;=n;i++)  scanf(\"%lld\",&amp;a[i]);    sort(a+1,a+n+1);       //排序，从小到大    double avg = 1.0*s/n;  //平均值    double sum = 0.0;    for(int i=1;i&lt;=n;i++){        if(a[i]*(n+1-i) &lt; s){//需要把钱全拿出的人：//（1）钱不够平均数的，（2）钱够平均数，但也不是很多的            sum += (a[i]-avg)*(a[i]-avg);            s -= a[i];            //更新剩余钱数        }        else{      //不用把钱全拿出的人：非常有钱，不管怎么平均都够            double cur_avg = 1.0*s/(n+1-i);    //更新平均出钱数            sum += (cur_avg-avg)*(cur_avg-avg)*(n+1-i);            break;        }    }    printf(\"%.4lf\",sqrt(sum/n));    return 0;}\n\nfrom math import *n, s = map(int,input().split())a = list(map(int,input().split()))a.sort()avg = s/nsum = 0for i in range(n):     if a[i]*(n-i) &lt; s:          sum += pow(a[i]-avg,2)          s -= a[i]     else:          cur_avg = s/(n-i);      #更新平均出钱数          sum += pow(cur_avg-avg,2)*(n-i)          breakprint(\"{:.4f}\".format(sqrt(sum/(n))))\n\nimport java.io.FileNotFoundException;import java.util.Arrays;import java.util.Scanner;public class Main {public static void main(String args[]) {        int n;        long S;        double ans=0,avg;        Scanner input=new Scanner(System.in);        n=input.nextInt();        S=input.nextLong();        long a[]=new long[n];        for(int i=0;i&lt;n;i++)                    a[i]=input.nextLong();        Arrays.sort(a);        avg=(double)S/n;        for(int i=0;i&lt;n;i++) {            if(S&lt;=(n-i)*a[i]) {                ans += (n-i)*Math.pow((double)S/(n-i)-avg,2);                break;            }            ans += Math.pow(a[i]-avg,2);            S -= a[i];        }        System.out.printf(\"%.4f\\n\",Math.sqrt(ans/n));    }}\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]}]