[{"title":"[数据结构与算法]二分","url":"/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/","content":"二分查找算法知识点\n二分查找原理讲解\n在单调递增序列 a 中查找 x 或 x 的后继\n在单调递增序列 a 中查找 x 或 x 的前驱\n\n二分查找算法讲解枚举查找即顺序查找，实现原理是逐个比较数组 a[0:n-1] 中的元素，直到找到元素 x 或搜索整个数组后确定 x 不在其中。最坏情况下需要比较 N 次，时间复杂度是 O(n)，属于线性阶算法。\nclass Solution {      public int search(int[] nums, int target) {          int left = 0, right = nums.length;          while (left &lt; right) {              int mid = left + ((right - left) &gt;&gt; 1); // 无符号右移等同于除以2取整              if (nums[mid] == target)                  return mid;              else if (nums[mid] &lt; target)                  left = mid + 1;              else if (nums[mid] &gt; target)                  right = mid - 1; // 修改这里，应该是 mid - 1          }          return -1; // 如果循环结束还没有找到，说明目标值不存在于数组中      }  }\n\n折半查找的基本思想：\n在有序表中（low, high, low&lt;=high），取中间记录即 a[(high+low)/2] 作为比较对象。\n\n若给定值与中间记录的关键码相等，则查找成功。\n若给定值小于中间记录的关键码，则在中间记录的左半区继续查找。\n若给定值大于中间记录的关键码，则在中间记录的右半区继续查找。\n\n不断重复上述过程，直到查找成功或所查找的区域无记录，查找失败。\n二分查找的特征：\n\n答案具有单调性。\n二分答案的问题往往有固定的问法，例如：令最大值最小（最小值最大），求满足条件的最大（小）值等。\n\n折半查找一般过程：\n\nStep 1:假设存在一个有序数组：下标[ 0   1   2   3   4   5   6   7   8    9    10   11   12 ]数据[ 7   14  18  21  23  29  31  35   38   42   46   49  52 ]      ↑                                                   ↑    low=0                                              high=12                            mid=(low+high)/2                            mid=(0+12)/2                            mid=6                            [mid]=31 &gt; 14，所以选择左半部分操作：    此时令low不变，high=mid-1=5Step 2:下标[ 0   1   2   3   4   5   6   7   8    9    10   11   12 ]数据[ 7   14  18  21  23  29  31  35   38   42   46   49  52 ]      ↑                   ↑   low=0                 high=5            mid=(low+high)/2            mid=(0+6)/2            mid=3            [mid]=21 &gt; 14，所以选择左半部分操作：    此时令low不变，high=mid-1=2Step 3:下标[ 0   1   2   3   4   5   6   7   8    9    10   11   12 ]数据[ 7   14  18  21  23  29  31  35   38   42   46   49  52 ]      ↑       ↑   low=0    high=2            mid=(low+high)/2            mid=(0+2)/2            mid=1            [mid]=14 = 14  找到答案操作：    返回下标\n\n这个文本看起来更加清晰，修正了一些不规范的表达。\n整数二分法常用算法模板C++ 语言描述// 在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继）while (low &lt; high){    int mid = (low + high) / 2;    if (a[mid] &gt;= x)        high = mid;    else        low = mid + 1;}// 在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前驱）while (low &lt; high){    int mid = (low + high + 1) / 2;    if (a[mid] &lt;= x)        low = mid;    else        high = mid - 1;}\n\nPython 语言描述\n#在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继）while low&lt;high:  mid=(low+high)/2  if(a[mid]&gt;=x):      high=mid  else:      low=mid+1#在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前驱）while low&lt;high:  mid=(low+high+1)/2  if(a[mid]&lt;=x):      low=mid  else:      high = mid-1\n\nJava 语言描述\n// 在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继）while (low &lt; high) {    int mid = (low + high) / 2;    if (a[mid] &gt;= x)      high= mid;  else      low = mid + 1;}// 在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前驱）while (low &lt; high) {    int mid = (low + high + 1) / 2;    if (a[mid] &lt;= x)      low = mid;  else      high = mid - 1;}\n\n此处我们先分整数的二分查找法的常用模版，关于实数的部分，我们后面再讲。\n\n下面可能会有同学会疑问道：为什么采用这一套代码的而不是采用查找等于的 X？\n是因为这样的适用范围更广，当有 X 时这套代码就返回 X 的位置。如果没有 X，就返回 &lt;=x 的数中最大的一个或者 &gt;=x 的数中最小的一个。\n\n分巧克力2017 年省赛真题链接。\n题目描述: 儿童节那天有 K 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。\n小明一共有  块巧克力，其中第  块是  的方格组成的长方形。为了公平起见，\n小明需要从这  块巧克力中切出 K 块巧克力分给小朋友们。切出的巧克力需要满足：\n\n形状是正方形，边长是整数;\n大小相同;\n\n例如一块 6x5 的巧克力可以切出 6 块 2x2 的巧克力或者 2 块 3x3 的巧克力。\n当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？\n输入描述:\n第一行包含两个整数  ()。\n以下 N 行每行包含两个整数  ()。\n输入保证每位小朋友至少能获得一块 1x1 的巧克力。\n输出描述:\n输出切出的正方形巧克力最大可能的边长。\n输入输出样例:\n示例:\n\n输入\n\n2 10 6 5 5 6\n\n\n输出\n\n2\n\n运行限制:\n\n最大运行时间：2s\n最大运行内存: 256M\n\n注意：\n\n请严格按要求输出，不要画蛇添足地打印类似：“请您输入…”的多余内容。\n不要调用依赖于编译环境或操作系统的特殊函数。\n所有依赖的函数必须明确地在源文件中\n不能通过工程设置而省略常用头文件。\n\n题目分析简单思路，边长的最大规模为 ；我们可以枚举出所有的情况。按从大到小的顺序进行切割，直到找到满足要求的巧克力边长。\n在判断边长是否满足条件时：求一块长方形（）最多被分成的正方形（）巧克力个数为：\n\nimport osimport sysimport heapqa = []b = []n, k = map(int, input().split())for _ in range(n):    x, y = map(int, input().split())    a.append(x)    b.append(y)q = []for i in range(n - 1):    heapq.heappush(q, (a[i], i))t = kans = 0while t &gt; 0:    w, i = heapq.heappop(q)    heapq.heappush(q, (b[i], i))    ans += w    t -= 1ans2 = 0if k &gt;= n:    ans2 += sum(a) + (k - n) * min(b)if k &gt;= n:    print(min(ans, ans2))else:    print(ans)\n\n即用在单调递增序列  中查找  的数中最大的一个（即  或  的前驱）即可，原本这里的条件是  ，我们将其换成验证即可。\n代码解答C++ 实现：\n#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100010;int n,k;int h[MAXN],w[MAXN];bool pd(int l){    int sum=0;    for(int i=0; i&lt;n; i++)    {        sum+=(h[i]/l)*(w[i]/l);        if(sum&gt;=k)        {            return true;        }    }    return false;}int main(){    cin&gt;&gt;n&gt;&gt;k;    for(int i=0; i&lt;n; i++)        cin&gt;&gt;h[i]&gt;&gt;w[i];    //找到二分查找的上界    int high=0;    for(int i=0; i&lt;n; i++)    {        high=max(high,h[i]);        high=max(high,w[i]);    }    // 二分下届由题意可得至少为1    int low=1;    // 由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边    int mid=0;    while(low&lt;high)    {        mid = (low + high+1) / 2;        if(pd(mid))            low=mid;        else            high = mid - 1;//        cout&lt;&lt;low&lt;&lt;\" \"&lt;&lt;high&lt;&lt;endl;    }    //因为low=high所以输出哪一个都一样    cout&lt;&lt;low;    return 0;}\n\n查找上界这里可以直接输入的时候查询，这道题实际上是可以少次操作的，代码如下。\nPython 实现\nN=K=0h=[]w=[]def pd(l): sum1=0 for i in range(N):   sum1+= (h[i]//l)* (w[i]//l)   # Java C++ 的除法都是自己取整，Python会换成小数，Python的取整除法是//   if sum1&gt;=K :       return True return Falseif __name__ == '__main__':   inFor = input().split()   N=int(inFor[0])   K=int(inFor[1])   #找到二分查找的上界   high=0   for _ in range(N):       wi, hi = map(int, input().split())       w.append(wi)       h.append(hi)       high=max(high,max((hi,wi)))   # 二分下届由题意可得至少为1   low=1   #由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边   mid=0   while low&lt;high :       mid= int ( (low+high+1)//2)       if pd(mid):           low=mid       else:           high=mid-1   #因为low=high所以输出哪一个都一样   print(low)\n\nJava 实现\nimport java.util.Scanner;import static java.lang.Integer.max;public class Main {  static int n, k;  static int h[] = new int[100005];  static int w[] = new int[100005];  static boolean pd(int l) {      int sum = 0;      for (int i = 1; i &lt;= n; i++) {          sum += (h[i] / l) * (w[i] / l);          if (sum &gt;= k) {              return true;          }      }      return false;  }  public static void main(String[] args) {      Scanner in = new Scanner(System.in);      n = in.nextInt();      k = in.nextInt();      //找到二分查找的上界      int high = 0;      for (int i = 1; i &lt;= n; i++) {          h[i] = in.nextInt();          w[i] = in.nextInt();          high = max(high, h[i]);          high = max(high, w[i]);      }      // 二分下届由题意可得至少为1      int low = 1;      // 由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边      int mid = 0;      while (low &lt; high) {          mid = (low + high + 1) / 2;          if (pd(mid))              low = mid;          else              high = mid - 1;          //        cout&lt;&lt;low&lt;&lt;\" \"&lt;&lt;high&lt;&lt;endl      }      //因为low=high所以输出哪一个都一样      System.out.println(low);  }}\n\n模板中的 &lt;= 和 =&gt; 都可以换成其他判定条件，像上面根据题目分析即可。\nM 次方根题目描述:\n小 A 最近在学高等数学，他发现了一道题，求 。现在已知，小 A 开始计算， 的三次方得， 的三次方得， 的三次方得，然后他很高兴的填上了。\n接着他要求 。然后他开始 的三次方得， 的三次方得， 的三次方得…\n直到他算到了秃头，也没有找到答案。\n这时一旁的小 B 看不下去了，说这题答案又不是个整数。小 A 震惊，原来如此。作为程序高手的小 A，打算设计一个程序用于求解  次根下的值。\n但是由于要考虑精度范围，答案必须要保留  位小数，连三次根号下都要掰手指的小 A 又怎么会设计呢。请你帮小 A 设计一个程序用于求解  次根号。\n数据范围：\n  且 \n要求输入:\n输入描述:第一行输入整数 N 和 M，数据间用空格隔开。\n\n要求输出：\n输出描述: 输出一个整数，并保留 7 位小数。\n\n样例:\n输入样例：27 3输出样例：3.000000\n\n运行限制:\n最大运行时间：1s最大运行内存: 256M注意：1. 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。2. 不要调用依赖于编译环境或操作系统的特殊函数。3. 所有依赖的函数必须明确地在源文件中。4. 不能通过工程设置而省略常用头文件。\n\n题目分析前面讲的都是整数二分，其实二分法还是可以用于实数。这个题目比较难，很多同学可能想不明白，想不明白就多读题，写写画画理解一下。这个题还有很多解法，现在告诉你了这道理用二分可以解答，请设计一个二分程序。\n首先是这道题我们怎么下手：\n根据前面的知识，我们要找到一个具有单调性的数列，去二分。这个题的关键是我们要去二分什么，这里可以二分的是  中的 ，所以我们要先想办法设计出用于处理实数二分的代码。\n这里给大家两个模板，都可以大家选择一个使用即可：\nC++ 模版：\n//模版一：实数域二分，设置eps法//令 eps 为小于题目精度一个数即可。比如题目说保留4位小数，0.0001 这种的。那么 eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。//一般为了保证精度我们选取精度/100 的那个小数，即设置 eps= 0.0001/100 =1e-6while (l + eps &lt; r){    double mid = (l + r) / 2;    if (pd(mid))        r = mid;    else        l = mid;}//模版二：实数域二分，规定循环次数法//通过循环一定次数达到精度要求，这个一般 log2N &lt; 精度即可。N 为循环次数，在不超过时间复杂度的情况下，可以选择给 N 乘一个系数使得精度更高。    for (int i = 0; i &lt; 100; i++){    double mid = (l + r) / 2;    if (pd(mid))        r = mid;    else        l = mid;}\n\nPython 模版:\n# 实数域二分，设置eps法# 令eps 为小于题目精度一个数即可，比如题目说保留4位小数，0.0001 这种的。那么eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。一般为了保证精度我们选取精度/100 的那个小数eps = 1e-6while l + eps &lt; r:  mid = (l + r) / 2  if (pd(mid)):      r = mid  else:      l = mid# 实数域二分，规定循环次数法# 通过循环一定次数达到精度要求，这个一般 log2N&lt; 精度即可。N 为循环次数，在不超过时间复杂度的情况下，可以选择给N乘一个系数使得精度更高。for _ in range(100):  mid = (l + r) / 2  if (pd(mid)):      r = mid  else:      l = mid\n\nJava 模版:\n//令eps 为小于题目精度一个数即可。//比如题目说保留4位小数，0.0001 这种的。那么eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。一般为了保证精度我们选取精度 /100 的那个小数，即设置  eps= 0.0001/100 =1e-6。while (l + eps &lt; r) {    double mid = (l + r) / 2;    if (pd(mid))      r = mid;  else      l = mid;}// 实数域二分，规定循环次数法//通过循环一定次数达到精度要求，这个一般log2N&lt; 精度即可。N为循环次数，在不超过时间复杂度的情况下，可以选择给N乘一个系数使得精度更高。for (int i = 0; i &lt; 100; i++) {    double mid = (l + r) / 2;    if (pd(mid))      r = mid;  else      l = mid;}\n\n模板讲完了，然后我们就要考虑判定条件了，怎样判定是否存在满足大于平均值的区间。当然这个题你可以使用语言中自带开方软件，但是我们还是联系一下实数的二分代码。\n关于判定条件，我们应该设计一个代码用于比较  和  的大小关系。\n在我们代码中：\nif (pd(mid))    r = mid;else    l = mid;\n\n 成功的情况，一定是  的  符合条件，且小于  的一定符合条件。因此我们要在大于  中继续查找，找到更大的 。\n所以我们可以设计出如下判定条件:\ndouble pd(double a,int m){    double c=1;    while(m&gt;0)    {        c=c*a;        m--;    }    if(c&gt;=n)        return true;    else        return false;}\n\n代码解答C++ 实现：\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;iomanip&gt; //用于浮点数输出using namespace std;double n,l,r,mid;double eps=1e-8;bool pd(double a,int m){    double c=1;    while(m&gt;0)    {        c=c*a;        m--;    }    if(c&gt;=n)        return true;    else        return false;}int main(){    int m;    cin&gt;&gt;n&gt;&gt;m;//设置二分边界    l=0,r=n;//实数二分    while (l + eps &lt; r)    {        double mid = (l + r) / 2;        if (pd(mid,m))            r = mid;        else            l = mid;    }    cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l;    //一般使用print    //printf(\"%x.yf\",n)    //其中X是固定整数长度，小数点前的整数位数不够，会在前面补0    //y是保留小数位数，不够补零    //printf(\"%.7f\",l);    return 0;}\n\n查找上界这里可以直接输入的时候查询，这道题实际上是可以少次操作的，代码如下。\nPython 实现\nn = 0.0m = 0l = 0.0r = 0.0mid = 0.0eps = 0.00000001def pd(a, m):  c = 1.0  cnt = int(m)  while cnt &gt; 0:      c = c * a      cnt -= 1  if c &gt;= n:      return True  else:      return Falseif __name__ == '__main__':  n, m = input().split()  l = 0  r=n=int(n)  while l + eps &lt; r:      mid = (l + r) / 2      if (pd(mid, m)):          r = mid      else:          l = midprint(\"%.7f\" % l)\n\nJava 实现\npackage com.company;import java.util.Scanner;public class Main {  static double n, l, r, mid;  static double eps = 1e-8;  static boolean pd(double a, int m) {      double c = 1;      while (m &gt; 0) {          c = c * a;          m--;      }      if (c &gt;= n)          return true;      else          return false;  }  public static void main(String[] args) {      int m;      Scanner in =new Scanner(System.in);      n=in.nextDouble();      m=in.nextInt();//设置二分边界      l = 0;      r = n;//实数二分      while (l + eps &lt; r) {          double mid = (l + r) / 2;          if (pd(mid, m))              r = mid;          else              l = mid;      }      System.out.println(String.format(\"%.7f\",l));  /*   关于string.format 的应用  double num = 123.4567899;  System.out.print(String.format(\"%f %n\", num)); // 123.456790  System.out.print(String.format(\"%a %n\", num)); // 0x1.edd3c0bb46929p6  System.out.print(String.format(\"%g %n\", num)); // 123.457  可用标识：        -，在最小宽度内左对齐,不可以与0标识一起使用。        0，若内容长度不足最小宽度，则在左边用0来填充。        #，对8进制和16进制，8进制前添加一个0,16进制前添加0x。        +，结果总包含一个+或-号。        空格，正数前加空格，负数前加-号。        ,，只用与十进制，每3位数字间用,分隔。        (，若结果为负数，则用括号括住，且不显示符号。  可用转换符：        b，布尔类型，只要实参为非false的布尔类型，均格式化为字符串true，否则为字符串false。        n，平台独立的换行符, 也可通过System.getProperty(\"line.separator\")获取。        f，浮点数型（十进制）。显示9位有效数字，且会进行四舍五入。如99.99。        a，浮点数型（十六进制）。        e，指数类型。如9.38e+5。        g，浮点数型（比%f，%a长度短些，显示6位有效数字，且会进行四舍五入）   */  }}\n\n总结二分的题目主要是必须要求是单调的，一般会有条件等字眼。做这种题目主要还是找到递增或者递减的序列，然后关于序列的判定条件。或者通过观察时间复杂度来看是否可以使用二分，二分法的题目相对来说比较明显，设计起来也比较简单，模板不用死记硬背，理解一下，很快就可以独立写出来。\n二分法的使用场景：前提：有序数组，也就是需要排序，且数组中没有重复元素区间的定义：    左闭右闭[left,right]    左闭右开[left,right]针对上面两种区间，以下是两种二分的写法实现\n二分法的第一种写法定义target在一个左闭右闭[left,right]区间中满足：    while(left&lt;=right)    if(nums[middle]&gt;target)  right要赋值为middle-1\n# 定义 Solution 类class Solution:    def search(self, nums, target):        left = 0        right = len(nums) - 1        while left &lt;= right:            middle = left + (right - left) // 2            if nums[middle] &gt; target:                right = middle - 1            elif nums[middle] &lt; target:                left = middle + 1            else:                return middle        return -1# 创建 Solution 实例solution = Solution()# 调用 search 方法进行二分查找a = [-1, 0, 3, 5, 9, 10]target = 0result = solution.search(a, target)print(\"目标值在列表中的索引为:\", result)\n\nclass Solution {public:    int search(vector&lt;int&gt;&amp; nums, int target) {        int left = 0;        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]        while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;=            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2            if (nums[middle] &gt; target) {                right = middle - 1; // target 在左区间，所以[left, middle - 1]            } else if (nums[middle] &lt; target) {                left = middle + 1; // target 在右区间，所以[middle + 1, right]            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }};\n\nclass Solution {    public int search(int[] nums, int target) {        // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) {            return -1;        }        int left = 0, right = nums.length - 1;        while (left &lt;= right) {            int mid = left + ((right - left) &gt;&gt; 1);            if (nums[mid] == target)                return mid;            else if (nums[mid] &lt; target)                left = mid + 1;            else if (nums[mid] &gt; target)                right = mid - 1;        }        return -1;    }}\n\n二分法的第二种写法定义target在一个左闭右开[left,right]区间中满足：    while(left&lt;right)    if(nums[middle]&gt;target)  right要赋值为middle\n# 定义 Solution 类class Solution:    def search(self, nums, target):        left = 0        right = len(nums) - 1        while left &lt; right:            middle = left + (right - left) // 2            if nums[middle] &gt; target:                right = middle            elif nums[middle] &lt; target:                left = middle + 1            else:                return middle        return -1# 创建 Solution 实例solution = Solution()# 调用 search 方法进行二分查找a = [-1, 0, 3, 5, 9, 10]target = 0result = solution.search(a, target)print(\"目标值在列表中的索引为:\", result)\n\nclass Solution {public:    int search(vector&lt;int&gt;&amp; nums, int target) {        int left = 0;        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)        while (left &lt; right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;            int middle = left + ((right - left) &gt;&gt; 1);            if (nums[middle] &gt; target) {                right = middle; // target 在左区间，在[left, middle)中            } else if (nums[middle] &lt; target) {                left = middle + 1; // target 在右区间，在[middle + 1, right)中            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }};\n\nclass Solution {    public int search(int[] nums, int target) {        int left = 0, right = nums.length;        while (left &lt; right) {            int mid = left + ((right - left) &gt;&gt; 1);            if (nums[mid] == target)                return mid;            else if (nums[mid] &lt; target)                left = mid + 1;            else if (nums[mid] &gt; target)                right = mid;        }        return -1;    }}\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[Vue2]基础入门","url":"/2024/07/01/Vue2-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","content":"01.Vue简介\n02.第一个Vue程序官方文档\n\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;        &lt;body&gt;        &lt;div id=\"app\"&gt;            {{message}}        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    message: 'Hello Vue!'                }            })        &lt;/script&gt;    &lt;/body&gt;    &lt;/head&gt;&lt;/html&gt;\n\n\n03.el挂载点el挂载可以使用各种选择器，但是建议使用id选择器，还有就是el不能挂载在body和html标签上。\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;el: 挂载点&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;        &lt;body&gt;        &lt;div id=\"app\"&gt;            {{message}}            &lt;div&gt;{{message}}&lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                                el: '#app',                data: {                    message: 'Hello Vue!'                }            })        &lt;/script&gt;    &lt;/body&gt;    &lt;/head&gt;&lt;/html&gt;\n\n\n04.data数据对象\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;/meta&gt;        &lt;/meta&gt;        &lt;title&gt;data数据对象&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;            {{message}}            &lt;div&gt;{{message}}&lt;/div&gt;            &lt;h2&gt;{{school}}&lt;/h2&gt;            字典获取类型：&lt;h2&gt;{{school.name}}&lt;/h2&gt;            &lt;h2&gt;{{campus}}&lt;/h2&gt;            数组获取类型：&lt;h2&gt;{{campus[0]}}&lt;/h2&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    message: 'Hello Vue!',                    school:{                        name:'北京大学',                        address:'北京市海淀区'                    },                campus:[                    '北京校区',                    '上海校区',                    '广州校区'                ]                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n05.本地应用v-text\n\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;v-test&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;            &lt;span v-text=\"message\"&gt;&lt;/span&gt;            &lt;div v-text=\"school.name+'!'\"&gt;&lt;/div&gt;支持字符串拼接&lt;br&gt;            &lt;/br&gt;            &lt;h2&gt;{{message}}&lt;/h2&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    message: 'Hello Vue!',                    show:true,                    school:{                        name:'北京大学',                        address:'北京市海淀区'                    }               }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n06.v-html\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;v-html&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;           &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;            &lt;p v-html=\"message\"&gt;&lt;/p&gt;            &lt;p v-text=\"message\"&gt;&lt;/p&gt;\"        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    message: '&lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;',                }            })        &lt;/script&gt;&lt;/html&gt;\n\n\n07.v-on元素绑定事件\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;v-on&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;            &lt;input type=\"button\" value=\"v-on指令\" v-on:click=\"show\"/&gt;            &lt;input type=\"button\" value=\"v-on简写\" @click=\"show\"/&gt;            &lt;input type=\"button\" value=\"双击事件\" @dblclick=\"show\"/&gt;            &lt;input type=\"button\" value=\"change事件\" @click=\"changeFood\"/&gt;            &lt;h2&gt;{{food}}&lt;/h2&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    message: 'Hello Vue!',                    food:'苹果'                },                methods:{                    show:function(){                        alert('show')                    },                    changeFood:function(){                        this.food='香蕉'                    }                            }            })        &lt;/script&gt;&lt;/html&gt;\n\n\n08.计数器\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;计数器&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;            点击直接加减&lt;br&gt;            &lt;/br&gt;            &lt;button @click=\"count++\"&gt;+&lt;/button&gt;            &lt;button @click=\"count--\"&gt;-&lt;/button&gt;            &lt;button @click=\"count=0\"&gt;reset&lt;/button&gt;            &lt;div&gt;{{count}}&lt;/div&gt;            &lt;div&gt;                点击调用事件&lt;br&gt;                &lt;/br&gt;                &lt;button @click=\"add\"&gt;+&lt;/button&gt;                &lt;button @click=\"sub\"&gt;-&lt;/button&gt;                &lt;button @click=\"reset\"&gt;reset&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    count:0                },                methods:{                    add:function(){                        this.count++                    },                    sub:function(){                        this.count--                    },                    reset:function(){                        this.count=0                    }                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n09.v-show\n\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;v-show&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;            &lt;/head&gt;        &lt;body&gt;        &lt;div id=\"app\"&gt;            &lt;span v-show=\"show\"&gt;Hello Vue!&lt;/span&gt;            &lt;div v-show=\"show\"&gt;Hello Vue!&lt;/div&gt;            &lt;button @click=\"show=!show\"&gt;显示/隐藏&lt;/button&gt;            &lt;h2&gt;{{show}}&lt;/h2&gt;            &lt;input type=\"button\" value=\"显示/隐藏\" @click=\"changeShow\"&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    show:true               },               methods:{                   changeShow(){                       this.show=!this.show                   }               }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n10.v-if\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;v-if&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;           &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;            &lt;button @click=\"show=!show\"&gt;切换&lt;/button&gt;&lt;br/&gt;            &lt;div v-if=\"show\"&gt;Hello Vue!&lt;/div&gt;            &lt;div v-if=\"show\"&gt;Hello Vue!&lt;/div&gt;            &lt;div v-show=\"show\"&gt;Hello Vue!&lt;/div&gt;            &lt;div v-if=\"times&gt;10\"&gt;Hello Vue!&lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    times:20,                    show:true                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n11.v-bind设置元素的属性\n\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;v-bind&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;        &lt;style&gt;            .active{                color:red;            }            .disabled{                color:gray;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        v-bind        &lt;div id=\"app\"&gt;            &lt;a v-bind:href=\"url\"&gt;{{name}}&lt;/a&gt;            &lt;a :href=\"url\"&gt;{{name}}&lt;/a&gt;            &lt;a :href=\"url\" :title=\"name\"&gt;{{name}}&lt;/a&gt;            &lt;a :href=\"url\" :title=\"name\" :class=\"{active:isActive}\"&gt;{{name}}&lt;/a&gt;            &lt;a :href=\"url\" :title=\"name\" :class=\"{active:isActive,disabled:isDisabled}\"&gt;{{name}}&lt;/a&gt;            &lt;a :href=\"url\" :title=\"name\" :class=\"classObject\"&gt;{{name}}&lt;/a&gt;            &lt;button :class=\"{active:isActive,disabled:isDisabled}\" @click=\"changeActive\"&gt;{{name}}&lt;/button&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    url:'https://www.baidu.com',                    name:'百度',                    isActive:true,                    isDisabled:false,                    classObject:{                        active:true,                        disabled:false                    }                },                methods:{                    changeActive(){                        this.isActive=!this.isActive;                    }                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n12.图片切换\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;切换图片&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;            切换图片&lt;br&gt;            &lt;img :src=\"imgUrls[index]\" alt=\"\"&gt;&lt;br&gt;            &lt;button @click=\"index=0\"&gt;切换到百度&lt;/button&gt;            &lt;button @click=\"index=1\"&gt;切换到QQ&lt;/button&gt;            &lt;button @click=\"index=2\"&gt;切换到新浪&lt;/button&gt;                        &lt;/br&gt;&lt;/img&gt;                    &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    index:0,                    imgUrls: [                        'https://www.baidu.com/img/bd_logo1.png',                        'https://www.qq.com/favicon.ico',                        'https://www.sina.com.cn/favicon.ico'                    ],                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n13.v-for\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;    &lt;title&gt;v-for&lt;/title&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;    &lt;/meta&gt;    &lt;/meta&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=\"app\"&gt;        &lt;div v-for=\"school,index in schools\"&gt;            &lt;h2&gt;{{index}}&lt;/h2&gt;            &lt;h2&gt;{{school.name}}&lt;/h2&gt;            &lt;p&gt;{{school.address}}&lt;/p&gt;        &lt;/div&gt;        &lt;div v-for=\"food in food\"&gt;            &lt;span&gt;{{food.name}}&lt;/span&gt;            &lt;span&gt;{{food.price}}&lt;/span&gt;        &lt;/div&gt;        &lt;br/&gt;        添加食物        &lt;input type=\"text\" v-model=\"food.name\"&gt;        &lt;/input&gt;        &lt;input type=\"text\" v-model=\"food.price\"&gt;        &lt;/input&gt;        &lt;button @click=\"addFood\"&gt;添加&lt;/button&gt;        &lt;br/&gt;删除食物        &lt;input type=\"text\" v-model=\"food.name\"&gt;        &lt;/input&gt;        &lt;button @click=\"removeFood\"&gt;删除&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        var app = new Vue({            el: '#app',            data: {                message: 'Hello Vue!',                schools:[                    {name:'北京大学',address:'北京市海淀区'},                    {name:'清华大学',address:'北京市海淀区'},                     {name:'北京大学',address:'北京市海淀区'},                    {name:'北京大学',address:'北京市海淀区' },                ],                food:[                    {name:'苹果',price:10},                    {name:'香蕉',price:20},                    {name:'西瓜',price:30},                    {name:'葡萄',price:40},                    {name:'草莓',price:50},                    {name:'火龙果',price:60},                    {name:'苹果',price:10},                    {name:'香蕉',price:20},                    {name:'西瓜',price:30},                ]            },            methods:{                addFood(){                    this.food.push({                        name:this.food.name,                        price:this.food.price                    })                },                removeFood(){                    for(var i=0;i&lt;this.food.length;i++){                        if(this.food[i].name==this.food.name){                            this.food.splice(i,1)                        }                    }                }            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n14.v-on补充\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;    &lt;title&gt;v-on补充&lt;/title&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=\"app\"&gt;        &lt;button @click=\"show\"&gt;点我&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        var app = new Vue({            el: '#app',            data: {                message: 'Hello Vue!'            },            methods: {                show: function () {                    alert('show')                                   }            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n15.v-model双向数据绑定\n\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;v-model&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;           &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;            &lt;button @click=\"message='Hello World!'\"&gt;点我&lt;/button&gt;&lt;br/&gt;            &lt;input type=\"text\" v-model=\"message\"&gt;            &lt;div&gt;{{message}}&lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    message: 'Hello Vue!'                }            })        &lt;/script&gt;    &lt;/body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n16.记事本-add\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;记事本&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;                        &lt;div class=\"title\"&gt;                &lt;input type=\"text\" v-model=\"title\" @keyup.enter=\"add\"&gt;            &lt;/div&gt;            &lt;div class=\"content\"&gt;                &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\" v-model=\"content\"&gt;&lt;/textarea&gt;            &lt;/div&gt;            &lt;div class=\"btn\"&gt;                &lt;button @click=\"add\"&gt;添加&lt;/button&gt;               &lt;button @click=\"clear\"&gt;清空&lt;/button&gt;            &lt;/div&gt;            &lt;div class=\"list\"&gt;                &lt;div class=\"title\"&gt;笔记列表&lt;/div&gt;                &lt;div class=\"item\" v-for=\"(item,index) in list\" :key=\"index\"&gt;                    &lt;span class=\"title\"&gt;{{item.title}}&lt;/span&gt;                    &lt;span class=\"content\"&gt;{{item.content}}&lt;/span&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    title:'',                    content:'',                    list:[                        {title:'标题1',content:'内容1'},                        {title:'标题2',content:'内容2'},                        {title:'标题3',content:'内容3'},                        {title:'标题4',content:'内容4'},                        {title:'标题5',content:'内容5'},                        {title:'标题6',content:'内容6'},                        {title:'标题7',content:'内容7'},                       {title:'标题8',content:'内容8'},                    ]                },                methods: {                    add(){                        this.list.push({                            title:this.title,                            content:this.content                        })                        this.title = ''                        this.content = ''                    },                    clear(){                        this.list = []                    }                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n17.记事本-remove\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;记事本&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;                        &lt;div class=\"title\"&gt;                &lt;input type=\"text\" v-model=\"title\" @keyup.enter=\"add\"&gt;            &lt;/div&gt;            &lt;div class=\"content\"&gt;                &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\" v-model=\"content\"&gt;&lt;/textarea&gt;            &lt;/div&gt;            &lt;div class=\"btn\"&gt;                &lt;button @click=\"add\"&gt;添加&lt;/button&gt;               &lt;button @click=\"clear\"&gt;清空&lt;/button&gt;            &lt;/div&gt;            &lt;div class=\"list\"&gt;                &lt;div class=\"title\"&gt;笔记列表&lt;/div&gt;                &lt;div class=\"item\" v-for=\"(item,index) in list\" :key=\"index\"&gt;                    &lt;span class=\"title\"&gt;{{item.title}}&lt;/span&gt;                    &lt;span class=\"content\"&gt;{{item.content}}&lt;/span&gt;                    &lt;button @click=\"remove(index)\"&gt;删除&lt;/button&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    title:'',                    content:'',                    list:[                        {title:'标题1',content:'内容1'},                        {title:'标题2',content:'内容2'},                        {title:'标题3',content:'内容3'},                        {title:'标题4',content:'内容4'},                        {title:'标题5',content:'内容5'},                        {title:'标题6',content:'内容6'},                        {title:'标题7',content:'内容7'},                       {title:'标题8',content:'内容8'},                    ]                },                methods: {                    add(){                        this.list.push({                            title:this.title,                            content:this.content                        })                        this.title = ''                        this.content = ''                    },                    clear(){                        this.list = []                    },                    remove(index){                        this.list.splice(index,1)                    }                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n18.记事本-count\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;记事本&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;                        &lt;div class=\"title\"&gt;                &lt;input type=\"text\" v-model=\"title\" @keyup.enter=\"add\"&gt;            &lt;/div&gt;            &lt;div class=\"content\"&gt;                &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\" v-model=\"content\"&gt;&lt;/textarea&gt;            &lt;/div&gt;            &lt;div class=\"btn\"&gt;                &lt;button @click=\"add\"&gt;添加&lt;/button&gt;               &lt;button @click=\"clear\"&gt;清空&lt;/button&gt;            &lt;/div&gt;            &lt;div class=\"count\"&gt;                &lt;div class=\"title\"&gt;笔记数量&lt;/div&gt;                &lt;div class=\"count\"&gt;{{list.length}}&lt;/div&gt;            &lt;/div&gt;            &lt;div class=\"list\"&gt;                &lt;div class=\"title\"&gt;笔记列表&lt;/div&gt;                &lt;div class=\"item\" v-for=\"(item,index) in list\" :key=\"index\"&gt;                    &lt;span class=\"title\"&gt;{{item.title}}&lt;/span&gt;                    &lt;span class=\"content\"&gt;{{item.content}}&lt;/span&gt;                    &lt;button @click=\"remove(index)\"&gt;删除&lt;/button&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    title:'',                    content:'',                    list:[                        {title:'标题1',content:'内容1'},                        {title:'标题2',content:'内容2'},                        {title:'标题3',content:'内容3'},                        {title:'标题4',content:'内容4'},                        {title:'标题5',content:'内容5'},                        {title:'标题6',content:'内容6'},                        {title:'标题7',content:'内容7'},                       {title:'标题8',content:'内容8'},                    ]                },                methods: {                    add(){                        this.list.push({                            title:this.title,                            content:this.content                        })                        this.title = ''                        this.content = ''                    },                    clear(){                        this.list = []                    },                    remove(index){                        this.list.splice(index,1)                    }                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n19.记事本-clear&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;记事本&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;                        &lt;div class=\"title\"&gt;                &lt;input type=\"text\" v-model=\"title\" @keyup.enter=\"add\"&gt;            &lt;/div&gt;            &lt;div class=\"content\"&gt;                &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\" v-model=\"content\"&gt;&lt;/textarea&gt;            &lt;/div&gt;            &lt;div class=\"btn\"&gt;                &lt;button @click=\"add\"&gt;添加&lt;/button&gt;               &lt;button @click=\"clear\"&gt;清空&lt;/button&gt;            &lt;/div&gt;            &lt;div class=\"count\"&gt;                &lt;div class=\"title\"&gt;笔记数量&lt;/div&gt;                &lt;div class=\"count\"&gt;{{list.length}}&lt;/div&gt;            &lt;/div&gt;            &lt;div class=\"list\"&gt;                &lt;div class=\"title\"&gt;笔记列表&lt;/div&gt;                &lt;div class=\"item\" v-for=\"(item,index) in list\" :key=\"index\"&gt;                    &lt;span class=\"title\"&gt;{{item.title}}&lt;/span&gt;                    &lt;span class=\"content\"&gt;{{item.content}}&lt;/span&gt;                    &lt;button @click=\"remove(index)\"&gt;删除&lt;/button&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    title:'',                    content:'',                    list:[                        {title:'标题1',content:'内容1'},                        {title:'标题2',content:'内容2'},                        {title:'标题3',content:'内容3'},                        {title:'标题4',content:'内容4'},                        {title:'标题5',content:'内容5'},                        {title:'标题6',content:'内容6'},                        {title:'标题7',content:'内容7'},                       {title:'标题8',content:'内容8'},                    ]                },                methods: {                    add(){                        this.list.push({                            title:this.title,                            content:this.content                        })                        this.title = ''                        this.content = ''                    },                    clear(){                        this.list = []                    },                    remove(index){                        this.list.splice(index,1)                    }                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n20.记事本-hidden没有数据时，隐藏元素（v-show,v-for）\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;记事本&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;                        &lt;div class=\"title\"&gt;                &lt;input type=\"text\" v-model=\"title\" @keyup.enter=\"add\"&gt;            &lt;/div&gt;            &lt;div class=\"content\"&gt;                &lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\" v-model=\"content\"&gt;&lt;/textarea&gt;            &lt;/div&gt;            &lt;div class=\"btn\"&gt;                &lt;button @click=\"add\"&gt;添加&lt;/button&gt;               &lt;button @click=\"clear\"&gt;清空&lt;/button&gt;            &lt;/div&gt;            &lt;div class=\"count\"&gt;                &lt;div class=\"title\"&gt;笔记数量&lt;/div&gt;                &lt;div class=\"count\"&gt;{{list.length}}&lt;/div&gt;            &lt;/div&gt;            &lt;div class=\"list\"&gt;                &lt;div class=\"title\" v-show=\"list.length\" style=\"background-color: aqua;\"&gt;笔记列表&lt;/div&gt;                &lt;div class=\"item\" v-for=\"(item,index) in list\" :key=\"index\"&gt;                    &lt;span class=\"title\" style=\"background-color: aquamarine;\"&gt;{{item.title}}&lt;/span&gt;                    &lt;span class=\"content\"&gt;{{item.content}}&lt;/span&gt;                    &lt;button @click=\"remove(index)\"&gt;删除&lt;/button&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    title:'',                    content:'',                    list:[                        {title:'标题1',content:'内容1'},                        {title:'标题2',content:'内容2'},                        {title:'标题3',content:'内容3'},                        {title:'标题4',content:'内容4'},                        {title:'标题5',content:'内容5'},                        {title:'标题6',content:'内容6'},                        {title:'标题7',content:'内容7'},                       {title:'标题8',content:'内容8'},                    ]                },                methods: {                    add(){                        this.list.push({                            title:this.title,                            content:this.content                        })                        this.title = ''                        this.content = ''                    },                    clear(){                        this.list = []                    },                    remove(index){                        this.list.splice(index,1)                    }                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n21.axios基本使用\n\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;axios基本使用&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;        &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;            &lt;button @click=\"get\"&gt;get&lt;/button&gt;            &lt;button @click=\"post\"&gt;post&lt;/button&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                methods: {                    get(){                        axios.get('https://api.github.com/users/zhongyuanzhi')                       .then(function (response) {                        var response = response.data;                        alert(response.url)                       })                       .catch(function (error) {                        alert(error)                       });                    },                    post(){                        axios.post('Http://example.com/login?username=admin&amp;password=12345')                       .then(function (response) {                        var response = response.data;                        alert(response.url)                       })                       .catch(function (error) {                        alert(error)                       });                    }                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n22.axios+vue\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;        &lt;title&gt;axios基本使用&lt;/title&gt;        &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;        &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"app\"&gt;            &lt;button @click=\"get\"&gt;get&lt;/button&gt;            &lt;button @click=\"post\"&gt;post&lt;/button&gt;            &lt;br/&gt;            &lt;textarea name=\"message\" rows=\"20\" cols=\"59\"&gt;{{tmp}}&lt;/textarea&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: '#app',                data: {                    tmp:''                },                methods: {                    get(){                        var that =this;                        axios.get('https://api.github.com/users/zhongyuanzhi')                       .then(function (response) {                        var response = response;                        that.tmp = JSON.stringify(response);                        alert(response.data.url)                       })                       .catch(function (error) {                        alert(error)                       });                    },                    post(){                        axios.post('Http://example.com/login?username=admin&amp;password=12345')                       .then(function (response) {                        var response = response.data;                        alert(response.url)                       })                       .catch(function (error) {                        alert(error)                       });                    }                }            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n23.example-weather回车查询\n墨迹天气API点击查询\n&lt;!DOCTYPE html&gt;  &lt;html lang=\"en\"&gt;  &lt;head&gt;      &lt;meta charset=\"UTF-8\"&gt;      &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;      &lt;title&gt;Weather App&lt;/title&gt;      &lt;!-- 引入Vue --&gt;      &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2\"&gt;&lt;/script&gt;      &lt;!-- 引入Axios --&gt;      &lt;script src=\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\"&gt;&lt;/script&gt;      &lt;style&gt;          /* 简单的样式 */          #app {              margin: 50px;              text-align: center;          }          input, button {              margin: 10px;          }      &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;      &lt;input type=\"text\" v-model=\"city\" placeholder=\"Enter city name\" @keyup.enter=\"getWeather\"&gt;      &lt;button @click=\"getWeather\"&gt;Get Weather&lt;/button&gt;      &lt;br/&gt;    {{weather.location[0].fxLink}}    &lt;p v-html=\"weather.location[0].fxLink\"&gt;&lt;/div&gt;    &lt;script&gt;      // Vue实例      new Vue({          el: '#app',          data: {              city: '',              weather: {                    code:200,                    location:[                        {                           name: \"海淀\",                            id: \"101010200\",                            lat: \"39.95607\",                            lon: \"116.31032\",                            adm2: \"北京\",                            adm1: \"北京市\",                            country: \"中国\",                            tz: \"Asia/Shanghai\",                            utcOffset: \"+08:00\",                            isDst: \"0\",                            type: \"city\",                            rank: \"15\",                            fxLink: \"https://www.qweather.com/weather/haidian-101010200.html\"                        }                    ],                            }          },          methods: {              getWeather: function() {                  if (!this.city) {                      alert('Please enter a city name!');                      return;                  }                  var vm = this;                  axios.get(                    \"https://geoapi.qweather.com/v2/city/lookup?location=\" + this.city + \"&amp;key=50a831558a6e47efaf68994e101b0e42\")                      .then(function(response) {                          vm.weather = response.data;                      })                      .catch(function(error) {                          console.error('Error fetching weather:', error);                          alert('Failed to fetch weather.');                      });              }          }      });  &lt;/script&gt;    &lt;/body&gt;  &lt;/html&gt;\n","categories":["Vue"],"tags":["Vue2"]},{"title":"[数据结构与算法]动态规划","url":"/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"动态规划（Dynamic Programming）实验介绍本节课我们进入动态规划课程的学习，动态规划是一种多阶段的决策过程最优化的问题。\n本课程对于算法学习非常重要，但是又比较难，我们讲解分  个章节进行动态规划问题的讲解。\n今天的课程是动态规划系列的第一个章节。\n知识点\n动态规划的基本思想\n动态规划问题的基本套路与步骤\n\n为什么使用动态规划算法我们先回忆一下贪心问题。\n贪心又称贪婪算法。是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而使得问题得到全局最优解。\n它的特点：\n贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。\n这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。\n贪心选择性质就是，该问题的每一步选择都在选择最优的情况下能够导致最终问题的答案也是最优。\n其实贪心和动态规划的区别，你可以理解为一个是正推，一眼就能看出来最优子结构，依次按照最优子结构选择每个过程最优选择即可。\n而动态规划是没办法按照题目的意思直接得到最有优子结构，如下文所述:\n多阶段决策过程最优化问题动态规划问题，是运筹学的一个分支，动态规划主要用于求解以时间划分阶段的动态过程的优化问题。\n在实际生活中，动态规划问题与贪心问题相似，都是完成某一事件的过程可以划分成多个阶段。\n但是与贪心不同的是动态规划的每个状态之间都会相互影响和相互干涉，也就是说在某一阶段做出的决策会影响整个事件的最终结果。\n因为阶段是有先后的，所以某一阶段的选取受之前阶段的影响，他也会影响后面的阶段。\n多阶段决策问题：\n多阶段决策过程问题，就是一类在每一阶段都需要做出选择，且某一阶段的决策受前面所有阶段决策后的状态影响，他的决策又会影响后续的决策。\n这样一类问题就是多阶段决策问题。\n多阶段决策过程最优化问题：\n在多阶段决策问题中，各个阶段采取的决策，通常与时间相关，但有时又与其他的线性的变量相关。\n我们前面说到，某个阶段的决策是在前面做完了的决策引发的某一个状态开始进行决策的。\n而现在做的决策又会使得状态进行转移，那么又影响了下次进行决策的状态。\n所以说作决策时的状态是动态的，规划是解决最优化问题的方式，所以解决这种多阶段决策过程最优化的方法叫做动态规划。\n动态规划中的术语解释\n阶段： 把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同\n\n状态： 述事物的性质，不同事物有不同的性质，因而用不同的状态来刻画。对问题的求解状态的描述是分阶段的\n\n决策： 根据题意要求，对每个阶段所做出的某种选择性操作\n\n策略： 由每个阶段的决策组成的序列称为策略\n\n状态转移方程： 用数学公式描述与阶段相关的状态间的演变规律\n\n\n能采用动态规划求解的问题的性质\n最优化原理：\n如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。\n\n无后效性：\n即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。\n\n有重叠子问题：\n即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）\n\n\n解题步骤\n拆分问题\n定义状态(并找出初状态)\n找到状态转移\n逆推找最优子结构\n写出 DP 状态转移方程。\n\n一般的模型方法\n递归搜索法\n记忆化搜索(记忆化暴力)\n递推式法\n\n经典例题数塔问题我们先来回顾一下我们之前讲过的数塔问题：\n题目描述:\n\n如图数字三角形。如下所示为一个数字三角形。请编一个程序计算从顶到底的某处的一条路径，使该路径所经过的数字总和最大。只要求输出总和。\n\n一步可沿左斜线向下或右斜线向下走；\n三角形行数小于等于 ；\n三角形中的数字为 ，，，；\n\n测试数据通过键盘逐行输入。\n如上例数据应以样例所示格式输入：\n样例:\n输入：573 88 1 02 7 4 44 5 2 6 5\n\n输出：30\n\n运行限制:\n1. 最大运行时间：1s 2. 最大运行内存：128M\n\n题目分析:\n\n定义状态 假设 dp[i][j] 为处理 a[i][j] 后能达到的最大值。\n\n找出状态转移\ndp[i][j]怎么转移呢？按照题意他有两条路径可以转移\ndp[i+1][j]=dp[i][j]+a[i+1][j] 向下走\ndp[i+1][j+1]=dp[i][j]+a[i+1][j+1] 向右下走\n我们有办法知道这两条路径哪条更优吗？\n不能！因为通向了两个不同的决策过程。为什么贪心可以知道，因为贪心处理完之后通向的是同一个决策过程，这里dp[i+1][j]和dp[i+1][j+1]明显他们两个所能达到的状态是完全不同的，这就是动态规划和贪心的不同之处。\n那我们怎样处理呢，我们要做的就是达到同一个状态我们才能够判断那个是最优的，这就是最优子结构。\n\n逆推找最优子结构\n虽然我们进行了逆推，但是实际上不是因为我们逆推做了什么，只是因为我们找最优子结构的过程中恰好做了逆推的过程。\n我们要找最优子结构，我们刚才说了，要找到达同一状态的转移才能比较。那我们就考虑什么状态能够转移得到dp[i][j]，这时候我们直接看也能看出来是这两条路径dp[i+1][j]+a[i][j],dp[i+1][j+1]+a[i][j]。\n\n写出状态转移方程\n\n\n\n空间优化，已知 dp[i][j] 的值只会被覆盖前使用一次，所以可以合并 dp[i][j] 和 a[i][j] 那么就变成了。\n\n则 逆推到出发点 a[1][1] 为题目所求答案，即第一层到第 N 层的最大值。\n答案解析：\nC++ 解题代码:\n#include&lt;iostream&gt;using namespace std;int main(){    int n; //n层    int a[101][101]; //路径矩阵    cin&gt;&gt;n;    //输入数字三角形的值    for (int i=1; i&lt;=n; i++)    {        for (int j=1; j&lt;=i; j++)        {        cin&gt;&gt;a[i][j]; //输入原始数据        }    }    //递推开始    for (int i=n-1; i&gt;=1; i--)//从最后一层逆推    {        for (int j=1; j&lt;=i; j++)        {            if (a[i+1][j]&gt;=a[i+1][j+1])                a[i][j]+=a[i+1][j];     //路径选择            else                a[i][j]+=a[i+1][j+1];        }    }    cout&lt;&lt;a[1][1]&lt;&lt;endl;}\n\nPython 解题代码:\na = [[0] * 101] * 101if __name__ == '__main__':  n = int(input())  # 输入数字三角形的值  for i in range(1, n+1):      a[i] = input().split()      a[i] = list(map(int, a[i]))  # split 分割后都是 字符 这里是转化成数字  #  # for i in range(1, n + 1):  #     print(a[i]) # a = list(map(int, a)) # split 分割后都是 字符 这里是转化成数字  # 递推开始  for i in range(n - 1, 0, -1):      # 最后一层逆推      for j in range(0, i):          # 路径选择          if a[i + 1][j] &gt;= a[i + 1][j + 1]:              a[i][j] += a[i + 1][j]          else:              a[i][j] += a[i + 1][j + 1]  # for i in range(1, n + 1):  #     print(a[i])  print(a[1][0])\n\nJava 解题代码\npackage com.company;import java.util.Scanner;public class Main {  static int [][]a=new int [101][101];  public static void main(String[] args) {      int n;      Scanner in = new Scanner(System.in);      n = in.nextInt();      //输入数字三角形的值      for (int i=1; i&lt;=n; i++)      {          for (int j=1; j&lt;=i; j++)          {              a[i][j]=in.nextInt(); //输入原始数据          }      }      //递推开始      for (int i=n-1; i&gt;=1; i--)//从最后一层逆推      {          for (int j=1; j&lt;=i; j++)          {              if (a[i+1][j]&gt;=a[i+1][j+1])                  a[i][j]+=a[i+1][j];     //路径选择              else  a[i][j]+=a[i+1][j+1];          }      }      System.out.println(a[1][1]);  }}\n\n其实我们在讲这道题目中所用到的思想就是动态规划。\n我们换种方式在理解一遍。\n在用动态规划考虑数塔问题时可以自顶向下的分析，自底向上的计算。\n从顶点出发时到底向左走还是向右走应取决于是从左走能取到最大值还是从右走能取到最大值，只要左右两道路径上的最大值求出来了才能作出决策。\n同样的道理下一层的走向又要取决于再下一层上的最大值是否已经求出才能决策。\n这样一层一层推下去，直到倒数第二层时就非常明了。\n所以第一步对第五层的  个数据，做如下四次决策：\n\n如果经过第四层 ，则在第五层的  和  中，决策选择的肯定是 \n\n如果经过第四层 ，则在第五层的  和  中，决策选择的肯定是 \n\n如果经过第四层第一个 ，则在第五层的  和  中，决策选择的肯定是 \n\n如果经过第四层第二个 ，则在第五层的  和  中肯定是 \n\n\n经过一次决策，问题降了一阶。 层数塔问题转换成  层数塔问题，经过如此的决策，就将原来问题转换为一阶数塔问题。\n于是我们可以用我们上面的递推求解。\n这就是递推式法模型。\n我们通过这道简单的例题，大家首先要去找感觉，去分解问题的状态，去找决策，去找状态转移，而笔者认为动态规划问题，感觉是最重要的。\n有的人  道题就能找到感觉，有的人  道题也找不到感觉。\n游戏中的学问难度: 简单 标签: DP, JSOI, 2013\n题目链接：https://www.lanqiao.cn/problems/1436/learning/\n题目描述：\n大家应该都见过很多人手拉手围着篝火跳舞的场景吧？\n一般情况下，大家手拉手跳舞总是会围成一个大圈，每个人的左手拉着旁边朋友的右手，右手拉着另一侧朋友的左手。\n不过，如果每一个人都随机的拉住两个不同人的手，然后再慢慢散开，事情就变得有趣多了——此时大家依旧会形成圈，不过却可能会形成多个独立的圈。\n当然这里我们依然要求一个人的右手只能拉另一个人的左手，反之亦然。\n班里一共有  个同学，由  到  编号。Will 想知道，究竟有多少种本质不同的拉手方案，使得最终大家散开后恰好形成  个圈呢？\n给定两种方案，若存在一个人和他的一只手，满足在这两种方案中，拉着这只手的人的编号不同，则这两种方案本质不同。\n输入描述：\n输入一行包含三个正整数 N k P3&lt;=3k&lt;=N&lt;=3000，10^4&lt;=p&lt;=2×10^9\n\n输出描述：\n输出一行一个整数，表示本质不同的方案数对 p 的余数。保证 p 一定是一个质数。\n输入输出样例：\n\n样例 1： Input：\n3 1 1000000009\n\noutput：\n2\n\n答案解析：\n题目是说随即的拉住右手，共计 N 个人形成 k 个独立环的可能的情况有多少种。\n我们举个例子，A B C 三个人：\n\nA 的左手是 C A 的右手是 B B 的左手是 A B 的右手是 C C 的左手是 B C 的右手是 A\n\nA 的左手是 B A 的右手是 C B 的左手是 C B 的右手是 A C 的左手是 A C 的右手是 B\n这两种是不同的。\n最后对 P 取模。\n这道题目可以说是记忆化搜索，也可以说是递推法模型。\n定义状态：\n我们设 dp{i,j} 是 i 个人组成 j 个圈有多少种情况的状态\n找初始状态：\n由于最少是三个人围成 1 个圈\n所以 dp{3,1}=2\n找状态转移：\n我们考虑 dp{4,1} 的时候： 由于一开始三个人之间共计 3 个空位置，它可以见缝插针，所以就有  dp {}，dp{} =  dp{}\n接着考虑 dp{x+1,y} 和 dp{x,y} 的关系：\n假设 X 个人分成了 y 个环后每个环得人数是 X1 X2 ... Xy\n对于第一个环 X1 来说共有 X1 个空\n对于第二个环 X2 来说共有 X2 个空\n共计 X1+X2+...+Xy=X\n所以共有 X 个空，那么第 X+1 个人就用 X 种选择可以做。\n所以 dp{} =  dp{}，即 dp{}= dp{}\n考虑 dp{} 和 dp{} ：\n大家考虑以下我们划分阶段得方式是什么，是圈数吗？\n如果是圈数，我们发现好像{} 和 {} 两个状态之间没有什么关系？\n单纯的圈数不存在关系。\n我们思考一下，至少需要 3 个人才能组成一个圈。\n所以第 i 个人加入时，要在前 i-1 个人中抽出两个人才能组成一个新圈。\n所以原本的 dp{} 的状态就变成了，dp{}了。\n由于是从 i-1 个人中抽出 2 个人所以，共计的抽取方式，3 个人我们已知能组成两种方案。\n根据组合数求方案数的方式\n\n\n所以 dp{i,j+1}=dp{i-3,j}×(i-1)×(i-2)\n即 dp{i,j}=dp{i-3,j-1}×(i-1)×(i-2)\n就此我们得到状态转移方程\n\ndp{i,j}=dp{i-1,j}×(i-1)\ndp{i,j}=dp{i-3,j-1}×(i-1)×(i-2)\n\n除此之外，我们还有要考虑的情况，即建不建立新圈都是 dp{i,j}的情况，所以这里不是等于，而是求和:\ndp{i,j}=dp{i-1,j}×(i-1)\ndp{i,j}=dp{i,j}+dp{i-3,j-1}×(i-1)×(i-2)\n比如：\ndp{7,2}可以由 dp{6,2}转移而来\ndp{7,2}也可以由 dp{4,1}转移而来\n为什么这两种情况没有重叠，而是绝对异构的：\ndp{6,2}由 dp{3,1}转移而来\ndp{4,1}由 dp{3,1}转移而来\ndp{4,1}中 1-4 号是在同一个圈内的。\ndp{6,2}中 两个圈中的任意 3 个在一个圈内\n不可能出现 1-4 在一个圈里的这种情况。\n所以推导 dp{i,j}\ndp{i,j}由 dp{i-i,j}转移而来 dp{i,j}也可以由 dp{i-3,j-1} 转移而来\ndp{i-i,j}可以由 dp{i-2,j}或者 dp{i-4,j-1} dp{i-3,j-1}可以由 dp{i-4,j-1}或者 dp{i-6,j-2}\n最终还是会到 3,1。\n所以通过 3，通过两种方式走向了完全不同的方向。\n至此我们轻松写出代码。\nC++ 描述：\n#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;typedef long long LL;LL DP[3100][3100],mod;int n,k;int main(){    cin&gt;&gt;n&gt;&gt;k&gt;&gt;mod;    DP[3][1]=2;    for(int i=4;i&lt;=n;i++)    {        for(int j=1;3*j&lt;=i&amp;&amp;j&lt;=k;j++)        {            DP[i][j]=DP[i-1][j]*(i-1)%mod;            DP[i][j]=(DP[i][j]+DP[i-3][j-1]*(i-1)*(i-2))%mod;        }    }    cout&lt;&lt;DP[n][k];    return 0;}\n\nPython 语言描述：\nn, k, mod = map(int, input().split())DP=[[0 for i in range (3100)] for j in range (3100) ]DP[3][1]=2for i in range(4,n+1):    for j in range(1,k+1):        if 3*j&gt;i:            break        DP[i][j]=DP[i-1][j]*(i-1)%mod        DP[i][j]=(DP[i][j]+DP[i-3][j-1]*(i-1)*(i-2))%modprint(DP[n][k])\n\njava 语言描述：\nimport java.util.Scanner;// 1:无需package// 2: 类名必须Main, 不可修改public class Main {    public static long DP[][]=new long [3100][3100];    public static int n,k; public static void main (String[] args) throws java.lang.Exception {     Scanner in = new Scanner(System.in);     n=in.nextInt();     k=in.nextInt();    long mod=in.nextLong();     DP[3][1]=2;        for(int i=4;i&lt;=n;i++)        {            for(int j=1;3*j&lt;=i&amp;&amp;j&lt;=k;j++)            {                DP[i][j]=DP[i-1][j]*(i-1)%mod;                DP[i][j]=(DP[i][j]+DP[i-3][j-1]*(i-1)*(i-2))%mod;            }        }  System.out.println(DP[n][k]); }}\n\n跳跃难度: 简单 标签: 动态规划, 搜索, 2021, 模拟赛\n题目链接：https://www.lanqiao.cn/problems/553/learning/\n题目描述： 开始时，小蓝站在方格图的左上角，即第  行第  列。\n小蓝可以在方格图上走动，走动时，如果当前在第  行第  列，他不能走到行号比  小的行，也不能走到列号比  小的列。\n同时，他一步走的直线距离不超过 。\n例如，如果当前小蓝在第  行第  列，他下一步可以走到\n第  行第  列 第  行第  列 第  行第  列 第  行第  列 第  行第  列 第  行第  列 第  行第  列 第  行第  列 第  行第  列 小蓝最终要走到第  行第  列。\n在图中，有的位置有奖励，走上去即可获得，有的位置有惩罚，走上去就要接受惩罚。奖励和惩罚最终抽象成一个权值，奖励为正，惩罚为负。\n小蓝希望，从第  行第  列走到第  行第  列后，总的权值和最大。请问最大是多少？\n输入描述：\n输入的第一行包含两个整数 ，表示图的大小。\n接下来  行，每行  个整数，表示方格图中每个点的权值。\n其中，，权值。\n输出描述：\n输出一个整数，表示最大权值和。\n输入输出样例：\n\n样例 1： Input：\n3 5-4 -5 -10 -3 17 5 -9 3 -1010 -2 6 -10 -4\n\noutput：\n15\n\n运行限制:\n\n最大运行时间：1s\n最大运行内存: 128M\n\n答案解析：\n由于这道题目数据较弱，大家可以使用搜索把所有情况都搜索到，每次到终点就保存最大值，知道遍历完所有的情况，然后输出最大值。\n大家一定要写一遍 DFS 然后在看后边的 DP ,有时动态规划要从状态出发，有时动态规划又可以看成暴力搜索的剪枝。\n我们先看一下搜索的解法：\n因为只能向右下方移动，不存再走回头路的情况，所以不需要设置 Vis 数组。\nC++ 语言描述：\n#include&lt;iostream&gt;#define MAX 105using namespace std;int n, m, sum = -0x3f3f3f3f;int map[MAX][MAX];int nextt[9][2] = { {0,1},{1,0},{0,2},{2,0},{0,3},{3,0},{1,1},{1,2},{2,1} };void dfs(int x, int y,int value){    value += map[x][y];    if (x == n &amp;&amp; y == m)    {        sum=max(sum,value);        return;    }    for (int i = 0; i &lt; 9; i++)    {        int tx = x + nextt[i][0];        int ty = y + nextt[i][1];        if (tx &lt;= n &amp;&amp; ty &lt;= m)            dfs(tx, ty, value);    }}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= m; j++)            cin &gt;&gt; map[i][j];    dfs(1, 1, 0);    cout &lt;&lt; sum;    return 0;}\n\nPython 语言描述：\nimport osimport sys# 请在此输入您的代码n,m = map(int,input().strip().split())mapTable = [list(map(int,input().strip().split())) for i in range(n)]nextt = [[0,1],[0,2],[0,3],[1,0],[2,0],[3,0],[1,1],[1,2],[2,1]] #9种走的方式Sum=float('-inf')def dfs(x,y,value):    global Sum    value+=mapTable[x][y]    if x==n-1 and y==m-1 :        Sum=max(Sum,value)        return    for i in range(9):        tx = x+nextt[i][0]        ty = y+nextt[i][1]        if  tx&lt;n and  ty&lt;m :            dfs(tx,ty,value)dfs(0,0,0)print(Sum)\n\nJava 语言描述：\nimport osimport sys# 请在此输入您的代码n,m = map(int,input().strip().split())mapTable = [list(map(int,input().strip().split())) for i in range(n)]nextt = [[0,1],[0,2],[0,3],[1,0],[2,0],[3,0],[1,1],[1,2],[2,1]] #9种走的方式Sum=float('-inf')def dfs(x,y,value):    global Sum    value+=mapTable[x][y]    if x==n-1 and y==m-1 :        Sum=max(Sum,value)        return    for i in range(9):        tx = x+nextt[i][0]        ty = y+nextt[i][1]        if  tx&lt;n and  ty&lt;m :            dfs(tx,ty,value)dfs(0,0,0)print(Sum)\n\n我们再来看一下 DP 怎么解这个问题。\n定义状态：\n我们设 dp{} 当走到第  行第  列的值。\n找初始状态：\ndp{}\n找状态转移：\n对于dp{} 会有  种不同的状态转移，我们很难知道当前的选择去怎样影响后续的值，这就是上边的搜索问题，我们难以找到一种 DP 思路去求解这个问题，但是我们反向考虑，既然dp{} 会有  种转移方式，那么当这  种状态的值为从这九种状态到达终点的最优解（最大值）时，那么我们就能轻易得到dp{} 的最大值为这九种最优解的最大值。\n继续消解子问题，那么我们得到这  种最优子状态，继续根据同样的原理得到这  种最优的子状态的最优子状态。\n持续消解，发现只有到了 dp{} 采用终止，这就是一个递归的过程。\nvalue[n+5][m+5]dp(x,y){    if(x==n&amp;&amp;y==m)        return value[n][m]    if(越界)        return 负无穷    value[x][y]=value[x][y]+max(dp(x+1,y)......,dp(2,1))    return dp(x,y)}\n\n这个过程是正推，根据递归写出递推来就变成了逆推，其实并不是根据动态规划写出来的逆推式，而是用正推递归变递推变来的，当然有的同学一眼看出来，那是非常优秀的。\n这个题目数据量较小，用递归写不会爆，大家可以根据我的伪代码写写试试。\n正推也是可以写出递推式，大家有兴趣可以尝试下。\nC++ 语言描述：\n#include&lt;iostream&gt;#define MAX 105using namespace std;int n, m, sum = -0x3f3f3f3f;int map[MAX][MAX];int nextt[9][2] = { {0,1},{1,0},{0,2},{2,0},{0,3},{3,0},{1,1},{1,2},{2,1} };int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= m; j++)            cin &gt;&gt; map[i][j];    for(int i=n;i&gt;=1;i--)    {      for(int j=m;j&gt;=1;j--)      {        if(i==n&amp;&amp;j==m) continue;        int maxTemp=-0x3f3f3f3f;        for (int k = 0; k &lt; 9; k++)        {          int tx = i + nextt[k][0];          int ty = j + nextt[k][1];          if (tx &gt; n || ty &gt; m) continue;          maxTemp=max(maxTemp,map[tx][ty]);        }        map[i][j]+=maxTemp;      }    }        // for (int i = 1; i &lt;= n; i++){        //   for (int j = 1; j &lt;= m; j++)        //   cout &lt;&lt; map[i][j]&lt;&lt;\" \";        //   cout&lt;&lt;endl;        // }          cout &lt;&lt; map[1][1];    return 0;}\n\nPython 语言描述：\nnextt = [[0, 1], [0, 2], [0, 3], [1, 0], [2, 0], [3, 0], [1, 1], [1, 2], [2, 1]]  # 9种走的方式n, m = map(int, input().split())DP = [list(map(int, input().split())) for i in range(n)]for i in range(n - 1, -1, -1):    for j in range(m - 1, -1, -1):        if i == n - 1 and j == m - 1:            continue        maxTemp = float('-inf')        for k in range(9):            tx = i + nextt[k][0]            ty = j + nextt[k][1]            if tx &gt;= n or ty &gt;= m:                continue            maxTemp = max(maxTemp, DP[tx][ty])        DP[i][j] += maxTempprint(DP[0][0])\n\njava 语言描述：\nimport java.io.*;import java.util.Scanner;public class test{    public static int n, m, Sum = -0x3f3f3f3f;    public static int [][] mapTable=new int [105][105];    public static int nextt[][] ={ {0,1},{1,0},{0,2},{2,0},{0,3},{3,0},{1,1},{1,2},{2,1} }; public static void main (String[] args) throws java.lang.Exception {      Scanner in =new Scanner(System.in);      n=in.nextInt();      m=in.nextInt();     for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= m; j++)                    mapTable[i][j]=in.nextInt();    for(int i=n;i&gt;=1;i--)    {      for(int j=m;j&gt;=1;j--)      {        if(i==n&amp;&amp;j==m) continue;        int maxTemp=-0x3f3f3f3f;        for (int k = 0; k &lt; 9; k++)        {          int tx = i + nextt[k][0];          int ty = j + nextt[k][1];          if (tx &gt; n || ty &gt; m) continue;          maxTemp=Math.max(maxTemp,mapTable[tx][ty]);        }        mapTable[i][j]+=maxTemp;      }    }  System.out.println(mapTable[1][1]); }}\n\n动态规划背包问题实验介绍本节课我们进入动态规划课程的学习，动态规划是一种多阶段的决策过程最优化的问题。\n本课程对于算法学习非常重要，但是又比较难，我们讲解分  个章节进行动态规划问题的讲解。\n今天的课程是动态规划系列的第二个章节。\n知识点\n0-1 背包\n完全背包\n多重背包问题\n\n背包问题我们上一章课程讲解了动态规划算法的基本原理，包括动态规划的“为什么使用动态规划算法”、“多阶段决策过程最优化问题”、“动态规划中的术语解释”，“可解动态鬼规划的性质”等知识点。\n今天我们来讲一下，动态规划中的背包问题，背包问题，是比赛中常考的问题，也是动态规划入门的问题，其实动态规划并没有套路，只是这类问题有着明确的特点，如果你做的题足够多的话，你会发现很多问题都会有模板。\n背包问题基本都是不可拆分背包，因为可拆分背包是贪心去求解的问题。我们今天讲三种背包的基本模型：1.0-1 背包、2.完全背包、3.多重背包问题。\n0-1 背包问题0-1 背包是背包问题的入门的问题。但是背包问题的模板也是最简单的。\n0-1 背包的问题是什么呢？\n其问题的简单表述为，有 N 件物品，每件物品只有一件。每个物品都有一个价值，每件物品都有一个占一个部分空间,已知你的背包共计可承重 C(Contains),现在让你求你的背包最多装得下多少，即求你背包中物品的最大价值。\n对于这个问题我们有以下模板:\n1.定义变量并输入\nC++ 语言描述：\n// 定义V,W用于保存价值和质量#define Maxn 5000int c[Maxn],w[Maxn];int C;// 输入int n;cin&gt;&gt; n;for(int i=0;i&lt;n;i++){    cin&gt;&gt;c[i]&gt;&gt;w[i];}cin&gt;&gt;C;//创建动态规划数组int dp[Maxn];\n\nPython 语言描述：\nimport osimport sysc = []w = []dp = []if __name__ == '__main__':    n, C = map(int, input().strip().split())    for i in range(n):        tempC, tempW = map(int, input().strip().split())        c.append(tempC)        w.append(tempW)\n\njava 语言描述：\nimport java.util.Arrays;import java.util.Scanner;import static java.lang.Math.max;public  class  Main{    static int []c;    static int []w;    static int dp[];   static int C;    static int n;    public static void main(String[] args)    {        Scanner in = new Scanner(System.in);        n=in.nextInt();       C=in.nextInt();       c=new int[n+50];       w=new int[n+50];       dp=new int [C+50];        for (int i = 0; i &lt; n; i++) {             c[i]=in.nextInt();             w[i]=in.nextInt();;        }    }}\n\n2.执行算法\n我们先去找到状态转移方程\ndp[i][j]=max(dp[i][j],dp[i−1]j−c[i]]+w[i])\n含义，选到第 i 件物品，且背包现在重量为 j。\n那么考虑这个状态会由什么状态转移而来，肯定是选到第 i-1 件的时候。\n如果选了第 i 件，那么就是由 dp[i−1]j−c[i]]转移而来。\n如果不选第 i 件，那么就是由 dp[i][j]转移而来。\n那么已知 dp[i−1]j−c[i]]和 dp[i][j]都为各自最优的状态，那我们直接取最优状态即可。\nC++ 描述：\nfor(int i=0;i&lt;n;i++){    for(int j=0;j&lt;=C;j++)    {        if(j&gt;=c[i])            dp[i][j]=max(dp[i][j],dp[i-1][j-c[i]]+w[i]);    }}\n\nPython 语言描述:\nfor i in range(n):    for j in reversed(C+1):        dp[i][j]=max(dp[i][j],dp[i-1][j-c[i]]+w[i])print(dp[C])\n\nJava 语言描述：\nfor(int i=0;i&lt;n;i++){    for(int j=0;j&lt;=C;j++)    {        if(j&gt;=c[i])            dp[i][j]=max(dp[i][j],dp[i-1][j-c[i]]+w[i]);    }}        System.out.println(dp[C]);\n\n空间优化：\n因为状态转移每次只与上一层有关，所以用一个一维数组就可以。\n为什么从大到小遍历， 看  这一状态转移，是根据小的改大的，如果先把小的改了，那小的还会被用到，数据就不对了，所以从小到大。\nC++ 描述；\nfor(int i=0;i&lt;n;i++) //遍历每一件物品    for(int j=C;j&gt;=c[i];j--)    //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;        dp[j]=max(dp[j-c[i]]+w[i],dp[j]);\n\nPython 语言描述:\nfor i in range(n):    for j in reversed(range(c[i],C+1)):        dp[j] = max(dp[j - c[i]] + w[i], dp[j]);print(dp[C])\n\nJava 语言描述：\nfor (int i = 0; i &lt; n; i++) //遍历每一件物品{    for (int j = C; j &gt;= c[i]; j--)        //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;        dp[j] = max(dp[j - c[i]] + w[i], dp[j]);}System.out.println(dp[C]);\n\n初始化细节：\n\n装满 ，其余赋值 ；\n不装满全初始化为 ；\n\nC++ 语言描述：\n//装满memset(dp, 0, sizeof(dp));dp[0]=0;//不装满memset(dp, -0x3f, sizeof(dp));\n\nPython 语言描述:\n# 装满for i in range(C + 50):    dp.append(-0x3f3f3f3f)dp[0]=0# 不装满for i in range(C + 50):    dp.append(0)\n\nJava 语言描述：\n//装满Arrays.fill(dp, -0x3f3f3f3f);dp[0]=0;//不装满memset(dp, -0x3f, sizeof(dp));\n\n题目描述:\n题目链接：https://www.lanqiao.cn/problems/1174/learning/\n小明有一个容量为  的背包。\n这天他去商场购物，商场一共有  件物品，第  件物品的体积为  ，价值为 ，每种物品都只有一个。\n小明想知道在购买的物品总体积不超过  的情况下所能获得的最大价值为多少，请你帮他算算。\n输入描述:\n输入第  行包含两个正整数 ，表示商场物品的数量和小明的背包容量。\n第  行包含  个正整数 ，表示物品的体积和价值。\n样例:\n输入：5 201 62 53 85 153 3\n\n输出： 37\n\n运行限制:\n1. 最大运行时间：1s 2. 最大运行内存：128M\n\n答案解析：\nC++ 解题代码\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define Maxn 5000int c[Maxn], w[Maxn];int dp[Maxn];int C;// 输入int n;int main() {    cin &gt;&gt; n;    cin &gt;&gt; C;    for (int i = 0; i &lt; n; i++) {        cin &gt;&gt; c[i] &gt;&gt; w[i];    }    int dp[Maxn];    memset(dp, 0, sizeof(dp)); //不装满    //创建动态规划数组    for (int i = 0; i &lt; n; i++) //遍历每一件物品    {        for (int j = C; j &gt;= c[i]; j--)            //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;            dp[j] = max(dp[j - c[i]] + w[i], dp[j]);    }    cout &lt;&lt; dp[C] &lt;&lt; endl;}\n\nPython 解题代码\nc = []w = []dp = []if __name__ == '__main__':    n, C = map(int, input().strip().split())    for i in range(n):        tempC, tempW = map(int, input().strip().split())        c.append(tempC)        w.append(tempW)    for i in range(C + 50):        dp.append(0)    for i in range(n):        for j in reversed(range(c[i],C+1)):            dp[j] = max(dp[j - c[i]] + w[i], dp[j]);    print(dp[C])\n\nJava 解题代码\nimport java.util.Arrays;import java.util.Scanner;import static java.lang.Math.max;public  class  Main{    static int []c;    static int []w;    static int dp[];    static int C;    static int n;    public static void main(String[] args)    {        Scanner in = new Scanner(System.in);        n=in.nextInt();        C=in.nextInt();        c=new int[n+50];        w=new int[n+50];        dp=new int [C+50];        for (int i = 0; i &lt; n; i++) {             c[i]=in.nextInt();             w[i]=in.nextInt();;        }        Arrays.fill(dp, 0);        for (int i = 0; i &lt; n; i++) //遍历每一件物品        {            for (int j = C; j &gt;= c[i]; j--)                //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;                dp[j] = max(dp[j - c[i]] + w[i], dp[j]);        }        System.out.println(dp[C]);    }}\n\n完全背包问题完全背包是背包问题的入门的问题。\n根据 0-1 背包写出模板也是很简单的。\n完全背包的问题是什么呢？\n其问题的简单表述为，有  件物品，每件物品有无数件。每个物品都有一个价值，每件物品都有一个占一个部分空间,已知你的背包共计可承重 ,现在让你求你的背包最多装得下多少，即求你背包中物品的最大价值。\n对于这个问题我们有以下模板:\n1.定义变量并输入\n参考 0-1 背包。\n2.执行算法\n我们先去找到状态转移方程\ndp[i][j]=max(dp[i][j],dp[i]j−c[i]]+w[i])\n含义，选到第  件物品，且背包现在重量为 。\n那么考虑这个状态会由什么状态转移而来，肯定是选到第  件的时候,或者选了若干次第  件。\n如果不选第  种，那么就是由 dp[i-1][j]转移而来。\n如果选了第  件，那么就是由 dp[i−1]j−c[i]]转移而来。\n或者在某一刻，不在选第  件了，那么就是有 dp[i][j]转移而来。\n那么已知 dp[i]j−c[i]]和 dp[i][j]都为各自最优的状态，那我们直接取最优状态即可。\nC++ 描述：\nfor(int i=0;i&lt;n;i++){    for(int j=0;j&lt;=C;j++){        dp[i][j]=dp[i-1][j];        if(j&gt;=c[i])  dp[i][j]=max(dp[i][j],dp[i][j-c[i]]+w[i]);    }}cout&lt;&lt;dp[n][C]&lt;&lt;endl;\n\nPython 语言描述:\nfor i in range(n):    for j in range(C+1):        dp[i][j]=dp[i-1][j];        dp[i][j]=max(dp[i][j],dp[i][j-c[i]]+w[i])print(dp[n][C])\n\nJava 语言描述：\nfor(int i=0;i&lt;n;i++){    for(int j=0;j&lt;=C;j++){        dp[i][j]=dp[i-1][j];        if(j&gt;=c[i])dp[i][j]=max(dp[i][j],dp[i][j-c[i]]+w[i]);    }} System.out.println(dp[n][C]);\n\n空间优化：\n因为状态转移每次只与上一层有关，所以用一个一维数组就可以。\n为什么从小到大遍历， 看  这一状态转移，是根据小的改大的，而此时的含义为选了 x 件后的容量与质量，跟 01 背包类似，但含义不同，处理方式上也有本质区别，处理完一件后在处理下件。\nC++ 描述；\nfor(int i=0;i&lt;n;i++) //遍历每一件物品    for(int j=c[i];j&lt;=C;j++)    //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;        dp[j]=max(dp[j-c[i]]+w[i],dp[j]);\n\nPython 语言描述:\nfor i in range(n):    for j in range(c[i],C+1):        dp[j] = max(dp[j - c[i]] + w[i], dp[j]);print(dp[C])\n\nJava 语言描述：\nfor (int i = 0; i &lt; n; i++) //遍历每一件物品{    for(int j=c[i];j&lt;=C;j++)        //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;        dp[j] = max(dp[j - c[i]] + w[i], dp[j]);}System.out.println(dp[C]);\n\n初始化细节：\n与 0 - 1背包相同。\n\n装满 ，其余赋值；\n不装满全初始化为 ；\n\n题目描述:\n题目链接：https://www.lanqiao.cn/problems/1175/learning/\n小明有一个容量为  的背包。\n这天他去商场购物，商场一共有  件物品，第  件物品的体积为  ，价值为 ，每种物品都有无限多个。\nimport java.io.*;public class Main {static int N=110;static long[][] g=new long[N][N],m=new long[N][N],f=new long[N][N];    static long n,q;static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));   static PrintWriter  out=new PrintWriter(new OutputStreamWriter(System.out));public static void main(String[] args) throws IOException { String[] s=br.readLine().split(\" \");        n=Long.parseLong(s[0]);        q=Long.parseLong(s[1]);        for(int i=1;i&lt;=n;++i){            s=br.readLine().split(\" \");            for(int j=1;j&lt;=n;++j){                g[i][j]=Long.parseLong(s[j-1]);            }        }        for(int i=1;i&lt;=n;++i){            s=br.readLine().split(\" \");            for(int j=1;j&lt;=n;++j){                m[i][j]=Long.parseLong(s[j-1]);                f[i][j]=m[i][j];            }        }        if(floyd()&gt;q){            out.println(-1);            out.flush();            return;        }        long l=0,r=1000000000;        while(l&lt;r){            long mid=l+r&gt;&gt;1;            if(check(mid)) r=mid;            else l=mid+1;        }       out.println(r);        out.flush();    }    static long floyd(){        long a=0;        for (int k = 1; k &lt;= n; k ++ )            for (int i = 1; i &lt;= n; i ++ )                for (int j = 1; j &lt;= n; j ++ )                    f[i][j] =Math.min(f[i][j], f[i][k] + f[k][j]);        for(int i=1;i&lt;=n;++i)            for(int j=1;j&lt;=n;++j)                a+=f[i][j];        return a;    }   static boolean check(long x){        for(int i=1;i&lt;=n;++i){            for(int j=1;j&lt;=n;++j) f[i][j]=g[i][j];        }        long h=x/n;        long s=x%n;        for(int i=1;i&lt;=n;++i){            for(int j=1;j&lt;=n;++j){                if(i==j) continue;                if(i&lt;=s) f[i][j]=Math.max(m[i][j],f[i][j]-h-1);                else f[i][j]=Math.max(m[i][j],f[i][j]-h);                f[j][i]=f[i][j];           }        }        return floyd()&lt;=q;    }}\n\n输入描述:\n输入第  行包含两个正整数 ，表示商场物品的数量和小明的背包容量。\n第  行包含  个正整数 ，表示物品的体积和价值。\n样例:\n输入：5 201 62 53 85 153 3\n\n输出： 120\n\n运行限制:\n1. 最大运行时间：1s 2. 最大运行内存：128M\n\n答案解析：\nC++ 解题代码\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define Maxn 5000int c[Maxn], w[Maxn];int dp[Maxn];int C;// 输入int n;int main() {    cin &gt;&gt; n;    cin &gt;&gt; C;    for (int i = 0; i &lt; n; i++) {        cin &gt;&gt; c[i] &gt;&gt; w[i];    }    int dp[Maxn];    memset(dp, 0, sizeof(dp)); //不装满    //创建动态规划数组    for (int i = 0; i &lt; n; i++) //遍历每一件物品    {        for(int j=c[i];j&lt;=C;j++)            //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;            dp[j] = max(dp[j - c[i]] + w[i], dp[j]);    }    cout &lt;&lt; dp[C] &lt;&lt; endl;}\n\nPython 解题代码\nimport osimport sysc = []w = []dp = []if __name__ == '__main__':    n, C = map(int, input().strip().split())    for i in range(n):        tempC, tempW = map(int, input().strip().split())        c.append(tempC)        w.append(tempW)    for i in range(C + 50):        dp.append(0)    for i in range(n):        for j in range(c[i],C+1):            dp[j] = max(dp[j - c[i]] + w[i], dp[j])    print(dp[C])\n\nJava 解题代码\nimport java.util.Arrays;import java.util.Scanner;import static java.lang.Math.max;public  class  Main{    static int []c;    static int []w;    static int dp[];    static int C;    static int n;    public static void main(String[] args)    {        Scanner in = new Scanner(System.in);        n=in.nextInt();        C=in.nextInt();        c=new int[n+50];        w=new int[n+50];        dp=new int [C+50];        for (int i = 0; i &lt; n; i++) {             c[i]=in.nextInt();             w[i]=in.nextInt();;        }        Arrays.fill(dp, 0);        for (int i = 0; i &lt; n; i++) //遍历每一件物品        {                for(int j=c[i];j&lt;=C;j++)                //遍历背包容量，表示在上一层的基础上，容量为J时，第i件物品装或不装的最优解;                dp[j] = max(dp[j - c[i]] + w[i], dp[j]);        }        System.out.println(dp[C])    }}\n\n多重背包多重背包是背包问题的入门的问题。 根据 0-1 背包写出模板也是很简单的。\n多重背包的问题是什么呢？\n其问题的简单表述为，有 N 件物品，每件物品有件。每个物品都有一个价值，每件物品都有一个占一个部分空间,已知你的背包共计可承重 C(Contains),现在让你求你的背包最多装得下多少，即求你背包中物品的最大价值。\n对于这个问题我们有以下模板:\n1.定义变量并输入\n参考 0-1 背包。\n2.执行算法\n这次我们直接空间优化，不再讲解二维做法：\n多重背包是可以不选，也可以选 1 个，可以选多个，而 0-1 背包只能选 0 个或者 1个。\n那就直接把种物品分开，即可比如：\n每个盘子 3 块钱，我有 2 个。每双筷子 1 块钱，我有 10 双，每对刀叉 3 块钱，我有 3 个。\n那么我就可以拆成，有 2 个三块的盘子，每个可以选也可以不选，就变成了 0-1 背包。\n也就是说，对于每种是可以选多个，那就直接拆分成独立的个体就可以了。\nC++ 描述；\nfor(int i=0;i&lt;n;i++)//遍历每一个物品    for(int j=0;j&lt;=s[i];j++)    //遍历物品的数量        for(int k=C;k&gt;=c[i];k--)        //当做01背包来处理        {            //取01背包情况的dp[k]和dp[k-c[i]]+w[i]的最大值            dp[k]=max( dp[k],dp[k-c[i]]+w[i] );        }\n\nPython 语言描述:\nfor i in range(n):    for j in range(s[i]+1):        for k in reversed(range(c[i],C+1)):            dp[k]=max( dp[k],dp[k-c[i]]+w[i] )print(dp[C])\n\nJava 语言描述：\nfor(int i=0;i&lt;n;i++)//遍历每一个物品    for(int j=0;j&lt;=s[i];j++)    //遍历物品的数量        for(int k=C;k&gt;=c[i];k--)        //当做01背包来处理        {            //取01背包情况的dp[k]和dp[k-c[i]]+w[i]的最大值            dp[k]=max( dp[k],dp[k-c[i]]+w[i] );        }System.out.println(dp[C]);\n\n不顾这样做大概率会超时，我们换一种理解方式：\n在这两种问题中，我们需要考虑每个物品选择取或不取的情况，通过动态规划来求解最优解。\n背包问题中，对于每个物品，我们有两个选择：选取或不选取。状态转移方程为： \n多重背包问题中，对于每个物品i，我们可以选择取个、个、个…直到个。状态转移方程为：  其中，k 的取值范围是。\n这两个问题的解决思路相似，都是通过填充一个二维的动态规划数组，其中表示背包容量为j时的最优解。在状态转移时，我们考虑了每个物品的选择情况，求解最终的最优解。\n初始化细节：\n与  背包相同。\n\n装满 ，其余赋值；\n不装满全初始化为 ；\n\n题目描述:\n题目链接：https://www.lanqiao.cn/problems/1176/learning/\n小明有一个容量为 的背包。\n这天他去商场购物，商场一共有  件物品，第  件物品的体积为 ，价值为 ，每种物品都有个。\n小明想知道在购买的物品总体积不超过  的情况下所能获得的最大价值为多少，请你帮他算算。\n输入描述:\n输入第  行包含两个正整数 ，表示商场物品的数量和小明的背包容量。\n第  行包含  个正整数 ,表示物品的体积、价值和数量。\n样例:\n输入：3 301 2 34 5 67 8 9\n\n输出： 39\n\n运行限制:\n1. 最大运行时间：1s 2. 最大运行内存：128M\n\n答案解析：\nC++ 解题代码\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define Maxn 5000int c[Maxn], w[Maxn], s[Maxn];int dp[Maxn];int C;// 输入int n;int main() {    cin &gt;&gt; n;    cin &gt;&gt; C;    for (int i = 0; i &lt; n; i++) {        cin &gt;&gt; c[i] &gt;&gt; w[i] &gt;&gt; s[i];    }    int dp[Maxn];    memset(dp, 0, sizeof(dp)); //不装满    //创建动态规划数组    for (int i = 0; i &lt; n; i++)//遍历每一个物品    {        for(int j=C;j&gt;=c[i];j--)        {            for(int k=1;k&lt;=s[i] &amp;&amp; j&gt;=k*c[i];k++)                //遍历物品的数量                dp[j]=max(dp[j],dp[j-k*c[i]]+w[i]*k);        }    }    cout &lt;&lt; dp[C] &lt;&lt; endl;}\n\nPython 解题代码\nc = []w = []s=[]dp = []if __name__ == '__main__':    n, C = map(int, input().strip().split())    for i in range(n):        tempC, tempW ,tempS= map(int, input().strip().split())        c.append(tempC)        w.append(tempW)        s.append(tempS)    for i in range(C + 50):        dp.append(0)    for i in range(n):        for j in reversed(range(c[i],C+1)):            for k in range(s[i]+1):                if j&lt;k*c[i]:                    break;                dp[j] = max(dp[j], dp[j - k * c[i]] + w[i] * k)    print(dp[C])\n\nJava 解题代码\nimport java.util.Arrays;import java.util.Scanner;import static java.lang.Math.max;public  class  Main{        static int []c;        static int []w;        static int []s;        static int dp[];        public static void main(String[] args)        {            Scanner in = new Scanner(System.in);            int n=in.nextInt();            int C=in.nextInt();            c=new int[n+50];            w=new int[n+50];            s=new int[n+50];            dp=new int [C+50];            for (int i = 0; i &lt; n; i++) {                c[i]=in.nextInt();                w[i]=in.nextInt();                s[i]=in.nextInt();            }            Arrays.fill(dp, 0);            for (int i = 0; i &lt; n; i++)//遍历每一个物品            {                for(int j=C;j&gt;=c[i];j--)                {                    for(int k=1;k&lt;=s[i] &amp;&amp; j&gt;=k*c[i];k++)                        //遍历物品的数量                        dp[j]=max(dp[j],dp[j-k*c[i]]+w[i]*k);                }            }            System.out.println(dp[C]);    }}\n\n动态规划线性 DP实验介绍本课程对于算法学习非常重要，但是又比较难，我们讲解分  个章节进行动态规划问题的讲解。\n今天的课程是动态规划系列的第  个章节。\n知识点\n讲解很多经典的动态规划问题，对动态规划初步掌握。\n\n普通线性 DP线性 DP 是动态规划问题中的一类问题，指状态之间有线性关系的动态规划问题。\n这类问题不像是我们讲的背包等问题有固定的模板。\n少数常见的线性 DP 问题也有模板，比如我们讲的  和  问题。\n大部分还是需要根据题目进行推导，基本没有什么规律可循。\n大部分线性规划的问题，都需要自己首先定义状态，找到决策，推导状态转移方程。\n我们再讲解几个题目，让大家找找做最普遍 DP 问题的感觉。\n蓝肽子序列题目链接：蓝肽子序列\n题目描述:\nL 星球上的生物由蛋蓝质组成，每一种蛋蓝质由一类称为蓝肽的物资首尾连接成一条长链后折叠而成。\n生物学家小乔正在研究 L 星球上的蛋蓝质。她拿到两个蛋蓝质的蓝肽序列，想通过这两条蓝肽序列的共同特点来分析两种蛋蓝质的相似性。\n具体的，一个蓝肽可以使用  至  个英文字母表示，其中第一个字母大写，后面的字母小写。一个蛋蓝质的蓝肽序列可以用蓝肽的表示顺序拼接而成。\n在一条蓝肽序列中，如果选取其中的一些位置，把这些位置的蓝肽取出，并按照它们在原序列中的位置摆放，则称为这条蓝肽的一个子序列。蓝肽的子序列不一定在原序列中是连续的，中间可能间隔着一些未被取出的蓝肽。\n如果第一条蓝肽序列可以取出一个子序列与第二条蓝肽序列中取出的某个子序列相等，则称为一个公共蓝肽子序列。\n给定两条蓝肽序列，找出他们最长的那个公共蓝肽子序列的长度。\n输入描述:\n输入两行，每行包含一个字符串，表示一个蓝肽序列。字符串中间没有空格等分隔字符。\n其中有 ，两个字符串的长度均不超过 。\n输出描述:\n输出一个整数，表示最长的那个公共蓝肽子序列的长度。\n输入输出样例:\n示例:\n\n输入\n\nLanQiaoBei LanTaiXiaoQiao\n\n\n输出\n\n2\n\n运行限制\n最大运行时间：1s\n最大运行内存: 128M\n\n答案解析：\n该题目是  的变形，由原来的一个字符或者一个数字的匹配变成了，一个单词的匹配。\n这个题目为先划分字符串变成基本的比较单位。\n然后再套用  模板\n即可完成这道题目。\nC++ 解题代码\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[1005][1005];string s1, s2;string a[1005], b[1005];int n=0, m=0;int main(){    cin &gt;&gt; s1 &gt;&gt; s2;    int d1 = s1.length(), d2 = s2.length();    for (int i = 0; i &lt; d1;)    {        if (s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'Z')        {            a[n] += s1[i++];            while (s1[i] &gt;= 'a' &amp;&amp; s1[i] &lt;= 'z')            {                a[n] += s1[i++];            }        }        n++;    }    for (int i = 0; i &lt; d2;)    {        if (s2[i] &gt;= 'A' &amp;&amp; s2[i] &lt;= 'Z')        {            b[m] += s2[i++];            while (s2[i] &gt;= 'a' &amp;&amp; s2[i] &lt;= 'z')            {                b[m] += s2[i++];            }        }        m++;    }     dp[0][0] = 0;    for (int i = 0; i &lt; n; i++)        for (int j = 0; j &lt; m; j++)        {            if (a[i] == b[j])            {                dp[i + 1][j + 1] = dp[i][j] + 1;            }            else            {                dp[i + 1][j + 1]=max(dp[i + 1][j], dp[i][j + 1]);            }        }    cout &lt;&lt; dp[n][m] &lt;&lt; endl;}\n\nPython 解题代码\nMaxn = 1005dp = [[0 for _ in range(Maxn)] for _ in range(Maxn)]if __name__ == '__main__':    s1 = input()    s2 = input()    a = []    b = []    temp = ''    for word in s1:        if 'A' &lt;= word &lt;= 'Z':            if temp != '':                a.append(temp)            temp = ''        temp += word    a.append(temp)    temp = ' '    for word in s2:        if 'A' &lt;= word &lt;= 'Z':            if temp != '':                b.append(temp)            temp = ''        temp += word    b.append(temp)    n = len(a)    m = len(b)    for i in range(len(a)):        for j in range(len(b)):            if a[i] == b[j]:                dp[i + 1][j + 1] = dp[i][j] + 1            else:                if dp[i + 1][j] &gt; dp[i][j + 1]:                    dp[i + 1][j + 1] = dp[i + 1][j]                else:                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])    print(dp[n][m])\n\nJava 解题代码\nimport java.util.Scanner;public class Main {    static int[][] dp;    static String s1;    static String s2;    static String []a;    static String []b;    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        int n=0,m=0;        s1=in.next();        s2=in.next();        a=new String[1005];        b=new String[1005];        int d1=s1.length();        int d2=s2.length();        dp=new int[1005][1005];        for (int i = 0; i &lt; d1;n++)        {            if (s1.charAt(i) - 'A'&gt;=0 &amp;&amp; s1.charAt(i) - 'Z'&lt;=0)            {                a[n] += s1.charAt(i++);                while (i &lt; d1&amp;&amp;s1.charAt(i) -'a'&gt;=0 &amp;&amp; s1.charAt(i)-'z' &lt;=0)                {                    a[n] += s1.charAt(i++);                }            }        }        for (int i = 0; i &lt; d2;m++)        {            if (s2.charAt(i) - 'A'&gt;=0 &amp;&amp; s2.charAt(i) - 'Z'&lt;=0)            {                b[m] += s2.charAt(i++);                while (i &lt; d2&amp;&amp;s2.charAt(i) -'a'&gt;=0&amp;&amp; s2.charAt(i)-'z' &lt;= 0)                {                    b[m] += s2.charAt(i++);                }            }        }        dp[0][0] = 0;        int Maxn=Math.max(n,m)+50;        dp=new int[Maxn][Maxn];        dp[0][0]=0;        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++)            {                if (a[i].equals( b[j]))                {                    dp[i + 1][j + 1] = dp[i][j] + 1;                }                else                {                    dp[i + 1][j + 1]=Math.max(dp[i + 1][j], dp[i][j + 1]);                }            }        System.out.println(dp[n][m]);    }}\n\n合唱队形题目链接：https://www.lanqiao.cn/problems/742/learning/\n题目描述:\n 位同学站成一排，音乐老师要请其中的  位同学出列，使得剩下的  位同学排成合唱队形。\n合唱队形是指这样的一种队形：设  位同学从左到右依次编号为 ，，，他们的身高分别为 ，，，， 则他们的身高满足 。\n你的任务是，已知所有  位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。\n输入描述:\n输入两行。\n第一行是一个整数 ，表示同学的总数。\n第二行有  个整数，用空格分隔，第  个整数  是第  位同学的身高(厘米)。\n输出描述:\n输出一个整数，就是最少需要几位同学出列。\n输入输出样例:\n示例: 1\n\n输入\n\n8 186 186 150 200 160 130 197 220\n\n\n输出\n\n4\n\n运行限制\n最大运行时间：1s\n最大运行内存: 128M\n\n答案解析：\n要使得出列最少，那么就要留下最多的，我们想到了  ，但是  只能处理单调序列最长，所以并不能直接用。\n我们看到，这里是两头低，中间高的一种情况。\n在这种情况下，最多的话那么就是最高的那个人的左侧加上右侧最高。\n到这，我们发现。\n在中间那个人左侧，从左到右做了一遍  。\n在那个人的右侧，从右到左的做了一遍  。\n至此，我们好像找了策略。\n通过枚举中间那个人，然后看他左侧的  和他右侧的 的值之和的大小，就能将这道题目解出。\nC++ 解题代码\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp1[105],dp2[105],a[105],s[105];int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a[i];        dp2[i]=1;        dp1[i]=1;    }//输入并赋初值    //预处理，从右往左LIS    for(int i=n-1;i&gt;=1;i--)    {        for(int j=i+1;j&lt;=n;j++)        {            if(a[i]&gt;a[j]&amp;&amp;dp2[i]&lt;=dp2[j]+1)            {                dp2[i]=dp2[j]+1;            }        }    }    //预处理，从左往右LIS    for(int i=2;i&lt;=n;i++)    {        for(int j=1;j&lt;i;j++)        {            if(a[i]&gt;a[j]&amp;&amp;dp1[i]&lt;=dp1[j]+1)            {                dp1[i]=dp1[j]+1;            }        }    }    int maxx=0;    for(int i=1;i&lt;=n;i++)    {        s[i]=dp2[i]+dp1[i]-1;        //自己算了两次，所以-1        if(s[i]&gt;maxx)        {            maxx=s[i];        }    }    cout&lt;&lt;n-maxx;//是求出列的人数}\n\nPython 解题代码\nif __name__ == \"__main__\":    # 输入并赋初值    n = int(input().strip())    t = list(map(int, input().split()))    dp1 = [1] * n    dp2 = [1] * n    # 预处理，从左往右LIS    for i in range(1, n):        for j in range(i):            if t[i] &gt; t[j]:                dp1[i] = max(dp1[i], dp1[j] + 1)    # 预处理，从右往左LIS    for i in range(n - 1, 0, -1):        for j in range(n - 1, i, -1):            if t[i] &gt; t[j]:                dp2[i] = max(dp2[i], dp2[j] + 1)    maxx = 0    for i in range(n):        maxx = max(maxx, dp1[i] + dp2[i] - 1)        # 自己算了两次，所以-1    print(n - maxx)\n\nJava 解题代码\nimport java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        int n = in.nextInt();        int[] a = new int[n];        int[] dp1 = new int[n];        int[] dp2 = new int[n];        for (int i = 0; i &lt; n; i++) {            a[i] = in.nextInt();            dp2[i]=1;            dp1[i]=1;        }//输入并赋初值        //预处理，从左往右LIS        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; i; j++) {                if (a[i] &gt; a[j] &amp;&amp; dp1[j] + 1 &gt; dp1[i]) {                    dp1[i] = dp1[j] + 1;                }            }        }        //预处理，从右往左LIS        for (int i = n - 1; i &gt;= 0; i--) {            for (int j = n - 1; j &gt; i; j--) {                if (a[i] &gt; a[j] &amp;&amp; dp2[j] + 1 &gt; dp2[i]) {                    dp2[i] = dp2[j] + 1;                }            }        }        int maxx = 0;        for (int i = 0; i &lt; n; i++) {            maxx = Math.max(maxx, dp1[i] + dp2[i]-1);            //自己算了两次，所以-1        }        // 是求出列的人数        System.out.println(n - maxx );    }}\n\n最优包含题目链接：https://www.lanqiao.cn/problems/239/learning/\n题目描述: 我们称一个字符串  包含字符串  是指  是  的一个子序列，即可以从字符串  中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与  完全一样。\n给定两个字符串  和 ，请问最少修改  中的多少个字符，能使  包含  ？\n其中，。\n输入描述:\n输入两行，每行一个字符串。\n第一行的字符串为 ，第二行的字符串为 。\n两个字符串均非空而且只包含大写英文字母。\n输出描述:\n输出一个整数，表示答案。\n输入输出样例:\n示例:\n\n输入\n\nABCDEABCD XAABZ\n\n\n输出\n\n3\n\n运行限制\n\n最大运行时间：1s\n最大运行内存: 256M\n\n答案解析：\n个题目是线性 DP 中比较经典的题目。\n这个类型就做编辑距离，可以通过 DFS 解决，也可以通过 DP 解决。\nDP 的时间复杂度低。\n我们先来讲一下，编辑距离。\n编辑距离为两个字符串， 和  通过多少次变换，使得  变成 。\n我们可以做出  种操作。\n 删除操作，将  从  中移除  插入操作，在  后加上   替换操作，将  修改为 \n编辑距离的状态转移类似 LCS ，但有有很大的差别。\n初始状态，，都在字符串的开头。\n然后开始判断 \n\n如果相同，那么就不需要修改，所以\n所以在等于时，这个状态由转移而来。\n\n\n如果不同，那就需要进行三种可能的操作\n\n\n\n修改操作：\n 修改为 ， 因为编辑了一次，所以\n\n所以在不等于时，这个状态由转移而来。\n\n\n删除操作，直接把  删除，此时转移到  ，因为  被删除，但是下一个字符到了  的位置，而对应比较的位置到了。\n所以此时状态转移到了\n\n因为编辑了一次，所以\n所以在不等于时，就有可能通过转移而来。\n\n插入操作，在后添加一个，那么此时和对应，因为加了一个字符就变成了,而且跟对应，那么下一个状态转移到了\n\n此时状态转移到了 \n因为编辑了一次，所以\n所以在不等于时，就有可能通过转移而来。\n\n\n那么不同时，我们选择他们的最小值即可。\n由此我们可以写出模板：\nC++ 解题代码：\n#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;string&gt;using namespace std;#define INF 99999999string s, t;int dp[1010][1010];void init(){    for (int i = 0; i &lt;= s.size(); i++) dp[i][0] = 0;    for (int j = 1; j &lt;= t.size(); j++) dp[0][j] = INF;}int main() {    cin &gt;&gt; s &gt;&gt; t;    init();    for (int i = 1; i &lt;= s.size(); i++) {        for (int j = 1; j &lt;= t.size(); j++) {            if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1];            else                dp[i][j] = min(dp[i - 1][j - 1],min(dp[i - 1][j], dp[i][j - 1])) + 1;        }    }    cout &lt;&lt; dp[s.size()][t.size()];    return 0;}\n\nPython 解题代码\ndef init(s,t):    dp = [[0 for i in range(len(t) + 1)] for j in range(len(s) + 1)]    for i in range(len(s) + 1):        dp[i][0] = 0    for j in range(1,len(t) + 1):        dp[0][j] = 999999    return dpif __name__ == '__main__':    s = list(input())    t = list(input())    dp=init(s,t)    for i in range(len(s)):        for j in range(len(t)):            if s[i] == t[j]:                dp[i + 1][j + 1] = dp[i][j]            else:                dp[i + 1][j + 1] = min(dp[i][j] + 1, dp[i][j + 1])                dp[i + 1][j + 1] = min( dp[i + 1][j + 1] ,dp[j+1][i]+1)    print(dp[-1][-1])\n\nJava 解题代码\nimport java.util.Scanner;public class Main {    public static   int dp[][];    public static void init(int n,int m){        dp = new int[n+1][m+1];        for (int i = 0; i &lt;= n; i++) dp[i][0] = 0;        for (int j = 1; j &lt;= m; j++) dp[0][j] = 99999;    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        String s = in.nextLine();        String t = in.nextLine();        int n = s.length();        int m = t.length();        init(n,m);        for (int i = 1; i &lt;= n; i++) {            for (int j = 1; j &lt;= m; j++) {                if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];                else  dp[i][j] = min(dp[i - 1][j - 1],min(dp[i - 1][j], dp[i][j - 1])) + 1;            }        }        System.out.println(dp[n][m]);    }}\n\n这道题目也比较简单，由于是包含关系，并不是相等关系，所以当 S 多余 T 是，不需要进行删除操作。\n所以这个题目不考虑删除的那个状态转移即可。\nC++ 解题代码\n#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;string&gt;using namespace std;#define INF 99999999string s, t;int dp[1010][1010];void init(){    for (int i = 0; i &lt;= s.size(); i++) dp[i][0] = 0;    for (int j = 1; j &lt;= t.size(); j++) dp[0][j] = INF;}int main() {    cin &gt;&gt; s &gt;&gt; t;    init();    for (int i = 1; i &lt;= s.size(); i++) {        for (int j = 1; j &lt;= t.size(); j++) {            if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1];            else dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j]);        }    }    cout &lt;&lt; dp[s.size()][t.size()];    return 0;}\n\nPython 解题代码\ndef init(s,t):    dp = [[0 for i in range(len(t) + 1)] for j in range(len(s) + 1)]    for i in range(len(s) + 1):        dp[i][0] = 0    for j in range(1,len(t) + 1):        dp[0][j] = 999999    return dpif __name__ == '__main__':    s = list(input())    t = list(input())    dp=init(s,t)    for i in range(len(s)):        for j in range(len(t)):            if s[i] == t[j]:                dp[i + 1][j + 1] = dp[i][j]            else:                dp[i + 1][j + 1] = min(dp[i][j] + 1, dp[i][j + 1])    print(dp[-1][-1])\n\nJava 解题代码\nimport java.util.Scanner;public class Main {    public static   int dp[][];    public static void init(int n,int m){        dp = new int[n+1][m+1];        for (int i = 0; i &lt;= n; i++) dp[i][0] = 0;        for (int j = 1; j &lt;= m; j++) dp[0][j] = 99999;    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        String s = in.nextLine();        String t = in.nextLine();        int n = s.length();        int m = t.length();        init(n,m);        for (int i = 1; i &lt;= n; i++) {            for (int j = 1; j &lt;= m; j++) {                if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];                else dp[i][j] = Math.min(dp[i - 1][j - 1] + 1, dp[i - 1][j]);            }        }        System.out.println(dp[n][m]);    }}\n\n实验总结动态规划的学习是痛苦的，也是快乐，而且是非常重要的。\n希望大家努力克服，动态规划都学会了还有什么学不会呢。\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]并查集","url":"/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"并查集并查集是我认为最巧妙优雅的一种数据结构，他主要适用于解决元素分组和不相交集合的合并和查询问题。\n并查集也非常简单，但是，并查集在比赛中非常常用，能够极大的降低算法复杂度得数据结构，是必须要掌握熟练的。\n本节课的难度相对较低，无论是实现方式还是算法原理。\n知识点1.并查集的原理与实现方式 2.并查集的路径压缩 3.启发式合并\n并查集并查集是大量的树（单个节点也算是树）经过合并生成一系列家族森林的过程。\n每个集合也就是每棵树都是由根节点确定，也可以理解为每个家族的族长就是根节点。\n举个数字和字母的例子如下。\n初始森林： \n\n经过的一系列合并后的状态（不唯一，举个栗子）：\n\n最终合并后的状态：\n注：示意图的位置与存储物理位置无关，只代表逻辑关系。\n\n并查集的存储结构并查集采用数组表示整个森林，初始时每个森林的树根为自己。\nC++ 存储与初始化：\n# define Maxn 200// 假设所需数量为200int fa[Maxn+1]void init(){    for(int i =0;i&lt;=Maxn; i++)        fa[i]=i;}\n\nPython 存储与初始化：\nMaxn = 200# 假设所需的数量为200fa = []def init():    for i in range(Maxn + 1):        fa.append(i)\n\nJava 存储与初始化：\nstatic final int Maxn = 200;static int fa[]=new int[Maxn+1];static void init() {    for(int i=0 ;i&lt;=Maxn;i++)        fa[i]=i;}\n\n查询一般用递归法实现对代表元素的查询：递归访问父节点，直至根节点（根节点的标志就是父节点是本身）。\n根节点相同的两个元素属于同一个集合，上面也说到了。所以判断 A，B 是否属于一个集合直接判断 find(A)和 find(B)是否相同即可。\n由于代码比较简单，我们先给出查询的代码：\nC++ 查询：\nint find(int x){    if(fa[x] == x)        return x;    else        return find(fa[x]);}\n\nPython 查询：\ndef find(x):    if fa[x] == x:        return x    else:        return find(fa[x])\n\nJava 查询：\nstatic  int find(int x){    if(fa[x] == x)        return x;    else        return find(fa[x]);}\n\n我们这里有一个问题，当树的链很长时，比如：\n\n如果每次都查询最后一个，那么他就要经过多次递归，非常消耗时间，这时候我们就要引入路径压缩。\n路径压缩路径压缩是为了解决当树的高度过高的时候，提高查询时效的方法。\n解决方式也很简单，在递归的同时将路径压缩，那么上面的图经过一次查询后的效果如下。\n\n其实，实现方式也非常简单，只需要将查询代码修改即可，代码如下：\nC++ 查询带路径压缩：\nint find(int x){    if(x == fa[x])        return x;    else    {        fa[x] = find(fa[x]);        //父节点设为根节点        return fa[x];        //返回父节点    }}\n\nPython 查询带路径压缩：\ndef find(x):    if fa[x] == x:        return x    else:        fa[x] = find(fa[x]);        #父节点设为根节点        return  fa[x]        # 返回父节点\n\nJava 查询带路径压缩：\nstatic  int find(int x){    if(x == fa[x])        return x;    else    {        fa[x] = find(fa[x]);        //父节点设为根节点        return fa[x];        //返回父节点    }}\n\n合并合并的方式很简单，就是把一颗树的根节点设置为另一棵树的根节点即可。\n还有一种方式是按秩合并，但是我们使用路径压缩时间复杂度就已经很低了，如果在引入 rank 相对会有些复杂。而且对于我们的使用路径压缩一种方式就已经足够。并且路径压缩和按秩合并一起使用时会影响 rank 准确性，所以我们采用普通的合并与优化后的查找即可。\n\n合并后：\n\nC++ 合并：\nvoid merge(int i, int j){    fa[find(i)] = find(j);}\n\nPython 合并：\ndef merge(x,y):    fa[find(x)] = find(y)\n\nJava 合并：\nstatic void merge(int i, int j){    fa[find(i)] = find(j);}\n\n合并优化：\n除此之外还有一个优化是启发式合并，其实这个启发式是泛指有很多的合并算法都叫启发式合并，我们这里讲其中一种常用的启发式合并。合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以按照子树大小去合并，小的合并到大的，以免发生退化。所以启发式合并的原理是在集合合并时将小的集合合并到大的集合里，也可以使 find 操作复杂度降低到  ，在集合合并时还要增加一个更新集合大小的操作。\nC++void merge(int x,int y)//启发式合并{    x=find(x);    y=find(y);    if(x!=y)    {        if(sz[x]&lt;sz[y])            swap(x,y);        sz[x]+=sz[y];        fa[y]=x;    }}Java    public void merge(int x, int y) {        x = find(x);        y = find(y);        if (x != y) {            if (sz[x] &lt; sz[y]) {                swap(x, y);            }            sz[x] += sz[y];            fa[y] = x;        }    }pythondef merge(x, y, sz, fa):    x = find(x, fa)    y = find(y, fa)    if x != y:        if sz[x] &lt; sz[y]:            swap(x, y, fa)        sz[x] += sz[y]        fa[y] = x\n\n如果是一般的并查集题目用路径压缩就可以了，当然两种优化都用的话复杂度可以降得更低。两种优化都使用的话单次操作的复杂度才是  \n并查集相关题目讲解合根植物题目链接\n难度: 简单\n标签: 并查集, 2017, 国赛\n题目描述:\nw 星球的一个种植园，被分成 m×n 个小格子（东西方向 m 行，南北方向 n 列）。每个格子里种了一株合根植物。这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？\n\n输入描述:\n第一行，两个整数 m,n，用空格分开，表示格子的行数、列数（1≤m,n≤1000）。接下来一行，一个整数 k (0≤k≤105 )，表示下面还有 k 行数据。接下来 k 行，每行两个整数 a，b，表示编号为 a 的小格子和编号为 b 的小格子合根了。格子的编号一行一行，从上到下，从左到右编号。比如：5×4 的小格子，编号：\n\n\n\n\n行列\n①\n②\n③\n④\n\n\n\n①\n1\n2\n3\n4\n\n\n②\n5\n6\n7\n8\n\n\n③\n9\n10\n11\n12\n\n\n④\n13\n14\n15\n16\n\n\n⑤\n17\n18\n19\n20\n\n\n输出描述:\n输出植物数量。\n\n输入输出样例:\n示例:\n输入:\n5 4162 31 55 94 87 89 1010 1111 1210 1412 1614 1817 1815 1919 209 1313 17\n\n输出:\n5\n\n样例图例如下：\n\n运行限制:\n最大运行时间：1s 最大运行内存: 256M\n\n题目解析：\n这个题就是一个模板并查集的题目，每次合根就是一次 Merge。\n最后答案就是看有多少个根即可，那么就是看有多少个fa[x]=x即可。\n直接按照题目编写即可，部分解析直接写进题目。\n答案解析：\nC++ 描述：\n#include &lt;bits/stdc++.h&gt;using namespace std;# define Maxn 2000000// 假设所需数量为200int fa[Maxn+1];void init(){    for(int i =0; i&lt;=Maxn; i++)        fa[i]=i;}int find(int x){    if(x == fa[x])        return x;    else    {        fa[x] = find(fa[x]);        //父节点设为根节点        return fa[x];        //返回父节点    }}void merge(int i, int j){    fa[find(i)] = find(j);}int n,m; //n行，m列int k; //k次合根int main(){    init();    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    int a,b;    for(int i=1; i&lt;=k; i++)    {        cin&gt;&gt;a&gt;&gt;b;        merge(a,b); //合根    }    int ans=0;    for(int i=1; i&lt;=n*m; i++)    {        if(fa[i]==i) //找根节点        {            ans++;        }    }    cout&lt;&lt;ans;    return 0;}\n\nPython 描述：\nMaxn = 2000000# 假设所需的数量为200fa = []def init():    for i in range(Maxn + 1):        fa.append(i)def find(x):    if fa[x] == x:        return x    else:        fa[x] = find(fa[x])        #父节点设为根节点        return  fa[x]        # 返回父节点def merge(x,y):    fa[find(x)] = find(y)if __name__ == '__main__':    n,m=input().split()    k=input()    n=int(n)    m=int(m)    k=int(k)    Maxn=m*n+100    init()    for _ in range(k):        a,b= input().split()        a=int(a)        b=int(b)        merge(a,b)    ans=0    for i in range(m*n): #从0开始        index=i+1 #调整一下，应该是从1开始        if(fa[index]==index):            ans+=1    print(ans)\n\nJava 描述：\nimport java.util.Scanner;public class Main {    static  int Maxn;    static int fa[];    static void init() {        for(int i=0 ;i&lt;=Maxn;i++)            fa[i]=i;    }    static  int find(int x)    {        if(x == fa[x])            return x;        else        {            fa[x] = find(fa[x]);            //父节点设为根节点            return fa[x];            //返回父节点        }    }    static void merge(int i, int j)    {        fa[find(i)] = find(j);    }    static int n,m; //n行，m列    static int k; //k次合根    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        n=in.nextInt();        m=in.nextInt();        k=in.nextInt();        Maxn=m*n;        fa=new int[Maxn+100];        init();        int a,b;        for(int i=1; i&lt;=k; i++)        {            a=in.nextInt();            b=in.nextInt();            merge(a,b);        }        int ans=0;        for(int i=1; i&lt;=n*m; i++)        {            if(fa[i]==i)            {                ans++;            }        }        System.out.println(ans);    }}\n\n修改数组题目链接\n难度: 中等\n标签: 并查集, 2019, 省赛\n题目描述: 给定一个长度为  的数组 ，数组中有可能有重复出现的整数。\n现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改。\n当修改  时，小明会检查  是否在  ∼  中出现过。如果出现过，则小明会给  加上 1 ；如果新的  仍在之前出现过，小明会持续给  加 1 ，直 到  没有在  ∼  中出现过。\n当  也经过上述修改之后，显然  数组中就没有重复的整数了。\n现在给定初始的  数组，请你计算出最终的  数组。\n输入:\n第一行包含一个整数 。\n第二行包含  个整数 。\n其中，，。\n输出：\n输出  个整数，依次是最终的 。\n输入输出样例:\n输入\n52 1 1 3 4\n\n输出\n2 1 3 4 5\n\n运行限制:\n最大运行时间：1s 最大运行内存: 128M\n\n题目解析：\n第一步，先初始化并查集。\n第二步，读入数组并作如下处理：\n如果这数字在之前没出现过那么他的值应该就是自己，并将其加入集合，此后再出现这个数字那么就要输出这个数字加 ，所以将这个数字的根节点设置为这个数字 即可。\n如果这个数字之前出现过那么这个数字应该变成根节点的值，根节点的值是之前出现过的值加。\n然后重复简单的逻辑即可，现在是维护一个之前出现过的集合，每个出现过的数字会把根节点设置为比他大  的数字，重复这个过程即可完成题意。\n我们之前说过，因为输入输出是分开的，这里直接输出就行，不必在使用数组存储。\n比如样例：\n2 1 1 3 4首先因为 2 没出现过现在，所以初始化后的 fa[2] 等于2所以直接输出2 即可。此时 2 已经出现过了，下次遇见2就要输出3，所以这里我们使fa[2]等于3或者使用merge(2,3);然后输入1，因为1 也没有出现过，所以重复 2 的操作即可。输出fa[1]。令fa[1]=2，但是fa[2]=3,因为2也出现过这样fa[1]=fa[2]=3当然这里只需要执行merge(2,3)然后输入1，因为1 之前出现过，而且他的值我们之前也处理好了，直接输出即可。输出fa[1],即3。使用merge(3,4)然后重复上述过程，代码如下：        输入X :Input(X)        找到根节点: X=find(X);        输出应该是多少：Print(X)        将根节点加+1处理：merge(X,X+1);\n\n答案解析：\nC++ 描述：\n #include &lt;bits/stdc++.h&gt;using namespace std;# define Maxn 2000000// 假设所需数量为2000000int fa[Maxn+1];void init(){    for(int i =0; i&lt;=Maxn; i++)        fa[i]=i;}int find(int x){    if(x == fa[x])        return x;    else    {        fa[x] = find(fa[x]);        //父节点设为根节点        return fa[x];        //返回父节点    }}void merge(int i, int j){    fa[find(i)] = find(j);}int main(){    init();    int n;    cin&gt;&gt;n;    for(int i=0; i&lt;n; i++)    {        int t;        cin&gt;&gt;t;        t=find(t);        cout&lt;&lt;t&lt;&lt;\" \";        merge(t,t+1);    }    return 0;}\n\nPython 描述：\nMaxn = 2000000# 假设所需的数量为200fa = []def init():    for i in range(Maxn + 1):        fa.append(i)def find(x):    if fa[x] == x:        return x    else:        fa[x] = find(fa[x]);        #父节点设为根节点        return  fa[x]        # 返回父节点def merge(x,y):    fa[find(x)] = find(y)if __name__ == '__main__':    n=input()    A=input().split()    A=list(map(int,A))    Maxn=len(A)+100    init()    for i in range(len(A)):        t=find(A[i])        print(t,end=\" \")        merge(t,t+1)\n\nJava 描述：\nimport java.util.Scanner;public class Main {    static  int Maxn=1000005;    static int fa[];    static void init() {        for(int i=0 ;i&lt;=Maxn;i++)            fa[i]=i;    }    static  int find(int x)    {        if(x == fa[x])            return x;        else        {            fa[x] = find(fa[x]);            //父节点设为根节点            return fa[x];            //返回父节点        }    }    static void merge(int i, int j)    {        fa[find(i)] = find(j);    }    static int n,m; //n行，m列    static int k; //k次合根    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        n=in.nextInt();        fa=new int[Maxn+100];        init();        for(int i=1; i&lt;=n; i++)        {            int t;            t=in.nextInt();            t=find(t);            System.out.print(t+\" \");            merge(t,t+1);        }    }}\n\n总结并查集的思想非常简单，但是我们也看到了题目有点复杂，稍微一点改变就是另一种方向。并查集代码实现非常简单，但重点还是看对于题目的把握，这个数据结构不仅直接出题目，并且也会杂糅到别的算法里面，所以他的应用非常广泛，需要我们牢牢地掌握。\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]图论入门","url":"/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8/","content":"图论本章节为图论最基本的内容，要求每位同学都要尽量掌握。\n图的基本概念图：由点(node，或者 vertex)和连接点的边(edge)组成。图是点和边构成的网。\n树：特殊的图\n树，即连通无环图树的结点从根开始，层层扩展子树，是一种层次关系，这种层次关系，保证了树上不会出现环路。两点之间的路径：有且仅有一条路径。最近公共祖先。\n图的种类（1）无向无权图，边没有权值、没有方向； （2）有向无权图，边有方向、无权值； （3）加权无向图，边有权值，但没有方向； （4）加权有向图； （5）有向无环图（Directed Acyclic Graph，DAG）。\n图算法的时间分析图算法的复杂度和边的数量 E、点的数量 V 相关。：几乎是图问题中能达到的最好程度。、：很好的算法。、或更高：不算是好的算法。\n图的存储能快速访问：图的存储，能让程序很快定位结点 u 和 v 的边(u, v) 。\n\n数组存边：简单、空间使用最少；无法快递定位\n邻接矩阵：简单、空间使用最大；定位最快 dis[a][b]\n邻接表：空间很少，定位较快\n链式前向星：空间更少，定位较快\n\n注： 存储方式跟题目相匹配，占用空间少定位快也不一定是问题的最优存储方式。\n数组存边优点：简单、最省空间。 缺点：无法定位某条边。 应用：bellman-ford 算法、最小生成树的 kruskal 算法\n\nC++\n\n// c/c++实现struct Edge{    int from,to,dis;}e[M]; //结构体数组存边cin&gt;&gt;n&gt;&gt;m;for(int i=1;i&lt;=m;++i)    cin&gt;&gt;e[i].from&gt;&gt;e[i].to&gt;&gt;e[i].dis;\n\n\nJava\n\n//Java实现class Edge { int from; int to; int dis;    public Edge(int from, int to, int dis) {        this.from = from;        this.to = to;        this.dis = dis;    }}Edge[] e = new Edge[M];Scanner sc = new Scanner(System.in);int n = sc.nextInt();int m = sc.nextInt();for (int i = 0; i &lt; m; ++i){    int from = sc.nextInt();    int to = sc.nextInt();    int dis = sc.nextInt();    e[i] = new Edge(from, to, dis);}\n\n\nPython\n\n#python实现class Edge:    def init(self, f, t, d):        self.from = f        self.to = t        self.dis = de = [Edge(0, 0, 0) for i in range(M)]n, m = map(int, input().split())for i in range(1, m + 1):    e[i].from, e[i].to, e[i].dis = map(int, input().split())\n\n邻接矩阵二维数组：  \n无向图： 。 \n有向图： 。 \n权值： 存结点到的边的权值。 \n例如 ，等等。 \n用 表示，之间无边。\n优点：\n\n适合稠密图；\n编码非常简短；\n对边的存储、查询、更新等操作又快又简单。\n\n缺点：\n\n存储复杂度 太高。V=10000 时，空间 100M。\n不能存储重边。\n\n邻接表和链式前向星邻接表（指针或数组下标）和链式前向星（容器模拟）的思路一样，只是表达方式不同。\n\n\nC++\n\nstruct edge{    int from, to; long long w; //起点，终点，权值。起点from并没有用到，e[i]的i就是from    edge(int a, int b,long long c){from=a; to=b; w=c;}};vector&lt;edge&gt;e[N];          //用于存储图\n\n\nJava\n\nstatic class Edge {    int from, to;    long w;    Edge(int a, int b, long c) {        from = a;        to = b;        w = c;    }}static ArrayList&lt;Edge&gt;[] e = new ArrayList[N];\n\n\nPython\n\nclass Edge:    def __init__(self, fr, to, w):        self.fr = fr        self.to = to        self.w = we = [[] for _ in range(N)]\n\n我们会在使用的时候进行讲解。\n最短路问题最广为人知的图论问题就是最短路径问题。\n简单图的最短路径\n\n树上的路径：任意  点之间\n\n只有一条路径\n\n所有边长都为  的图：用 BFS 搜最短路径，复杂度 \n\n普通图的最短路径\n\n边长：不一定等于 ，而且可能为负数\n算法：Floyd、Dijkstra、SPFA 等，各有应用场景，不可互相替代\n\n最短路算法比较\n\n\n问题\n边权\n算法\n时间复杂度\n\n\n\n一个起点，一个终点\n非负数；无边权（或边权为 1）\nA*\n&lt; \n\n\n\n\n双向广搜\n&lt; \n\n\n\n\n贪心最优搜索\n&lt; \n\n\n一个起点到其他所有点\n无边权（或边权为 1）\nBFS\n\n\n\n\n非负数\nDijkstra(堆优化优先队列)\n\n\n\n\n允许有负数\nSPFA\n&lt; \n\n\n所有点对之间\n允许有负数\nFloyd-Warshall\n\n\n\n什么算法也不能解决存在负环图的最短路的问题！最多是判断是否存在，或者找到负环。\n网站推荐：CSAcademy Graph Editor\n\n方便图论的学习。\nFloyd 算法\n最简单的最短路径算法，代码仅有  行\n存图：最简单的矩阵存图\n易懂，比暴力的搜索更简单易懂。\n效率不高，不能用于大图在某些场景下有自己的优势，难以替代。能做传递闭包问题（离散数学）\n\nC++、Java\n//java 和 c++for(int k=1; k&lt;=n; k++)         //floyd的三重循环    for(int i=1; i&lt;=n; i++)        for(int j=1; j&lt;=n; j++)      // k循环在i、j循环外面            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n\n\nPython\n\n#pythonfor k in range(1, n+1): #floyd的三重循环    for i in range(1, n+1):        for j in range(1, n+1): # k循环在i、j循环外面            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n\nFloyd算法：多源最短路算法，一次计算能得到图中每一对结点之间（多对多）的最短路径。 Dijkstra、Bellman-Ford、SPFA算法：单源最短路径算法（Single source shortest path algorithm），一次计算能得到一个起点到其他所有点（一对多）的最短路径。在截止目前的蓝桥杯大赛中，Floyd算法是最常见的最短路径算法。 以上统计包括国赛和省赛，所以另外两种仍然要进行学习。\nFloyd 算法思想：动态规划下面为 Floyd 算法的原理，不看背代码也可以。\n\n动态规划：求图上两点 i、j 之间的最短距离，按“从小图到全图”的步骤，在逐步扩大图的过程中计算和更新最短路。\n定义状态：dp[k][i][j]，i、j、k是点的编号，范围 1 ~ n。状态dp[k][i][j]表示在包含 1 ~ k 点的子图上，点对 i、j 之间的最短路。\n状态转移方程：从子图 1 ~ k-1 扩展到子图 1 ~ k \n\n首先是包含 1 ~ k-1 点的子图。 ：不包含 k 点子图内的点对 i、j 的最短路； ：经过 k 点的新路径的长度，即这条路径从 i 出发，先到 k，再从 k 到终点 j。 比较：不经过 k 的最短路径和经过 k 的新路径，较小者就是新的。\n所以 Floyd 的原理就是每次引入一个新的点，用它去更新其他点的最短距离。\nk 从 1 逐步扩展到 n：最后得到的是点对 i、j 之间的最短路径长度。 初值：若 i、j 是直连的，就是它们的边长；若不直连，赋值为无穷大。 i、j 是任意点对：计算结束后得到了所有点对之间的最短路。\n 用滚动数组简化： \n特点：\n\n在一次计算后求得所有结点之间的最短距离。\n代码极其简单，是最简单的最短路算法。\n效率低下，计算复杂度是 ，只能用于  的小规模的图。\n存图用邻接矩阵 dp[][] 。因为 Floyd 算法计算的结果是所有点对之间的最短路，本身就需要 n^2 的空间，用矩阵存储最合适。\n能判断负圈。 负圈：若图中有权值为负的边，某个经过这个负边的环路，所有边长相加的总长度也是负数，这就是负圈。在这个负圈上每绕一圈，总长度就更小，从而陷入在负圈上兜圈子的死循环。 Floyd 算法很容易判断负圈，只要在算法运行过程出现任意一个 dp[i][i] &lt; 0 就说明有负圈。因为 dp[i][i] 是从 i 出发，经过其他中转点绕一圈回到自己的最短路径，如果小于零，就存在负圈。\n\nDijkstra 算法\nDijkstra：单源最短路径问题。\n优点：非常高效而且稳定。\n缺点：只能处理不含有负权边的图。\n思路：贪心思想+优先队列。\n\n算法思想Dijkstra 算法算是贪心思想实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。\n为什么是每次都是找最小的？\n因为最小边的不会被其它的点松弛，只有可能最小边去松弛别人。 如果存在一个点  能够松弛  的话那么一定有  距离加上  的距离小于 ，已知  最短，所以不存在 。\nDijkstra 算法应用了贪心法的思想，即“抄近路走，肯定能找到最短路径”。\n算法高效稳定：\n\nDijkstra 的每次迭代，只需要检查上次已经确定最短路径的那些结点的邻居，检查范围很小，算法是高效的；\n每次迭代，都能得到至少一个结点的最短路径，算法是稳定的\n\n优先队列实现：\n\n每次往队列中放新数据时，按从小到大的顺序放，采用小顶堆的方式，复杂度是 ，保证最小的数总在最前面；\n找最小值，直接取 B 的第一个数，复杂度是 。\n复杂度：用优先队列时，Dijkstra 算法的复杂度是 ，是最高效的最短路算法。\n\n维护两个集合：已确定最短路径的结点集合 A、这些结点向外扩散的邻居结点集合 B。\n\n把起点 s 放到 A 中，把 s 所有的邻居放到 B 中。此时，邻居到 s 的距离就是直连距离。\n从 B 中找出距离起点 s 最短的结点 u，放到 A 中。\n把 u 所有的新邻居放到 B 中。显然，u 的每一条边都连接了一个邻居，每个新邻居都要加进去。其中 u 的一个新邻居 v，它到 s 的距离 dis(s, v) 等于 dis(s, u) + dis(u, v)。\n重复(2)、(3)，直到 B 为空时，结束。\n\nDijkstra 的局限性是边的权值不能为负数：\nDijkstra 基于 BFS，计算过程是从起点 s 逐步往外扩散的过程，每扩散一次就用贪心得到到一个点的最短路。 扩散要求路径越来越长，如果遇到一个负权边，会导致路径变短，使扩散失效。\nDijkstra 模板如下：\n\nC++\n\n#include&lt;bits/stdc++.h&gt;using namespace std;const long long INF = 0x3f3f3f3f3f3f3f3fLL;//这样定义INF的好处是: INF &lt;= INF+xconst int N= 3e5+2;struct edge{    int from, to; long long w; //起点，终点，权值。起点from并没有用到，e[i]的i就是from    edge(int a, int b,long long c){from=a; to=b; w=c;}};vector&lt;edge&gt;e[N];          //用于存储图struct s_node{    int id; long long n_dis;   //id：结点；n_dis：这个结点到起点的距离    s_node(int b,long long c){id=b; n_dis=c;}    bool operator &lt; (const s_node &amp; a) const    { return n_dis &gt; a.n_dis;}};int n,m;int pre[N];                                //记录前驱结点，用于生成路径void print_path(int s, int t) {            //打印从s到t的最短路    if(s==t){ printf(\"%d \", s); return; }  //打印起点    print_path(s, pre[t]);                 //先打印前一个点    printf(\"%d \", t);                      //后打印当前点。最后打印的是终点t}long long  dis[N];         //记录所有结点到起点的距离void dijkstra(){    int s = 1;             //起点s是1    bool done[N]; //done[i]=true表示到结点i的最短路径已经找到    for (int i=1;i&lt;=n;i++) {dis[i]=INF; done[i]=false; }    //初始化    dis[s]=0;                           //起点到自己的距离是0    priority_queue &lt;s_node&gt; Q;          //优先队列，存结点信息    Q.push(s_node(s, dis[s]));          //起点进队列    while (!Q.empty())   {        s_node u = Q.top();             //pop出距起点s距离最小的结点u        Q.pop();        if(done[u.id])  continue;       //丢弃已经找到最短路径的结点。即集合A中的结点                    done[u.id]= true;        for (int i=0; i&lt;e[u.id].size(); i++) {  //检查结点u的所有邻居            edge y = e[u.id][i];         //u.id的第i个邻居是y.to            if(done[y.to])  continue;    //丢弃已经找到最短路径的邻居结点                            if (dis[y.to] &gt; y.w + u.n_dis) {                dis[y.to] = y.w + u.n_dis;                Q.push(s_node(y.to, dis[y.to]));  //扩展新的邻居，放到优先队列中                pre[y.to]=u.id;  //如果有需要，记录路径            }        }    }    // print_path(s,n);          //如果有需要，打印路径: 起点1，终点n}int main(){    scanf(\"%d%d\",&amp;n,&amp;m);    for (int i=1;i&lt;=n;i++)    e[i].clear();    while (m--) {        int u,v,w;  scanf(\"%d%d%lld\",&amp;u,&amp;v,&amp;w);        e[u].push_back(edge(u,v,w));     // e[v].push_back(edge(v,u,w));    //本题是单向道路    }    dijkstra();    for(int i=1;i&lt;=n;i++){        if(dis[i]&gt;=INF)  cout&lt;&lt;\"-1 \";        else   printf(\"%lld \", dis[i]);    }}\n\n\nJava\n\nimport java.util.*;import java.io.*;public class Main {    static final long INF = 0x3f3f3f3f3f3f3f3fL;    static final int N = 300005;    static ArrayList&lt;Edge&gt;[] e = new ArrayList[N];    static int n, m;    static int[] pre = new int[N];    static long[] dis = new long[N];    static boolean[] done = new boolean[N];    static class Edge {        int from, to;        long w;        Edge(int a, int b, long c) {            from = a;            to = b;            w = c;        }    }    static class SNode implements Comparable&lt;SNode&gt; {        int id;        long n_dis;        SNode(int b, long c) {            id = b;            n_dis = c;        }        public int compareTo(SNode o) {            return Long.compare(n_dis, o.n_dis);        }    }    static void printPath(int s, int t) {        if (s == t) {            System.out.print(s + \" \");            return;        }        printPath(s, pre[t]);        System.out.print(t + \" \");    }    static void dijkstra() {        int s = 1;        PriorityQueue&lt;SNode&gt; Q = new PriorityQueue&lt;&gt;();        Arrays.fill(dis, INF);        dis[s] = 0;        Q.offer(new SNode(s, dis[s]));        while (!Q.isEmpty()) {            SNode u = Q.poll();            if (done[u.id])                continue;            done[u.id] = true;            for (Edge y : e[u.id]) {                if (done[y.to])                    continue;                if (dis[y.to] &gt; y.w + u.n_dis) {                    dis[y.to] = y.w + u.n_dis;                    Q.offer(new SNode(y.to, dis[y.to]));                    pre[y.to] = u.id;                }            }        }        // printPath(s, n);    }    public static void main(String[] args) throws Exception {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        StringTokenizer st = new StringTokenizer(br.readLine());        n = Integer.parseInt(st.nextToken());        m = Integer.parseInt(st.nextToken());        for (int i = 1; i &lt;= n; i++)            e[i] = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= m; i++) {            st = new StringTokenizer(br.readLine());            int u = Integer.parseInt(st.nextToken());            int v = Integer.parseInt(st.nextToken());            long w = Long.parseLong(st.nextToken());            e[u].add(new Edge(u, v, w));            // e[v].add(new Edge(v, u, w)); //本题是单向道路        }        dijkstra();        for (int i = 1; i &lt;= n; i++) {            if (dis[i] &gt;= INF)                System.out.print(\"-1 \");            else                System.out.print(dis[i] + \" \");        }    }}\n\n\nPython\n\nimport heapqINF = 0x3f3f3f3f3f3f3f3fN = 300002class Edge:    def __init__(self, fr, to, w):        self.fr = fr        self.to = to        self.w = wclass SNode:    def __init__(self, id, n_dis):        self.id = id        self.n_dis = n_dis    def __lt__(self, other):        return self.n_dis &lt; other.n_disdef print_path(s, t):    if s == t:        print(s, end=\" \")        return    print_path(s, pre[t])    print(t, end=\" \")def dijkstra():    s = 1    done = [False] * N    dis = [INF] * N    pre = [-1] * N    dis[s] = 0    pq = []    heapq.heappush(pq, SNode(s, dis[s]))    while pq:        u = heapq.heappop(pq)        if done[u.id]:            continue        done[u.id] = True        for y in e[u.id]:            if done[y.to]:                continue            if dis[y.to] &gt; y.w + u.n_dis:                dis[y.to] = y.w + u.n_dis                heapq.heappush(pq, SNode(y.to, dis[y.to]))                pre[y.to] = u.id    for i in range(1, n+1):        if dis[i] &gt;= INF:            print(\"-1\", end=\" \")        else:            print(dis[i], end=\" \")n, m = map(int, input().split())e = [[] for _ in range(N)]for i in range(m):    u, v, w = map(int, input().split())    e[u].append(Edge(u, v, w))dijkstra()\n\nBellman-Ford 算法BFS 的扩散思想，每个人都去问自己的相邻节点到 S 点的距离最近是多少。\n第一轮至少有一个点得到了到 S 的最短距离，即与 S 相邻的节点，标记为 T1\n重复以上操作，那么必然至少又有一个节点找到了与 S 的最短距离，即与 T1 相邻的节点，标记为 T2\n一共需要几轮操作？\n每一轮操作，都至少有一个新的结点得到了到 S 的最短路径。所以，最多只需要 n 轮操作，就能完成 n 个结点。在每一轮操作中，需要检查所有 m 个边，更新最短距离。\nBellman-Ford 算法的复杂度：O(nm)。\nBellman-Ford 能判断负圈：\n没有负圈时，只需要 n 轮就结束。\n如果超过 n 轮，最短路径还有变化，那么肯定有负圈。\nSPFA 算法队列优化版的 Bellman-Ford\nSPFA = 队列处理+Bellman-Ford。\nBellman-Ford 算法有很多低效或无效的操作。其核心内容，是在每一轮操作中，更新所有结点到起点 S 的最短距离。 计算和调整一个结点 U 到 S 的最短距离后，如果紧接着调整 U 的邻居结点，这些邻居肯定有新的计算结果；而如果漫无目的地计算不与 U 相邻的结点，很可能毫无变化，所以这些操作是低效的。\n改进： 计算结点 U 之后，下一步只计算和调整它的邻居，能加快收敛的过程。 这些步骤用队列进行操作，这就是 SPFA。\n（1）起点 S 入队，计算它所有邻居到 S 的最短距离。把 S 出队，状态有更新的邻居入队，没更新的不入队。 （2）现在队列的头部是 S 的一个邻居 U。弹出 U，更新它所有邻居的状态，把其中有状态变化的邻居入队列。 （3）继续以上过程，直到队列空。这也意味着，所有结点的状态都不再更新。最后的状态就是到起点 S 的最短路径。\n弹出 U 之后，在后面的计算中，U 可能会再次更新状态（后来发现，U 借道别的结点去 S，路更近）。所以，U 可能需要重新入队列。 有可能只有很少结点重新进入队列，也有可能很多。这取决于图的特征。\n所以，SPFA 是不稳定的,所以根据题目的类型，我们要选择合适的算法。\nSPFA 模板如下：\n\nC++\n\n#include&lt;bits/stdc++.h&gt;using namespace std;const long long INF = 0x3f3f3f3f3f3f3f3f;const int N = 5e3+10;struct edge{    int to;    long long w;    edge(int tt,long long ww) {to = tt; w = ww;}};long long dist[N];int inq[N];vector&lt;edge&gt; e[N];void spfa(int s){    memset(dist,0x3f,sizeof(dist));    dist[s] = 0;      //起点到自己的距离是0    queue&lt;int&gt; q;    q.push(s);        //从s开始，s进队列    inq[s] = 1;       //起点在队列中    while(!q.empty()) {        int u = q.front();        q.pop();        inq[u] = 0;   //u已经不在队列中        if(dist[u] == INF)     continue;        for(int i = 0;i &lt; e[u].size();i++) {   //遍历u的邻居            int v = e[u][i].to;            long long w = e[u][i].w;            if(dist[v] &gt; dist[u]+w) {         //u的第i个邻居v，它借道u，到s更近                dist[v] = dist[u]+w;          //更新邻居v到s的距离                if(!inq[v]) {      //邻居v更新状态了，但v不在队列中，放进队列                    q.push(v);                    inq[v] = 1;                }            }        }    }}int main(){    int n,m,s;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;    for(int i = 1;i &lt;= m;i++)    {        int u,v; long long w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        e[u].push_back(edge(v,w));    }    spfa(s);    for(int i = 1;i &lt;= n;i++) {        if(dist[i]==INF)  cout &lt;&lt; -1;        else              cout &lt;&lt; dist[i];        if(i != n)        cout &lt;&lt; \" \";        else              cout &lt;&lt; endl;    }    return 0;}\n\n\nJava\n\nimport java.util.*;public class Main {    static final long INF = 0x3f3f3f3f3f3f3f3fL;    static final int N = 5010;    static long[] dist = new long[N];    static int[] inq = new int[N];    static List&lt;edge&gt;[] e = new ArrayList[N];    static class edge {        int to;        long w;        public edge(int tt, long ww) {            to = tt;            w = ww;        }    }    static void spfa(int s) {        Arrays.fill(dist, INF);        dist[s] = 0;        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();        q.add(s);        inq[s] = 1;        while (!q.isEmpty()) {            int u = q.poll();            inq[u] = 0;            if (dist[u] == INF) continue;            for (int i = 0; i &lt; e[u].size(); i++) {                int v = e[u].get(i).to;                long w = e[u].get(i).w;                if (dist[v] &gt; dist[u] + w) {                    dist[v] = dist[u] + w;                    if (inq[v] == 0) {                        q.add(v);                        inq[v] = 1;                    }                }            }        }    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        int n = in.nextInt();        int m = in.nextInt();        int s = in.nextInt();        for (int i = 1; i &lt;= n; i++) {            e[i] = new ArrayList&lt;&gt;();        }        for (int i = 1; i &lt;= m; i++) {            int u = in.nextInt();            int v = in.nextInt();            long w = in.nextLong();            e[u].add(new edge(v, w));        }        spfa(s);        for (int i = 1; i &lt;= n; i++) {            if (dist[i] == INF) System.out.print(\"-1 \");            else System.out.print(dist[i] + \" \");        }    }}\n\n\nPython\n\nimport heapqINF = 0x3f3f3f3f3f3f3f3fN = 5010class Edge:    def __init__(self, to, w):        self.to = to        self.w = wdist = [INF] * Ninq = [0] * Ne = [[] for _ in range(N)]def spfa(s):    global dist    global inq    dist = [INF] * N    dist[s] = 0    q = []    heapq.heappush(q, s)    inq[s] = 1    while q:        u = heapq.heappop(q)        inq[u] = 0        if dist[u] == INF:            continue        for i in range(len(e[u])):            v = e[u][i].to            w = e[u][i].w            if dist[v] &gt; dist[u] + w:                dist[v] = dist[u] + w                if inq[v] == 0:                    heapq.heappush(q, v)                    inq[v] = 1n, m, s = map(int, input().split())for i in range(m):    u, v, w = map(int, input().split())    e[u].append(Edge(v, w))spfa(s)for i in range(1, n+1):    if dist[i] == INF:        print(\"-1\", end=\" \")    else:        print(dist[i], end=\" \")\n\n总结Dijkstra：适用于权值为非负的图的单源最短路径，用斐波那契堆的复杂度 O(E+VlgV) BellmanFord：适用于权值有负值的图的单源最短路径，并且能够检测负圈，复杂度 O(VE) SPFA：适用于权值有负值，且没有负圈的图的单源最短路径。论文中的复杂度为 O(kE), 其中 k 为每个节点进入队列的次数，且 k 一般 &lt;=2，但此处的复杂度证明是有问题的，其实 SPFA 的最坏情况应该是 O(VE)。 Floyd：每对节点之间的最短路径。\n所以：\n单源最短路 (1)当权值为非负时，用 Dijkstra。 (2)当权值有负值，且没有负圈，则用 SPFA。SPFA 能检测负圈，但是不能输出负圈。 (3)当权值有负值，而且可能存在负圈需要输出，则用 BellmanFord。能够检测并输出负圈。 多源最短路使用 Floyd\n最小生成树在无向图中，连通而且不含有圈（环路）的图，称为树。 最小生成树 MST：一个有 n 个结点的连通图的生成树是原图的极小连通子图，包含原图中的所有 n 个结点，并且边的权值之和最小。\nPrim 算法对点进行贪心操作：“最近的邻居一定在 MST 上”。 从任意一个点 u 开始，把距离它最近的点 v 加入到 MST 中；下一步，把距离 {u, v} 最近的点 w 加入到 MST 中；继续这个过程，直到所有点都在 MST 中。\n\nC++\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1005;vector&lt;int&gt; demo;int closest[MAXN],lowcost[MAXN],m,n;//m为节点的个数，n为边的数量int G[MAXN][MAXN];//邻接矩阵int prim(){    for(int i=0;i&lt;m;i++)    {        lowcost[i] = INF;    }    for(int i=0;i&lt;m;i++)    {        closest[i] = 0;    }    closest[0] = -1;//加入第一个点，-1表示该点在集合U中，否则在集合V中    int num = 0,ans = 0,e = 0;//e为最新加入集合的点    while (num &lt; m-1)//加入m-1条边    {        int micost = INF,miedge = -1;        for(int i=0;i&lt;m;i++)        if(closest[i] != -1)        {            int temp = G[e][i];            if(temp &lt; lowcost[i])            {                lowcost[i] = temp;                closest[i] = e;            }            if(lowcost[i] &lt; micost)            micost = lowcost[miedge=i];        }        ans += micost;        demo.push_back(micost);        closest[e = miedge] = -1;        num++;    }    return ans;}int main(){    scanf(\"%d %d\", &amp;m, &amp;n);    memset(G,INF,sizeof(G));    for(int i = 0; i &lt; n; ++i)    {       int a,b,c;       cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;       G[b][a]=G[a][b]=c;    }    cout&lt;&lt;prim()&lt;&lt;endl;    for(int i=0;i&lt;m-1;i++) cout&lt;&lt;demo[i]&lt;&lt;\" \";    return 0;}\n\n\nJava\n\nimport java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main {    private static final int INF = 0x3f3f3f3f;    private static final int MAXN = 1005;    private static int[] closest = new int[MAXN];    private static int[] lowcost = new int[MAXN];    private static int[][] G = new int[MAXN][MAXN];    private static int m;    private static List demo = new ArrayList();    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        m = scanner.nextInt();        int n = scanner.nextInt();        for (int i = 0; i &lt; n; ++i) {            int a = scanner.nextInt();            int b = scanner.nextInt();            int c = scanner.nextInt();            G[b][a] = G[a][b] = c;        }        System.out.println(prim());        for (int i = 0; i &lt; m - 1; i++) {            System.out.print(demo.get(i) + \" \");        }    }    private static int prim() {        for (int i = 0; i &lt; m; i++) {            lowcost[i] = INF;            closest[i] = 0;        }        closest[0] = -1;//加入第一个点，-1表示该点在集合U中，否则在集合V中        int num = 0, ans = 0, e = 0;//e为最新加入集合的点        while (num &lt; m - 1)//加入m-1条边        {            int micost = INF, miedge = -1;            for (int i = 0; i &lt; m; i++) {                if (closest[i] != -1) {                    int temp = G[e][i];                    if (temp &lt; lowcost[i]) {                        lowcost[i] = temp;                        closest[i] = e;                    }                    if (lowcost[i] &lt; micost) {                        micost = lowcost[miedge = i];                    }                }            }            ans += micost;            demo.add(micost);            closest[e = miedge] = -1;            num++;        }        return ans;    }}\n\n\nPython\n\nINF = 0x3f3f3f3fMAXN = 1005closest = [0] * MAXNlowcost = [0] * MAXNG = [[INF] * MAXN for _ in range(MAXN)]demo = []m,n = map(int, input().split())for i in range(n):    a,b,c = map(int, input().split())    G[b][a]=G[a][b]=cdef prim():    global closest, lowcost, G, m    for i in range(m):        lowcost[i] = INF        closest[i] = 0    closest[0] = -1    num = 0    ans = 0    e = 0    while num &lt; m-1:        micost = INF        miedge = -1        for i in range(m):            if closest[i] != -1:                temp = G[e][i]                if temp &lt; lowcost[i]:                    lowcost[i] = temp                    closest[i] = e                if lowcost[i] &lt; micost:                    miedge=i                    micost = lowcost[miedge]        ans += micost        demo.append(micost)        e = miedge        closest[e] = -1        num += 1    return ansprint(prim())for i in range(m - 1): print(demo[i], end=' ')\n\nkruskal 算法对边进行贪心操作：“最短的边一定在 MST 上”。 从最短的边开始，把它加入到 MST 中；在剩下的边中找最短的边，加入到 MST 中；继续这个过程，直到所有点都在 MST 中。\nkruskal 算法的 2 个关键技术： （1）对边进行排序。 （2）判断圈，即处理连通性问题。这个问题用并查集简单而高效，并查集是 kruskal 算法的实现基础。\n初始时最小生成树 MST 为空。开始的时候，每个点属于独立的集。\n按边长从小到大进行边的遍历操作：\n尝试将最小边加入最小生成树：\n\n如果边的两个端点属于同一个集合，就说明这两个点已经被加入最小生成树。则不能将边加入，否则就会生成一个环。\n如果两个端点不属于同一个集合，就说明该点还未纳入最小生成树，此边可以加入。\n\n重复上述操作，直到加入 n-1 条边。\nkruskal 算法的复杂度包括两部分：对边的排序 O(ElogE)，并查集的操作 O(E)，一共是 O(ElogE + E)，约等于 O(ElogE)，时间主要花在排序上。\n如果图的边很多，kruskal 的复杂度要差一些。kruskal 适用于稀疏图，prim 适合稠密图。\n模板如下：\n\nC++\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;int father[1100000];struct node{    int x;    int y;    int k;} Q[1100000];int find(int x){    if (father[x] == x)        return x;    return father[x] = find(father[x]);}bool cmp(node a, node b){    return a.k &lt; b.k;}int main(){    scanf(\"%d %d\", &amp;n, &amp;m);    int cont = 0,        sum = 0, st = 0;    for (int i = 0; i &lt; m; i++)    {        scanf(\"%d %d %d\", &amp;Q[i].x, &amp;Q[i].y, &amp;Q[i].k);        cont += Q[i].k;    }    sort(Q, Q + m, cmp);    for (int i = 1; i &lt;= n; i++)        father[i] = i;    for (int i = 0; i &lt; m; i++)    {        int tx = find(Q[i].x);        int ty = find(Q[i].y);        if (tx != ty)        {            sum += Q[i].k;            st++;            father[tx] = ty;            if (st == n - 1)                break;        }    }    printf(\"%d\\n\", sum);    return 0;}\n\n\nJava\n\nimport java.util.Arrays;import java.util.Scanner;public class Main {    static int n, m;    static int[] father;    static Node[] Q;    static class Node {        int x;        int y;        int k;        public Node(int x, int y, int k) {            this.x = x;            this.y = y;            this.k = k;        }    }    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        n = scanner.nextInt();        m = scanner.nextInt();        father = new int[n + 1];        Q = new Node[m];        int cont = 0, sum = 0, st = 0;        for (int i = 0; i &lt; m; i++) {            int x = scanner.nextInt();            int y = scanner.nextInt();            int k = scanner.nextInt();            Q[i] = new Node(x, y, k);            cont += k;        }        Arrays.sort(Q, (a, b) -&gt; a.k - b.k);        for (int i = 1; i &lt;= n; i++)            father[i] = i;        for (int i = 0; i &lt; m; i++) {            int tx = find(Q[i].x);            int ty = find(Q[i].y);            if (tx != ty) {                sum += Q[i].k;                st++;                father[tx] = ty;                if (st == n - 1)                    break;            }        }        System.out.println(sum);    }    static int find(int x) {        if (father[x] == x)            return x;        return father[x] = find(father[x]);    }}\n\n\nPython\n\nn, m = map(int, input().split())father = [i for i in range(n+1)]Q = []cont = 0sum = 0st = 0for i in range(m):    x, y, k = map(int, input().split())    Q.append({'x': x, 'y': y, 'k': k})    cont += kQ.sort(key=lambda x:x['k'])def find(x):    if father[x] == x :        return x    father[x] = find(father[x])    return father[x]for i in range(m):    tx = find(Q[i]['x'])    ty = find(Q[i]['y'])    if tx != ty:        sum += Q[i]['k']        st += 1        father[tx] = ty        if st == n - 1:            breakprint(sum)\n\n图论例题蓝桥王国 lanqiaoOJ 题号 1122题目描述\n蓝桥王国一共有  个建筑和  条单向道路，每条道路都连接着两个建筑，每个建筑都有自己编号，分别为 。（其中皇宫的编号为 1）国王想让小明回答从皇宫到每个建筑的最短路径是多少，但紧张的小明此时已经无法思考，请你编写程序帮助小明回答国王的考核。\n输入描述\n输入第一行包含 2 个正整数 。第 2 到  行每行包含三个正整数 ，表示  之间存在一条距离为  的路。，，，。\n输出描述\n输出仅一行，共  个数，分别表示从皇宫到编号为  建筑的最短距离，两两之间用空格隔开。（如果无法到达则输出 −1）\n解题思路:\n本题为单源最短路的模板题，直接套模板即可，本题我们采用 Dijkstra。\nC++ 语言描述:\n#include&lt;bits/stdc++.h&gt;using namespace std;const long long INF = 0x3f3f3f3f3f3f3f3fLL;//这样定义INF的好处是: INF &lt;= INF+xconst int N= 3e5+2;struct edge{    int from, to; long long w; //起点，终点，权值。起点from并没有用到，e[i]的i就是from    edge(int a, int b,long long c){from=a; to=b; w=c;}};vector&lt;edge&gt;e[N];          //用于存储图struct s_node{    int id; long long n_dis;   //id：结点；n_dis：这个结点到起点的距离    s_node(int b,long long c){id=b; n_dis=c;}    bool operator &lt; (const s_node &amp; a) const    { return n_dis &gt; a.n_dis;}};int n,m;int pre[N];                                //记录前驱结点，用于生成路径void print_path(int s, int t) {            //打印从s到t的最短路    if(s==t){ printf(\"%d \", s); return; }  //打印起点    print_path(s, pre[t]);                 //先打印前一个点    printf(\"%d \", t);                      //后打印当前点。最后打印的是终点t}long long  dis[N];         //记录所有结点到起点的距离void dijkstra(){    int s = 1;             //起点s是1    bool done[N]; //done[i]=true表示到结点i的最短路径已经找到    for (int i=1;i&lt;=n;i++) {dis[i]=INF; done[i]=false; }    //初始化    dis[s]=0;                           //起点到自己的距离是0    priority_queue &lt;s_node&gt; Q;          //优先队列，存结点信息    Q.push(s_node(s, dis[s]));          //起点进队列    while (!Q.empty())   {        s_node u = Q.top();             //pop出距起点s距离最小的结点u        Q.pop();        if(done[u.id])  continue;       //丢弃已经找到最短路径的结点。即集合A中的结点        done[u.id]= true;        for (int i=0; i&lt;e[u.id].size(); i++) {  //检查结点u的所有邻居            edge y = e[u.id][i];         //u.id的第i个邻居是y.to            if(done[y.to])  continue;    //丢弃已经找到最短路径的邻居结点            if (dis[y.to] &gt; y.w + u.n_dis) {                dis[y.to] = y.w + u.n_dis;                Q.push(s_node(y.to, dis[y.to]));  //扩展新的邻居，放到优先队列中                pre[y.to]=u.id;  //如果有需要，记录路径            }        }    }    // print_path(s,n);          //如果有需要，打印路径: 起点1，终点n}int main(){    scanf(\"%d%d\",&amp;n,&amp;m);    for (int i=1;i&lt;=n;i++)    e[i].clear();    while (m--) {        int u,v,w;  scanf(\"%d%d%lld\",&amp;u,&amp;v,&amp;w);        e[u].push_back(edge(u,v,w));     // e[v].push_back(edge(v,u,w));    //本题是单向道路    }    dijkstra();    for(int i=1;i&lt;=n;i++){        if(dis[i]&gt;=INF)  cout&lt;&lt;\"-1 \";        else   printf(\"%lld \", dis[i]);    }}\n\nPython 语言描述:\nimport heapqINF = 0x3f3f3f3f3f3f3f3fN = 300002class Edge:    def __init__(self, fr, to, w):        self.fr = fr        self.to = to        self.w = wclass SNode:    def __init__(self, id, n_dis):        self.id = id        self.n_dis = n_dis    def __lt__(self, other):        return self.n_dis &lt; other.n_disdef print_path(s, t):    if s == t:        print(s, end=\" \")        return    print_path(s, pre[t])    print(t, end=\" \")def dijkstra():    s = 1    done = [False] * N    dis = [INF] * N    pre = [-1] * N    dis[s] = 0    pq = []    heapq.heappush(pq, SNode(s, dis[s]))    while pq:        u = heapq.heappop(pq)        if done[u.id]:            continue        done[u.id] = True        for y in e[u.id]:            if done[y.to]:                continue            if dis[y.to] &gt; y.w + u.n_dis:                dis[y.to] = y.w + u.n_dis                heapq.heappush(pq, SNode(y.to, dis[y.to]))                pre[y.to] = u.id    for i in range(1, n+1):        if dis[i] &gt;= INF:            print(\"-1\", end=\" \")        else:            print(dis[i], end=\" \")n, m = map(int, input().split())e = [[] for _ in range(N)]for i in range(m):    u, v, w = map(int, input().split())    e[u].append(Edge(u, v, w))dijkstra()\n\nJava 语言描述:\nimport java.util.*;import java.io.*;public class Main {    static final long INF = 0x3f3f3f3f3f3f3f3fL;    static final int N = 300005;    static ArrayList&lt;Edge&gt;[] e = new ArrayList[N];    static int n, m;    static int[] pre = new int[N];    static long[] dis = new long[N];    static boolean[] done = new boolean[N];    static class Edge {        int from, to;        long w;        Edge(int a, int b, long c) {            from = a;            to = b;            w = c;        }    }    static class SNode implements Comparable&lt;SNode&gt; {        int id;        long n_dis;        SNode(int b, long c) {            id = b;            n_dis = c;        }        public int compareTo(SNode o) {            return Long.compare(n_dis, o.n_dis);        }    }    static void printPath(int s, int t) {        if (s == t) {            System.out.print(s + \" \");            return;        }        printPath(s, pre[t]);        System.out.print(t + \" \");    }    static void dijkstra() {        int s = 1;        PriorityQueue&lt;SNode&gt; Q = new PriorityQueue&lt;&gt;();        Arrays.fill(dis, INF);        dis[s] = 0;        Q.offer(new SNode(s, dis[s]));        while (!Q.isEmpty()) {            SNode u = Q.poll();            if (done[u.id])                continue;            done[u.id] = true;            for (Edge y : e[u.id]) {                if (done[y.to])                    continue;                if (dis[y.to] &gt; y.w + u.n_dis) {                    dis[y.to] = y.w + u.n_dis;                    Q.offer(new SNode(y.to, dis[y.to]));                    pre[y.to] = u.id;                }            }        }        // printPath(s, n);    }    public static void main(String[] args) throws Exception {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        StringTokenizer st = new StringTokenizer(br.readLine());        n = Integer.parseInt(st.nextToken());        m = Integer.parseInt(st.nextToken());        for (int i = 1; i &lt;= n; i++)            e[i] = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= m; i++) {            st = new StringTokenizer(br.readLine());            int u = Integer.parseInt(st.nextToken());            int v = Integer.parseInt(st.nextToken());            long w = Long.parseLong(st.nextToken());            e[u].add(new Edge(u, v, w));            // e[v].add(new Edge(v, u, w)); //本题是单向道路        }        dijkstra();        for (int i = 1; i &lt;= n; i++) {            if (dis[i] &gt;= INF)                System.out.print(\"-1 \");            else                System.out.print(dis[i] + \" \");        }    }}\n\n随机数据下的最短路问题 lanqiaoOJ 题号 1366题目描述\n给定  个点和  条单向道路，每条道路都连接着两个点，每个点都有自己编号，分别为 。问你从  点出发，到达每个点的最短路径为多少。\n输入描述\n输入第一行包含三个正整数 。第 2 到  行每行包含三个正整数 ，表示  之间存在一条距离为  的路。，，，。\n输出描述\n输出仅一行，共  个数，分别表示从编号  到编号为  点的最短距离，两两之间用空格隔开。（如果无法到达则输出 −1）\n解题思路:\n本题为单源最短路的模板题，直接套模板即可，本题我们采用 SPFA。\nC++ 语言描述:\n#include&lt;bits/stdc++.h&gt;using namespace std;const long long INF = 0x3f3f3f3f3f3f3f3f;const int N = 5e3+10;struct edge{    int to;    long long w;    edge(int tt,long long ww) {to = tt; w = ww;}};long long dist[N];int inq[N];vector&lt;edge&gt; e[N];void spfa(int s){    memset(dist,0x3f,sizeof(dist));    dist[s] = 0;      //起点到自己的距离是0    queue&lt;int&gt; q;    q.push(s);        //从s开始，s进队列    inq[s] = 1;       //起点在队列中    while(!q.empty()) {        int u = q.front();        q.pop();        inq[u] = 0;   //u已经不在队列中        if(dist[u] == INF)     continue;        for(int i = 0;i &lt; e[u].size();i++) {   //遍历u的邻居            int v = e[u][i].to;            long long w = e[u][i].w;            if(dist[v] &gt; dist[u]+w) {         //u的第i个邻居v，它借道u，到s更近                dist[v] = dist[u]+w;          //更新邻居v到s的距离                if(!inq[v]) {      //邻居v更新状态了，但v不在队列中，放进队列                    q.push(v);                    inq[v] = 1;                }            }        }    }}int main(){    int n,m,s;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;    for(int i = 1;i &lt;= m;i++)    {        int u,v; long long w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        e[u].push_back(edge(v,w));    }    spfa(s);    for(int i = 1;i &lt;= n;i++) {        if(dist[i]==INF)  cout &lt;&lt; -1;        else              cout &lt;&lt; dist[i];        if(i != n)        cout &lt;&lt; \" \";        else              cout &lt;&lt; endl;    }    return 0;}\n\nPython 语言描述:\nimport heapqINF = 0x3f3f3f3f3f3f3f3fN = 5010class Edge:    def __init__(self, to, w):        self.to = to        self.w = wdist = [INF] * Ninq = [0] * Ne = [[] for _ in range(N)]def spfa(s):    global dist    global inq    dist = [INF] * N    dist[s] = 0    q = []    heapq.heappush(q, s)    inq[s] = 1    while q:        u = heapq.heappop(q)        inq[u] = 0        if dist[u] == INF:            continue        for i in range(len(e[u])):            v = e[u][i].to            w = e[u][i].w            if dist[v] &gt; dist[u] + w:                dist[v] = dist[u] + w                if inq[v] == 0:                    heapq.heappush(q, v)                    inq[v] = 1n, m, s = map(int, input().split())for i in range(m):    u, v, w = map(int, input().split())    e[u].append(Edge(v, w))spfa(s)for i in range(1, n+1):    if dist[i] == INF:        print(\"-1\", end=\" \")    else:        print(dist[i], end=\" \")\n\nJava 语言描述:\nimport java.util.*;public class Main {    static final long INF = 0x3f3f3f3f3f3f3f3fL;    static final int N = 5010;    static long[] dist = new long[N];    static int[] inq = new int[N];    static List&lt;edge&gt;[] e = new ArrayList[N];    static class edge {        int to;        long w;        public edge(int tt, long ww) {            to = tt;            w = ww;        }    }    static void spfa(int s) {        Arrays.fill(dist, INF);        dist[s] = 0;        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();        q.add(s);        inq[s] = 1;        while (!q.isEmpty()) {            int u = q.poll();            inq[u] = 0;            if (dist[u] == INF) continue;            for (int i = 0; i &lt; e[u].size(); i++) {                int v = e[u].get(i).to;                long w = e[u].get(i).w;                if (dist[v] &gt; dist[u] + w) {                    dist[v] = dist[u] + w;                    if (inq[v] == 0) {                        q.add(v);                        inq[v] = 1;                    }                }            }        }    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        int n = in.nextInt();        int m = in.nextInt();        int s = in.nextInt();        for (int i = 1; i &lt;= n; i++) {            e[i] = new ArrayList&lt;&gt;();        }        for (int i = 1; i &lt;= m; i++) {            int u = in.nextInt();            int v = in.nextInt();            long w = in.nextLong();            e[u].add(new edge(v, w));        }        spfa(s);        for (int i = 1; i &lt;= n; i++) {            if (dist[i] == INF) System.out.print(\"-1 \");            else System.out.print(dist[i] + \" \");        }    }}\n\n路径 OJ 编号 1460\n解题思路:\n填空题对时间没有要求，用最简单的 floyd\nC++ 语言描述:\n#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N = 3000;const ll INF = 1e18;ll mp[N][N];void floyd(int n){    for(int k = 1;k &lt;= n;k++)        for(int i = 1;i &lt;= n;i++)            for(int j = 1;j &lt;= n;j++)                mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);}int main(){    int n = 2021;    for(int i = 1;i &lt;= n;i++){        for(int j = 1;j &lt;= n;j++){            if(i == j) mp[i][j] = 0;            else if(abs(i - j)&lt;=21) mp[i][j]=mp[j][i]=i*j/__gcd(i, j);            else mp[i][j] = mp[j][i] = INF;        }    }    floyd(n);    cout &lt;&lt; mp[1][2021];    return 0;}\n\nPython 语言描述:\nimport mathdef lcm(a, b):    return int(a * b / math.gcd(a, b))n = 2021g = [[0 for i in range(1, n + 2)] for j in range(1, n + 2)]for i in range(1, n + 1):    for j in range(1, n + 1):        if i == j:            g[i][j] = g[j][i] = 0        elif abs(i - j) &lt;= 21:            g[i][j] = g[j][i] = lcm(i, j)        else:            g[i][j] = 1000000000for k in range(1, n + 1):    for i in range(1, n + 1):        for j in range(1, n + 1):            if g[i][j] &gt; g[i][k] + g[k][j]:                g[i][j] = g[i][k] + g[k][j]print(g[1][n])\n\nJava 语言描述:\npublic class Main {    static final int n = 2021;    static int gcd(int a, int b) {        return b == 0 ? a : gcd(b, a % b);    }    static int lcm(int a, int b) {        return a * b / gcd(a, b);    }    public static void main(String[] args) {        int[][] floyd = new int[n][n];        for (int i = 0; i &lt; n; i++)            for (int j = i + 1; j &lt; n &amp;&amp; j &lt; i + 22; j++)                floyd[i][j] = floyd[j][i] = lcm(i + 1, j + 1);        for (int k = 0; k &lt; n; k++)            for (int i = 0; i &lt; n; i++)                for (int j = 0; j &lt; n; j++)                    if (floyd[i][k] != 0 &amp;&amp; floyd[k][j] != 0 &amp;&amp; (floyd[i][j] == 0 || floyd[i][k] + floyd[k][j] &lt; floyd[i][j]))                        floyd[i][j] = floyd[i][k] + floyd[k][j];        System.out.println(floyd[0][n - 1]);    }}\n\n出差\n解题思路:\n\n我们这里给大家一个朴素的 dijkstra 的模板，大家感受一下，优先队列到底优化的那一部分。\nC++ 语言描述:\n#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1010;//邻接矩阵int gra[N][N];int dist[N];int g[N];bool st[N];int n,m;//朴素版dijkstraint dijkstra(){     memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 0; i &lt; n - 1; i ++ )    {        int t = -1;        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        for (int j = 1; j &lt;= n; j ++ )            dist[j] = min(dist[j], dist[t] + gra[t][j]);        st[t] = true;    }    return dist[n];}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;++i) cin&gt;&gt;g[i];    g[n]=0;    memset(gra, 0x3f, sizeof gra);    for(int i=1;i&lt;=m;++i){        int u,v,c;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;c;        gra[u][v]=g[v]+c;        gra[v][u]=g[u]+c;    }    cout&lt;&lt;dijkstra()&lt;&lt;endl;    return 0;}\n\nPython 语言描述:\nimport sysfrom typing import Listn, m = map(int, input().split())# 邻接矩阵gra = [[float('inf')] * (n+1) for _ in range(n+1)]dist = [float('inf')] * (n+1)g = [0] + list(map(int, input().split()))g[n] = 0st = [False] * (n+1)# 朴素版 Dijkstradef dijkstra() -&gt; int:    dist[1] = 0    for _ in range(n - 1):        t = -1        for j in range(1, n + 1):            if not st[j] and (t == -1 or dist[t] &gt; dist[j]):                t = j        for j in range(1, n + 1):            dist[j] = min(dist[j], dist[t] + gra[t][j])        st[t] = True    return dist[n]for _ in range(m):    u, v, c = map(int, input().split())    gra[u][v] = g[v] + c    gra[v][u] = g[u] + cprint(dijkstra())\n\nJava 语言描述:\nimport java.util.*;public class Main {    static int N = 1010;    static int[][] gra = new int[N][N];    static int[] dist = new int[N];    static int[] g = new int[N];    static boolean[] st = new boolean[N];    static int n, m;    public static void main(String[] args) {        Scanner scan = new Scanner(System.in);        n = scan.nextInt();        m = scan.nextInt();        for(int i = 1; i &lt;= n; ++i) {            g[i] = scan.nextInt();        }        g[n] = 0;        for(int i = 0 ; i &lt; N ; i ++) Arrays.fill(gra[i], 0x3f3f3f);        for(int i = 1; i &lt;= m; ++i) {            int u = scan.nextInt(), v = scan.nextInt(), c = scan.nextInt();            gra[u][v] = g[v] + c;            gra[v][u] = g[u] + c;        }        System.out.println(dijkstra());    }    private static int dijkstra() {        Arrays.fill(dist, 10000000);        dist[1] = 0;        for(int i = 0; i &lt; n - 1; i++) {            int t = -1;            for(int j = 1; j &lt;= n; j++) {                if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) {                    t = j;                }            }            if(t == -1) break;            for(int j = 1; j &lt;= n; j++) {                dist[j] = Math.min(dist[j], dist[t] + gra[t][j]);            }            st[t] = true;        }        return dist[n];    }}\n\n聪明的猴子\n\n解题思路:\n\nC++ 语言描述:\n#include &lt;bits/stdc++.h&gt;using namespace std;int a[5005], x[5005], y[5005], f[5005];struct Edge{    int x;    int y;    double w;}edge[1000005];int find(int x){    if (x == f[x])        return x;    f[x] = find(f[x]);    return f[x];}int cmp(Edge a, Edge b){    return a.w &lt; b.w;}void merge(int x, int y){    int xx = find(x);    int yy = find(y);    if (xx != yy)        f[yy] = xx;}int main(){    int cnt = 0;    int n, m;    cin &gt;&gt; m;    for (int i = 1; i &lt;= m; i++)        cin &gt;&gt; a[i];    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; x[i] &gt;&gt; y[i];    for (int i = 1; i &lt;= n; i++)        f[i] = i;    for (int i = 1; i &lt;= n; i++){        for (int j = i + 1; j &lt;= n; j++){            double w = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));            edge[++cnt] = {i, j, w};        }    }    sort(edge + 1, edge + cnt + 1, cmp);    int num = 0;    double max = 0.0;    for (int i = 1; i &lt;= cnt; i++){        if (find(edge[i].x)!=find(edge[i].y)){            merge(edge[i].x, edge[i].y);            num++;            max = max&gt;=edge[i].w?max:edge[i].w;        }        if (num == n - 1)            break;    }    int ans = 0;    for (int i = 1; i &lt;= m; i++)        if (a[i] &gt;= max)            ans++;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}\n\nPython 语言描述:\nimport mathclass Edge:    x = 0    y = 0    w = 0.0    def __init__(self, x, y, w):        self.x = x        self.y = y        self.w = wdef find(x):    if f[x]==x:        return f[x]    else:        f[x] = find(f[x])        return f[x]def merge(x,y):    xx = find(x)    yy = find(y)    if xx!=yy:        f[yy] = xxif __name__ == '__main__':    m = int(input())    a = list(map(int, input().split()))    n = int(input())    x = [0 for i in range(n + 2)]    y = [0 for i in range(n + 2)]    for i in range(n):        b = list(map(int, input().split()))        x[i + 1] = b[0]        y[i + 1] = b[1]    edge_list = []    maxvalue = 0    num = 0    for i in range(1, n + 1):        for j in range(i + 1, n + 1):            w = math.sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]))            edge =  Edge(i, j, w)            edge_list.append(edge)    edge_list.sort(key=lambda x: x.w)    f = [i for i in range(n + 1)]    for i in edge_list:        if find(i.x)!=find(i.y):            merge(i.x,i.y)            maxvalue = max(maxvalue,i.w)            num+=1            if num==n-1:                break    ans = 0    for i in range(m):        if a[i]&gt;=maxvalue:            ans+=1    print(ans)\n\nJava 语言描述:\nimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.util.ArrayList;import java.util.Collections;public class Main {    static int ans = 0;    static int n;    static int[] a;    static int m;    static int[] x;    static int[] y;    static double max;    static int[] f;    static int num = 0;    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));    public static void main(String[] args) throws IOException{        m = Integer.parseInt(in.readLine().trim());        a = new int[m];        String[] s = in.readLine().trim().split(\" \");        for(int i=0;i&lt;m;i++)            a[i] = Integer.parseInt(s[i]);        n = Integer.parseInt(in.readLine().trim());        x = new int[n];        y = new int[n];        for(int i=0;i&lt;n;i++) {            s = in.readLine().trim().split(\" \");            x[i] = Integer.parseInt(s[0]);            y[i] = Integer.parseInt(s[1]);        }        ArrayList&lt;Edge&gt; list = new ArrayList&lt;&gt;();        for(int i=0;i&lt;n-1;i++) {            for(int j=i+1;j&lt;n;j++) {                double l = Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));                Edge edge = new Edge(i, j, l);                list.add(edge);            }        }        Collections.sort(list);        f = new int[n];        for(int i=0;i&lt;n;i++)            f[i] = i;        for(int i=0;i&lt;list.size();i++) {            Edge e = list.get(i);            if(find(e.x)!=find(e.y)) {                merge(e.x,e.y);                max = Math.max(max, e.w);                num++;                if(num==n-1)                    break;            }        }        for(int i=0;i&lt;m;i++)            if(a[i]&gt;=max)                ans++;        System.out.println(ans);    }    static int find(int x) {        if(f[x] == x)            return f[x];        f[x] = find(f[x]);        return f[x];    }    static void merge(int x,int y) {        int xx = find(x);        int yy = find(y);        if(xx!=yy)            f[yy] = xx;    }}class Edge implements Comparable&lt;Edge&gt;{    int x;    int y;    double w;    public Edge(int x, int y, double w) {        super();        this.x = x;        this.y = y;        this.w = w;    }    @Override    public int compareTo(Edge o) {        // TODO Auto-generated method stub        return this.w&gt;o.w?1:-1;    }}\n\n通电\n解题思路:\n给了你 n 个节点，又给了你 n 个基点之间相互连接需要多少钱，现在要 n 个村庄都通电，只需要保证 n 个节点构成连通子图即可。\n最小的连通子图是树，也就是构造一棵树，那么在图上构造一棵最最少花费的树的问题即为最小生成树。\nC++ 语言描述:\n#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1005;vector&lt;int&gt; demo;double closest[MAXN], lowcost[MAXN];int m, n;             // m为节点的个数，n为边的数量double G[MAXN][MAXN]; // 邻接矩阵double prim(){    for (int i = 0; i &lt; m; i++)    {        lowcost[i] = INF;    }    for (int i = 0; i &lt; m; i++)    {        closest[i] = 0;    }    closest[0] = -1;             // 加入第一个点，-1表示该点在集合U中，否则在集合V中    int num = 0,  e = 0; // e为最新加入集合的点    double ans=0;    while (num &lt; m - 1)          // 加入m-1条边    {        int miedge = -1;        double micost = INF;        for (int i = 0; i &lt; m; i++)            if (closest[i] != -1)            {                double temp = G[e][i];                if (temp &lt; lowcost[i])                {                    lowcost[i] = temp;                    closest[i] = e;                }                if (lowcost[i] &lt; micost)                    micost = lowcost[miedge = i];            }        ans += micost;        demo.push_back(micost);        closest[e = miedge] = -1;        num++;    }    return ans;}struct node{    double x, y, h;} dis[MAXN];double getDistance(node a, node b){    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2)) + pow(a.h - b.h, 2);}int main(){    scanf(\"%d\", &amp;m);    for (int i = 0; i &lt; m; i++)        scanf(\"%lf%lf%lf\", &amp;dis[i].x, &amp;dis[i].y, &amp;dis[i].h);    for (int i = 0; i &lt; m - 1; i++)        for (int j = i + 1; j &lt; m; j++)        {            G[i][j] = getDistance(dis[i], dis[j]);            G[j][i] = G[i][j];        }    printf(\"%.2lf\", prim());    // for (int i = 0; i &lt; m - 1; i++)    //     cout &lt;&lt; demo[i] &lt;&lt; \" \";    return 0;}\n\nPython 语言描述:\nimport osimport sysimport mathdef caculate(x1,y1,h1,x2,y2,h2):    return math.sqrt( (x1-x2)**2+(y1-y2)**2)+(h1-h2)**2\\def find(x):    if x!=ufs[x]:        ufs[x]=find(ufs[x])    return ufs[x]def kruskal():    global ufs    ufs=list(range(n+1))    my_brige.sort(key=lambda x:x[2])    ans=0    cnt=0    for a,b,w in my_brige:        x=find(a)        y=find(b)        if x==y:            continue        cnt+=1        ans+=w        ufs[x]=y        if cnt==n-1:            return ansn=int(input())brige=[[] for i in range(n+1)]for i in range(1,n+1):    x,y,h=map(int,input().split())    brige[i]=(x,y,h)my_brige=[]for i in range(1,n):    for j in range(i+1,n+1):        x1,y1,h1=brige[i]        x2,y2,h2=brige[j]        w=caculate(x1,y1,h1,x2,y2,h2)        my_brige.append((i,j,w))ans=kruskal()print(\"{:.2f}\".format(ans))\n\nJava 语言描述:\nimport java.util.ArrayList;import java.util.Comparator;import java.util.List;import java.util.Scanner;public class Main {    static int N = 1010;    static List&lt;Node&gt; list = new ArrayList&lt;&gt;();    static int[] x = new int[N], y = new int[N], z = new int[N];    static int n;    //并查集数组    static int[] q = new int[N];    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        n = sc.nextInt();        for (int i = 0; i &lt; n; i++) {            x[i] = sc.nextInt();            y[i] = sc.nextInt();            z[i] = sc.nextInt();        }        //建边  任意两个村庄都要建边        for (int i = 0; i &lt; n; i++) {            for (int j = i + 1; j &lt; n; j++) {                int l = x[i] - x[j];                int r = y[i] - y[j];                double c = z[i] - z[j];                // i 村庄 到  j 村庄的 距离                double s = Math.sqrt(l * l + r * r) + c * c;                list.add(new Node(i, j, s));            }        }        // 核心：按权值排序        list.sort(Comparator.comparingDouble(a -&gt; a.w));        for (int i = 0; i &lt; n; i++) {            q[i] = i;        }        //记录权重之和，答案        double res = 0;        for (int i = 0; i &lt; list.size(); i++) {            int a = list.get(i).a;            int b = list.get(i).b;            double w = list.get(i).w;            a = find(a);            b = find(b);            if (a != b) {                q[a] = b;                res += w;            }        }        System.out.printf(\"%.2f\", res);    }    static int find(int x) {        if (q[x] != x) q[x] = find(q[x]);        return q[x];    }    static class Node {        int a, b;        double w;        public Node(int a, int b, double w) {            this.a = a;            this.b = b;            this.w = w;        }    }}\n\n机房这天, 小明在机房学习。\n他发现机房里一共有  台电脑, 编号为 1 到 , 电脑和电脑之间有网线连 接, 一共有  根网线将  台电脑连接起来使得任意两台电脑都直接或者间 接地相连。\n小明发现每台电脑转发、发送或者接受信息需要的时间取决于这台电脑和 多少台电脑直接相连, 而信息在网线中的传播时间可以忽略。比如如果某台电脑 用网线直接连接了另外  台电脑, 那么任何经过这台电脑的信息都会延迟  单 位时间 (发送方和接收方也会产生这样的延迟, 当然如果发送方和接收方都是 同一台电脑就只会产生一次延迟)。\n小明一共产生了  个疑问: 如果电脑  向电脑  发送信息, 那么信息从  传到  的最短时间是多少?\n解题思路:\n还是一道比较明显的求LCA(最近公共祖先)模型的题目,我们可以使用多种方法来解决该问题，这里我们使用更好写的离线的tarjan算法来解决该问题。\n除去tarjan算法必用的基础数组，我们还有一个数组d[],d[i]记录的是每个点的出度，也就是它的延迟时间，以及数组w[],w[i]的含义是点i到根节点的延迟时间。在通过dfs求出每个点i的w[i]以后，在tarjan中我们该如何求出两点的延迟时间呢？\n我们设点i到j的延迟时间为,当我们求得i与j的最近公共祖先为anc，我们首先让,但很明显，我们多加了两遍，所以我们需要减去两倍的，但延迟时间还包括经过anc的时间，所以还得加上一个。此处请结合w[]和d[]的含义理解。 最后能得出式子: 我们利用这个式子在tarjan函数中就能得出每个询问的答案，当然对于起始和结束都在同一个节点的情况下,它的答案就是当前节点的出度，我们可以进行特判一下。输入输出较多，建议使用scanf和printf进行输入输出。\n时间复杂度:dfs：每个点遍历一次,复杂度级别,tarjan算法复杂度接近 。\nC++ 语言描述:\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int N=100010;unordered_map&lt;int,vector&lt;int&gt;&gt; gra;int n,m;//单个点的出度int d[N];//记录点i到根节点的延迟int w[N];//并查集数组int q[N];//记录答案int res[N];int st[N];//存下查询vector&lt;PII&gt;    query[N];//并查集查询int find(int x){    if(x!=q[x]) q[x]=find(q[x]);    return q[x];}void dfs(int u,int fa){    w[u]+=d[u];    for(auto g:gra[u]){        if(g==fa) continue;        w[g]+=w[u];        dfs(g,u);    }}void tarjan(int u){    st[u]=1;    for(auto j:gra[u]){        if(!st[j])        {            tarjan(j);            q[j]=u;        }    }    for(auto item: query[u]){        int y=item.first,id=item.second;        if(st[y]==2){            int anc=find(y);            res[id]=w[y]+w[u]-w[anc]*2+d[anc];        }    }    st[u]=2;}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n-1;++i){        int a,b;        scanf(\"%d%d\",&amp;a,&amp;b);        gra[a].push_back(b);        gra[b].push_back(a);        d[a]++,d[b]++;    }    for(int i=0;i&lt;m;++i){        int a,b;        scanf(\"%d%d\",&amp;a,&amp;b);        if(a!=b){            query[a].push_back({b,i});            query[b].push_back({a,i});        }else{            res[i]=d[a];        }    }    dfs(1,-1);    for(int i=1;i&lt;=n;++i) q[i]=i;    tarjan(1);    for(int i=0;i&lt;m;++i) printf(\"%d\\n\",res[i]);    return 0;}\n\nPython 语言描述:\nfrom collections import defaultdictgra = defaultdict(list)d = [0] * 100010w = [0] * 100010q = [0] * 100010res = [0] * 100010st = [0] * 100010query = [[] for _ in range(100010)]def find(x):    if x != q[x]:        q[x] = find(q[x])    return q[x]def dfs(u, fa):    w[u] += d[u]    for g in gra[u]:        if g == fa:            continue        w[g] += w[u]        dfs(g, u)def tarjan(u):    st[u] = 1    for j in gra[u]:        if st[j] == 0:            tarjan(j)            q[j] = u    for item in query[u]:        y, id = item        if st[y] == 2:            anc = find(y)            res[id] = w[y] + w[u] - w[anc] * 2 + d[anc]    st[u] = 2n, m = map(int, input().split())for i in range(n - 1):    a, b = map(int, input().split())    gra[a].append(b)    gra[b].append(a)    d[a] += 1    d[b] += 1for i in range(m):    a, b = map(int, input().split())    if a != b:        query[a].append((b, i))        query[b].append((a, i))    else:        res[i] = d[a]dfs(1, -1)for i in range(1, n + 1):    q[i] = itarjan(1)for i in range(m):    print(res[i])\n\nJava 语言描述:\nimport java.util.*;public class Main {    static class Pair {        int first, second;        public Pair(int first, int second) {            this.first = first;            this.second = second;        }    }    static Map&lt;Integer, List&lt;Integer&gt;&gt; gra = new HashMap&lt;&gt;();    static int[] d = new int[100010];    static int[] w = new int[100010];    static int[] q = new int[100010];    static int[] res = new int[100010];    static int[] st = new int[100010];    static List&lt;Pair&gt;[] query = new List[100010];    static int find(int x) {        if (x != q[x]) q[x] = find(q[x]);        return q[x];    }    static void dfs(int u, int fa) {        w[u] += d[u];        for (int g : gra.get(u)) {            if (g == fa) continue;            w[g] += w[u];            dfs(g, u);        }    }    static void tarjan(int u) {        st[u] = 1;        for (int j : gra.get(u)) {            if (st[j] == 0) {                tarjan(j);                q[j] = u;            }        }        for (Pair item : query[u]) {            int y = item.first, id = item.second;            if (st[y] == 2) {                int anc = find(y);                res[id] = w[y] + w[u] - w[anc] * 2 + d[anc];            }        }        st[u] = 2;    }    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt();        int m = scanner.nextInt();        for (int i = 1; i &lt;= n; i++) {            gra.put(i, new ArrayList&lt;&gt;());            query[i] = new ArrayList&lt;&gt;();        }        for (int i = 0; i &lt; n - 1; i++) {            int a = scanner.nextInt();            int b = scanner.nextInt();            gra.get(a).add(b);            gra.get(b).add(a);            d[a]++;            d[b]++;        }        for (int i = 0; i &lt; m; i++) {            int a = scanner.nextInt();            int b = scanner.nextInt();            if (a != b) {                query[a].add(new Pair(b, i));                query[b].add(new Pair(a, i));            } else {                res[i] = d[a];            }        }        dfs(1, -1);        for (int i = 1; i &lt;= n; i++) {           q[i] = i;        }        tarjan(1);        for (int i = 0; i &lt; m; i++) {            System.out.println(res[i]);        }    }}\n\n环境治理LQ 国拥有  个城市, 从 0 到  编号, 这  个城市两两之间都有且仅有 一条双向道路连接, 这意味着任意两个城市之间都是可达的。每条道路都有一 个属性 , 表示这条道路的灰尘度。当从一个城市  前往另一个城市  时, 可 能存在多条路线, 每条路线的灰尘度定义为这条路线所经过的所有道路的灰尘 度之和, LQ 国的人都很讨厌灰尘, 所以他们总会优先选择灰尘度最小的路线。\nLQ 国很看重居民的出行环境, 他们用一个指标  来衡量 LQ 国的出行环 境,  定义为:\n\n其中  表示城市  到城市  之间灰尘度最小的路线对应的灰尘度的值。 为了改善出行环境, 每个城市都要有所作为, 当某个城市进行道路改善时, 会将与这个城市直接相连的所有道路的灰尘度都减少 1 , 但每条道路都有一个 灰尘度的下限值 , 当灰尘度达到道路的下限值时, 无论再怎么改善, 道路的 灰尘度也不会再减小了。\n具体的计划是这样的:\n第 1 天, 0 号城市对与其直接相连的道路环境进行改善;\n第 2 天, 1 号城市对与其直接相连的道路环境进行改善;\n\n第  天,  号城市对与其直接相连的道路环境进行改善;\n第  天, 0 号城市对与其直接相连的道路环境进行改善;\n第  天, 1 号城市对与其直接相连的道路环境进行改善;\nLQ 国想要使得  指标满足  。请问最少要经过多少天之后,  指标 可以满足  。如果在初始时就已经满足条件, 则输出 0 ; 如果永远不可能 满足, 则输出  。\n解题思路:\n首先，对于求解P指的公式，我们要清楚，是每个点到其他所有点的最短路径之和相加，这种涉及到任意两点的最短路，加上  的最大范围只有100，很明显我们需要想到Floyd算法求任意两点的最短路。\n我们并没有一个直观的算法直接求得答案，所以，我们考虑二分答案。 如果改善x天是符合要求的，那么大于x的天数也一定符合，但小于x的天数不一定，所以满足二段性，我们可以二分。\n我们用g[][]记录初始道路的灰尘度,m[][]记录每条道路的最低灰尘度,f[][]记录的是在改善x天后的每条道路的环境。这样我们就可以使用二分+Floyd的做法得到答案。\n当然这里有一些需要注意的细节问题，当我们改变f[i][j]的值时，相应的也要改变f[j][i]的值，因为任意两点只存在一条双向道路，所以这两个状态应该表示的是同一条道路。每次check时，别忘记将f[][]重置回g[][]，再去减去对于的天数。floyd函数每次跑完后，计算并返回此时的P值。\n最开始时我们可以判断每条道路都是最低复杂度的情况下，计算出来的P是否大于Q，如果大于说明肯定无解，直接返回-1即可。二分对于r的上限也需要注意，最多100个点，每个点最大1e5，所以理论上我们只要开到大于1e7以上就不会有问题，否则样例过大时可能会出错。\n时间复杂度：。\nC++ 语言描述:\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N=110;LL g[N][N];LL m[N][N];LL f[N][N];LL n,q;LL floyd(){    LL a=0;    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                f[i][j] = min(f[i][j], f[i][k] + f[k][j]);    for(int i=1;i&lt;=n;++i)        for(int j=1;j&lt;=n;++j)            a+=f[i][j];    return a;}//改善X天bool check(LL x){    memcpy(f,g,sizeof(g));    LL h=x/n;    LL s=x%n;    for(int i=1;i&lt;=n;++i){        for(int j=1;j&lt;=n;++j){            if(i==j) continue;            if(i&lt;=s) f[i][j]=max(m[i][j],f[i][j]-h-1);            else f[i][j]=max(m[i][j],f[i][j]-h);            f[j][i]=f[i][j];        }    }    return floyd()&lt;=q;}void solve(){    cin&gt;&gt;n&gt;&gt;q;    for(int i=1;i&lt;=n;++i){        for(int j=1;j&lt;=n;++j){            cin&gt;&gt;g[i][j];        }    }    for(int i=1;i&lt;=n;++i){        for(int j=1;j&lt;=n;++j){            cin&gt;&gt;m[i][j];            f[i][j]=m[i][j];        }    }    if(floyd()&gt;q){        cout&lt;&lt;-1&lt;&lt;endl;        return;    }    LL l=0,r=1000000000;    while(l&lt;r){        int mid=l+r&gt;&gt;1;        if(check(mid)) r=mid;        else l=mid+1;    }    cout&lt;&lt;r&lt;&lt;endl;}int main(){    solve();    return 0;}\n\nPython 语言描述:\nimport copyN=110g=[[0]*N for i in range(N)]m=[[0]*N for i in range(N)]f=[[0]*N for i in range(N)]n,q=map(int,input().split())def floyd(f):    a=0    for k in range(1,n+1):        for i in range(1,n+1):            for j in range(1,n+1):                f[i][j]=min(f[i][j],f[i][k]+f[k][j])    for i in range(1,n+1):        for j in range(1,n+1):            a=a+f[i][j]    return adef check(x,g):    f=copy.deepcopy(g)    h=x//n    s=x%n    for i in range(1,n+1):        for j in range(1,n+1):            if i==j:                continue            if i&lt;=s:                f[i][j]=max(m[i][j],f[i][j]-h-1)            else:                f[i][j]=max(m[i][j],f[i][j]-h)            f[j][i]=f[i][j]    return  floyd(f)&lt;=qdef solve():    for i in range(1,n+1):        l=list(map(int,input().split()))        for j in range(1,n+1):            g[i][j]=l[j-1]#灰尘度    for i in range(1,n+1):        l = list(map(int, input().split()))        for j in range(1,n+1):            m[i][j]=l[j-1]#灰尘度的下限值            f[i][j]=m[i][j]    if floyd(f)&gt;q:        print(-1)        return    l,r=0,10000000    while (l &lt; r):        mid=(l+r)&gt;&gt;1        if (check(mid,g)):            r=mid        else:            l=mid+1    print(r)solve()\n\nJava 语言描述:\nimport java.io.*;public class Main {    static int N=110;    static long[][] g=new long[N][N],m=new long[N][N],f=new long[N][N];    static long n,q;    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));    static PrintWriter  out=new PrintWriter(new OutputStreamWriter(System.out));    public static void main(String[] args) throws IOException {        String[] s=br.readLine().split(\" \");        n=Long.parseLong(s[0]);        q=Long.parseLong(s[1]);        for(int i=1;i&lt;=n;++i){            s=br.readLine().split(\" \");            for(int j=1;j&lt;=n;++j){                g[i][j]=Long.parseLong(s[j-1]);            }        }        for(int i=1;i&lt;=n;++i){            s=br.readLine().split(\" \");            for(int j=1;j&lt;=n;++j){                m[i][j]=Long.parseLong(s[j-1]);                f[i][j]=m[i][j];            }        }        if(floyd()&gt;q){            out.println(-1);            out.flush();            return;        }        long l=0,r=1000000000;        while(l&lt;r){            long mid=l+r&gt;&gt;1;            if(check(mid)) r=mid;            else l=mid+1;        }        out.println(r);        out.flush();    }    static long floyd(){        long a=0;        for (int k = 1; k &lt;= n; k ++ )            for (int i = 1; i &lt;= n; i ++ )                for (int j = 1; j &lt;= n; j ++ )                    f[i][j] =Math.min(f[i][j], f[i][k] + f[k][j]);        for(int i=1;i&lt;=n;++i)            for(int j=1;j&lt;=n;++j)                a+=f[i][j];        return a;    }    static boolean check(long x){        for(int i=1;i&lt;=n;++i){            for(int j=1;j&lt;=n;++j) f[i][j]=g[i][j];        }        long h=x/n;        long s=x%n;        for(int i=1;i&lt;=n;++i){            for(int j=1;j&lt;=n;++j){                if(i==j) continue;                if(i&lt;=s) f[i][j]=Math.max(m[i][j],f[i][j]-h-1);                else f[i][j]=Math.max(m[i][j],f[i][j]-h);                f[j][i]=f[i][j];            }        }        return floyd()&lt;=q;    }}\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]手算与思维题","url":"/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%89%8B%E7%AE%97%E4%B8%8E%E6%80%9D%E7%BB%B4%E9%A2%98/","content":"手算与思维题课程伊始，我们先要讲一下蓝桥杯相关的注意事项。\n比赛流程赛程：\n省赛\n决赛\n\n省赛一等奖参加决赛\n比赛时长  小时\n竞赛形式：\n个人赛，一人一机，全程机考\n答题过程中无法访问互联网\n不允许携带任何电子、纸质资料\n\n参赛选手机器环境\nX86 兼容机器，内存不小于 1G，硬盘不小于 60G 操作系统：Windows7、Windows8 或 Windows10。\nC/C++ 开发环境：Dev-cpp 5.4.0 C/C++ API 帮助文档\nJava 开发环境：JDK 1.8 Eclipse-java-2020-06 API 帮助文档\nPython 环境：Python 3.8.6 IDLE（Python 自带编辑器）\n\n题型\n结果填空 把答案直接通过网页提交，不要书写多余的内容。填空题每题  分。\n\n程序设计 每道题目多个测试数据， 是弱测试数据，其他是强测试数据。 题量大、时间紧张，难题往往不会做或来不及用高效算法编码，此时可以用暴力方法编程得  的分数。 程序设计题每题  分。\n\n\n评分方式评分：全部使用机器自动评分\n对于结果填空题，题目保证只有唯一解，选手的结果只有和解完全相同才得分，出现格式错误或有多余内容时不得分。\n对于编程大题，评测系统将使用多个评测数据来测试程序。每个评测数据有对应的分数。选手所提交的程序将分别用每个评测数据作为输入来运行。对于某个评测数据，如果选手程序的输出与正确答案是匹配的，则选手获得该评测数据的分数。\n知识点梳理（1）思维题（杂题）：不需要算法和数据结构，只需要逻辑、推理的题目，难度可难可易。考察思维能力和编码能力，只能通过大量做题来提高。\n（2）BFS 搜索和 DFS 搜索：也就是暴力搜索。这是非常基本的算法，是基础中的基础。\n（3）动态规划：线性 DP，以及一些 DP 应用，例如状态压缩 DP、树形 DP 等。\n（4）简单数学和简单数论。\n（5）简单的字符串处理、输入输出，简单图论。\n（6）基本算法：例如排序、排列、二分、倍增、差分、贪心。\n（7）基本数据结构：队列、栈、链表、二叉树等。\n技巧：手算\n应用场合：填空题\n手算的目的：减少做题时间，省下时间做编程题。\n\n手段：\n\n不编码，或者只做部分编码\n用推理获得答案\n用软件工具帮助计算\n\n方法：\n\n巧用编辑器\n心算手数\n巧用 Excel\n巧用 Python\n\n例题1. 门牌制作 2020 年第十一届蓝桥杯省赛，填空题问题描述： 从  到  的所有数字中，共有多少个 ？\n\n先编码连续打印出    这  个数字\n然后粘贴到任何一个编辑器中\n选查询或替换功能，查找或替换字符 “”，共  次，就是答案。\n\n简单直接，不用思考\n2. 迷宫 2017 年第八届蓝桥杯省赛，填空题问题描述： 给出一个迷宫，问迷宫内的人有多少能走出来。迷宫如右图所示：每个位置上有一个人，共  人。每个位置有指示牌， 表示向左走， 表示向右走， 表示向上走， 表示向下走。\nUDDLUULRUL   UURLLLRRRU    RRUURLDLRD    RUDDDDUUUU    URUDLLRRUU    DURLRLDLRL    ULLURLLRDU    RDLULLRDDD    UUDDUDUDLL    ULRDLUURRR\n\n\n正解：DFS 搜索，编码 10 分钟。\n技巧：直接用手画图标记 3-5 分钟。\n\n3. 星期一 2017 年第八届蓝桥杯省赛，填空题问题描述： 整个 20 世纪（ 年  月  日至  年  月  日之间），一共有多少个星期一？\n思路： 用 Excel，在一个格子里输入日期  年  月  日，另一个格子输入  年  月  日，然后两个格子相减得  天，除以  得  周。\n再看  年  月  日是星期几。\n用 Excel 点  年  月  日这一格的“设置单元格式-数字-日期-星期三”，点击“确定”，得“星期二”，即  年  月  日是星期二， 是  周多几天，最后几天没有星期一，说明答案就是 。\n也可以直接利用 Excel“单元格格式”对话框得出  年  月  日刚好是星期天，从星期二至星期天之间没有星期一。\n巧用 Python填空题遇到字符、大数字、日期问题，Python 是首选。\n•即使参加 C/C++、Java 组比赛，也要学一些 Python，以方便手算，或用来做对比测试。\n•这几种语言的编译器，在比赛机器上都有。\n•写 Python 代码既简单又快，代码长度一般比 C/C++、Java 短很多。例如 30 行的 C++代码，用 Python 写只需要 20 行。\n3. 星期一 2017 年第八届蓝桥杯省赛，填空题\n问题描述： 整个 20 世纪(1901 年 1 月 1 日至 2000 年 12 月 31 日之间)，一共有多少个星期一？\n直接用 Python datetime 库求解，第 4 行可以输出某个日期是星期几。\nfrom datetime import* dt1=datetime(1901,1,1) dt2=datetime(2000,12,31) print(dt1.weekday()) # 周一为0，周二为1... td=dt2-dt1 print(td.days//7)\n\n相对应的使用 C++同样可以完成，但是编码复杂：\n#include &lt;iostream&gt; using namespace std; int res; //先判断润年 bool is_r(int n){     if((n % 4 == 0 &amp;&amp; n % 100 != 0) || n % 400 == 0) return true; return false; } int main(){     for(int i = 1901;i &lt;= 2000;i ++)         if(is_r(i)) res += 366;     else res += 365;     int x = res / 7;     cout &lt;&lt; x &lt;&lt; endl;    return 0; }\n\n4. 乘积尾零 2018 年第九届蓝桥杯省赛\n【问题描述】 给出  个整数（这里省略题目给的  个数），问它们乘积的末尾有多少个零。\n最简单题解：\n\n直接连乘：几千位的大数\n然后统计末尾的 \n\n\n但是 C++ 装不下这么大的数字，所以要进行处理：\n#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int cnt2=0,cnt5=0;    for (int i=1;i&lt;=10;i++) {        for (int j=1;j&lt;=10;j++) {             int x;             cin&gt;&gt;x;            while (x%2==0) cnt2++,x/=2;             while (x%5==0) cnt5++,x/=5;         }     }     cout&lt;&lt;min(cnt2,cnt5)&lt;&lt;'\\n';    return 0; }\n\n发现编码时间变长了，如果填空题且 Java 学的好一点的，可以直接 Python 编程出结果。\n思维题\n不需要涉及某种算法的题目。\n只要学过编程语言，就能够解答。\n主要考核学生的思维、逻辑和编码能力，强调脑筋急转弯的解决方式。\n这类题目包括模拟题、构造题、思维题以及找规律题，统称为“思维题（杂题）”。\n每年蓝桥杯都会设置这类题目，而且可能有多道，是考试中的重要得分点。\n杂题涵盖了各种难度，有些可能相对简单，而另一些可能相对较难。\n\n5. 付账问题 2018 年第九届蓝桥杯省赛，lanqiaoOJ 题号 174\n【题目描述】\n现在有  个人出去吃饭，他们总共消费了  元。其中第  个人带了 元。幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？\n为了公平起见，我们希望在总付钱量恰好为  的前提下，最后每个人付的钱的标准差最小。这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 1 分钱的整数倍。你需要输出最小的标准差是多少。\n标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的”偏差有多大”。形式化地说，设第  个人付的钱为  元，那么标准差为 :\n\n解决思路：\n如果每个人携带的钱足够多，每个人平均支付相同的金额，即 ，那么标准差  为 。\n然而，总会有人的钱不够，这时我们考虑两种情况：\n（1）第  个人携带的钱不足以达到平均数 ，那么他只能支付他所携带的全部钱 。\n（2）第  个人携带的钱超过平均数 ，那么他可以支付多一些。\n解决步骤：\n（1）对  进行从小到大的排序；\n（2）前一部分人的钱不足以支付平均数，因此他们每个人支付所有携带的钱；\n（3）从总支付数中减去前一部分人支付的钱，得到剩余金额 ，以及后一部分人的平均支付数 。\n（4）后一部分人携带的钱较多，他们可以支付多一些。这部分人又可以分为两类：\n\n（i）相对富裕但仍然不足以支付  的人，他们需要支付所有携带的钱；\n（ii）非常富裕的人，无论如何摊分，他们都有余额。\n\n由于前面一部分人不足以支付 ，因此后面足够支付  的人不能只支付 。相反，他们应该尽可能地每个人支付相同的金额。\n因为有人支付不足，总有人支付过多，由于是标准差（方差的平方根），因此每个人支付的金额差距越小越好。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 5e5;long long a[M];int main(){    int n;  long long s;    scanf(\"%d %lld\",&amp;n,&amp;s);    for(int i=1;i&lt;=n;i++)  scanf(\"%lld\",&amp;a[i]);    sort(a+1,a+n+1);       //排序，从小到大    double avg = 1.0*s/n;  //平均值    double sum = 0.0;    for(int i=1;i&lt;=n;i++){        if(a[i]*(n+1-i) &lt; s){//需要把钱全拿出的人：//（1）钱不够平均数的，（2）钱够平均数，但也不是很多的            sum += (a[i]-avg)*(a[i]-avg);            s -= a[i];            //更新剩余钱数        }        else{      //不用把钱全拿出的人：非常有钱，不管怎么平均都够            double cur_avg = 1.0*s/(n+1-i);    //更新平均出钱数            sum += (cur_avg-avg)*(cur_avg-avg)*(n+1-i);            break;        }    }    printf(\"%.4lf\",sqrt(sum/n));    return 0;}\n\nfrom math import *n, s = map(int,input().split())a = list(map(int,input().split()))a.sort()avg = s/nsum = 0for i in range(n):     if a[i]*(n-i) &lt; s:          sum += pow(a[i]-avg,2)          s -= a[i]     else:          cur_avg = s/(n-i);      #更新平均出钱数          sum += pow(cur_avg-avg,2)*(n-i)          breakprint(\"{:.4f}\".format(sqrt(sum/(n))))\n\nimport java.io.FileNotFoundException;import java.util.Arrays;import java.util.Scanner;public class Main {public static void main(String args[]) {        int n;        long S;        double ans=0,avg;        Scanner input=new Scanner(System.in);        n=input.nextInt();        S=input.nextLong();        long a[]=new long[n];        for(int i=0;i&lt;n;i++)                    a[i]=input.nextLong();        Arrays.sort(a);        avg=(double)S/n;        for(int i=0;i&lt;n;i++) {            if(S&lt;=(n-i)*a[i]) {                ans += (n-i)*Math.pow((double)S/(n-i)-avg,2);                break;            }            ans += Math.pow(a[i]-avg,2);            S -= a[i];        }        System.out.printf(\"%.4f\\n\",Math.sqrt(ans/n));    }}\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]枚举与尺取","url":"/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%9E%9A%E4%B8%BE%E4%B8%8E%E5%B0%BA%E5%8F%96/","content":"在之前的课程中，我们深入讨论了打表法与模拟法的暴力解法。提到暴力，我们通常会首先想到枚举。然而，枚举实际上是一门技术，要确保能够穷尽所有可能的情况并不容易。因此，在本节课中，我们将详细介绍枚举法的技巧，以确保能够完整地列举出所有情况，不漏一种。\n知识点\n枚举法\n简单型枚举\n组合型枚举\n排列型枚举\n指数型枚举\n\n\n尺取算法\n\n枚举法枚举算法的思想：\n枚举算法的核心思想是将问题的所有可能成为答案的解一一列举，然后根据问题给定的条件判断这些解是否合适。对于符合条件的解，保留；反之则舍弃。\n枚举算法解题的基本思路：\n\n确定枚举解的范围和判断条件： 在开始解题之前，需要明确枚举的解范围，并定义问题的判断条件。\n选取合适的枚举方法： 选择适当的枚举方式进行逐一枚举，确保覆盖所有可能的解。避免遗漏任何真正的解，同时注意防止重复。\n使用判断条件检验解： 在枚举过程中，应用事先确定的判断条件验证每个解的合法性，保留符合要求的解。\n\n枚举算法的一般步骤：\n\n确定范围和枚举方式： 根据题目确定枚举的范围，并选择合适的枚举方式。确保不遗漏任何真正的解，同时避免重复。\n优化解空间： 查看是否存在优化的可能性，以缩小可能成为解的答案范围，提高解决问题的效率。\n定义准确验证条件： 根据问题找到准确、易编码的验证条件，用于检验每个可能的解。\n枚举和判断： 逐一枚举解并验证是否符合事先确定的条件，保留符合条件的解。\n输出结果： 按照要求输出枚举过程中留下的符合条件的解。\n\n枚举法包含多种技巧和方法，本节课将深入探讨其中几种方法。\n简单型枚举简单型枚举是通过简单的 for 循环嵌套解决的问题类型。在之前的课程中，我们所讨论的题目通常属于简单型枚举的范畴。因此，简单型枚举是一种相对简单且大家接触最多的枚举方式。\n这种枚举方式没有特定的固定枚举模式，而且相对简单。只需按照题目的要求设计代码即可完成解题。\n让我们通过一个示例题目来复习一下。\n42 点问题题目描述:\n众所周知在扑克牌中，有一个老掉牙的游戏叫做 24 点，选取 4 张牌进行加减乘除，看是否能得出 24 这个答案。\n现在小蓝同学发明了一个新游戏，他从扑克牌中依次抽出 6 张牌，注意不是一次抽出，进行计算，看是否能够组成 42 点，满足输出 YES，反之输出 N**O。\n最先抽出来的牌作为第一个操作数，抽出牌做第二个操作数，运算结果在当作第一个操作数，继续进行操作。\n除不尽的情况保留整数。\n请设计一个程序对该问题进行解答。\n样例:\n输入：K A Q 6 2 3输出：YES\n\n对于上面的样例我们进行了如下计算；\n1. K*A=K 即 13*1=132. 13/12=1 保留整数3. 1+6=74. 7*2=145. 14*3=42\n\n运行限制:\n最大运行时间：1s最大运行内存: 128M\n\n题目解析：\n这个题目我们可以依次枚举数字，然后在枚举数字间的符号即可。由于到结果之间进行了三步计算，所以我们这里需要进行一个递归操作，利用了上节课讲解的知识。\n两重循环即可解决问题，伪代码如下：\nop1 赋值为 第一个数op(op[1] op[2]){    for op in [+ - * /]       ans = 第一个操作数op1 操作 第二个操作数op2        如果是第六个操作数，就检验是否符合要要求 ==42？ 如果是就返回True        如果op(ans , op[3]) 返回 True，就返回True 因为找到了答案，否则就继续进行    没有找到答案返回False}\n\n但是这样写，思路感觉很清晰，写起来却非常的复杂，我们使用我们讲过的 Vector 来优化这个枚举方式。\n我们创建 5 个 Vector ，分别用来存放1−5 次的运算结果，非常简单。我们答案就采用这种方式。\n答案解析C++ 代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int a[10];vector &lt;int&gt; ans[10];int main(){    for(int i=0; i&lt;6; i++)    {        char c;        cin&gt;&gt;c;        if(c=='A')            a[i]=1;        else if(c=='J')            a[i]=11;        else if(c=='Q')            a[i]=12;        else if(c=='K')            a[i]=13;        else            a[i]=(c-'0');        //cout&lt;&lt;a[i]&lt;&lt;endl;    }    ans[0].push_back(a[0]);    for(int i=1; i&lt;=5; i++)    {        for(int j=0; j&lt;ans[i-1].size(); j++)        {            ans[i].push_back(ans[i-1][j]+a[i]);            ans[i].push_back(ans[i-1][j]-a[i]);            ans[i].push_back(ans[i-1][j]*a[i]);            ans[i].push_back(ans[i-1][j]/a[i]);        }    }    //cout&lt;&lt;ans[5].size()&lt;&lt;endl;    int flag=0;    for(int i=0; i&lt;ans[5].size(); i++)    {        if(ans[5][i]==42)        {            flag=1;            break;        }    }    if(flag==1)        cout&lt;&lt;\"YES\"&lt;&lt;endl;    else        cout&lt;&lt;\"NO\"&lt;&lt;endl;}\n\nPython 解题代码\nans = [[] for i in range(10)]a = ['0']*10if __name__ == '__main__':c = input().split()for i in range(6):    if c[i] == 'A':        a[i] = 1    elif c[i] == 'J':        a[i] = 11    elif c[i] == 'Q':        a[i] = 12    elif c[i] == 'K':        a[i] = 13    else:        a[i] = ord(c[i]) - ord('0')ans[0].append(a[0])for i in range(1, 6):    for j in range(len(ans[i - 1])):        ans[i].append(ans[i - 1][j] + a[i])        ans[i].append(ans[i - 1][j] - a[i])        ans[i].append(ans[i - 1][j] * a[i])        ans[i].append(int(ans[i - 1][j] / a[i]))flag = 0for j in range(len(ans[5])):    if ans[5][j] == 42:        flag = 1        breakif flag == 1:    print(\"YES\")else:    print(\"NO\")\n\nJava 解题代码\nimport java.util.Scanner;import java.util.Vector;public class Main {  static int[] a = new int[10];  static Vector&lt;Vector&lt;Integer&gt;&gt; ans = new Vector&lt;Vector&lt;Integer&gt;&gt;();  public static void main(String[] args) {      Scanner in = new Scanner(System.in);      for (int i = 0; i &lt; 6; i++) {          String c;          c = in.next();//            System.out.println(c);          if (c.charAt(0) == 'A')              a[i] = 1;          else if (c.charAt(0) == 'J')              a[i] = 11;          else if (c.charAt(0) == 'Q')              a[i] = 12;          else if (c.charAt(0) == 'K')              a[i] = 13;          else              a[i] = (c.charAt(0) - '0');//            System.out.println(a[i]);      }      ans.addElement(new Vector&lt;Integer&gt;());      ans.get(0).addElement(a[0]);      for(int i=1; i&lt;=5; i++)      {          ans.addElement(new Vector&lt;Integer&gt;());          for(int j = 0; j&lt; ans.get(i - 1).size(); j++)          {              ans.get(i).addElement(ans.get(i - 1).get(j) +a[i]);              ans.get(i).addElement(ans.get(i - 1).get(j)-a[i]);              ans.get(i).addElement(ans.get(i - 1).get(j)*a[i]);              ans.get(i).addElement(ans.get(i - 1).get(j)/a[i]);          }      }      //cout&lt;&lt;ans[5].size()&lt;&lt;endl;      int flag=0;      for(int i = 0; i&lt; ans.get(5).size(); i++)      {          if(ans.get(5).get(i)==42)          {              flag=1;              break;          }      }      if(flag==1)          System.out.println(\"YES\");      else          System.out.println(\" NO\");  }}\n\n组合型枚举排列组合是大家都接触过的概念，而组合型枚举则是在 n 个元素中随机选出 m 个元素的问题。对于每一种可能的选择方案，我们需要确定选择了哪 m 个元素，这就                                                                                                                                   是组合型枚举。\n具体而言，组合型枚举解决的是 Cnm 问题，即从 n 个元素中选择 m 个元素的组合数量。\n组合型枚举有一套固定的流程和算法模板，需要大家进行记忆。\nchosen = []n = 0m = 0def calc(x):  if len(chosen) &gt; m:      return  if len(chosen) + n - x + 1 &lt; m:      return  if x == n + 1:      for i in chosen:          print(i,end=' ')      print('')      return  chosen.append(x)  calc(x + 1)  chosen.pop()  calc(x + 1)if __name__ == '__main__':  tem = input().split()  n = int(tem[0])  m = int(tem[1])  calc(1)import java.util.Scanner;import java.util.Vector;public class Main {    static  int n;    static int m;//选m个数    static Vector&lt;Integer&gt; chosen = new Vector&lt;Integer&gt;();    static  void calc(int x) {        if (chosen.size() &gt; m || chosen.size() + (n - x + 1) &lt; m) //剪枝            return;        if (x == n + 1) { //选够了m个数输出            String ansTem = \"\";            for (int i = 0; i &lt; chosen.size(); i++)                System.out.print(chosen.get(i)+\" \");            System.out.println(\"\");            return;        }        chosen.addElement(x);        calc(x + 1);        chosen.remove((Object)x);        calc(x + 1);    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        n = in.nextInt();        m = in.nextInt();        calc(1);    }}#include&lt;bits/stdc++.h&gt;using namespace std;int n;//共计N个数int m;//选m个数vector&lt;int&gt; chosen;string s[1000];void calc(int x) {    if (chosen.size() &gt; m || chosen.size() + (n - x + 1) &lt; m) //剪枝        return;    if (x == n + 1) { //选够了m个数输出        for (int i = 0; i &lt; chosen.size(); i++)            cout&lt;&lt; s[chosen[i]]&lt;&lt;\" \";//也可以不输出，存放起来也是可以的，主要是看题目。        puts(\"\");        return;    }    chosen.push_back(x);    calc(x + 1);    chosen.pop_back();//消除痕迹    calc(x + 1);}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;s[i];    }    calc(1);}\n\n大家有个疑虑，我这里全是数字而且是从 11 开始的能好用吗，我题目要是字母怎么办，那么请看下面的题目。\n公平抽签题目描述:\n小 A 的学校，蓝桥杯的参赛名额非常有限，只有 m 个名额，但是共有 n 个人报名，其中 ≤m≤n。作为老师非常苦恼，他不知道该让谁去，他在寻求一个绝对公平的方式。于是他准备让大家抽签决定，即 m 个签是去，剩下的是不去。\n小 A 非常想弄明白最后的抽签结果是什么样子的，到底有多少种结果。\n请设计一个程序帮助小 A。最后输出各种情况的人名即可，一行一种情况，每种情况的名字按照报名即输入顺序排序。\n第一行 输入 N,M。\n第二行 到 第N+1 行 共输入 N 个人名\n每种情况输出 M 个人名，空格隔开。\n样例:\n输入：3  2xiaowangxiaoAxiaoli输出：xiaowang xiaoAxiaowang xiaolixiaoA xiaoli\n\n运行限制:\n1. 最大运行时间：1s2. 最大运行内存：128M\n\n题目解析：\n实际上还是组合型枚举，但是输出元素为人名，我们可以将人名存起来，输出的时候，根据数字下标找到提前存好的人名，直接输出即可。\n答案解析C++ 代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n; //共计N个数int m; //选m个数vector&lt;string&gt; name;vector&lt;string&gt; ans;vector&lt;int&gt; chosen;void calc(int x){    if (chosen.size() &gt; m || chosen.size() + (n - x + 1) &lt; m) //剪枝        return;    if (x == n + 1)    { //选够了m个数输出        string ansTem = \"\";        for (int i = 0; i &lt; chosen.size(); i++)            ansTem += name[chosen[i] - 1] + \" \";        ans.push_back(ansTem);        return;    }    chosen.push_back(x);    calc(x + 1);    chosen.pop_back(); //消除痕迹    calc(x + 1);}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i++)    {        string s;        cin &gt;&gt; s;        name.push_back(s);    }    calc(1);    for (int i =0; i &lt; ans.size(); i++)        cout &lt;&lt; ans[i] &lt;&lt; endl;}\n\nPython 解题代码\nname = []ans = []chosen = []n = 0m = 0def calc(x):    if len(chosen) &gt; m:        return    if len(chosen) + n - x + 1 &lt; m:        return    if x == n + 1:        ansTem = \"\"        for i in chosen:            ansTem = ansTem + name[i - 1] + ' '        # print(ansTem)        ans.append(ansTem)        return    chosen.append(x)    calc(x + 1)    chosen.pop()    calc(x + 1)if __name__ == '__main__':    tem = input().split()    n = int(tem[0])    m = int(tem[1])    # print(n,\" \",m)    for i in range(n):        s = input()        name.append(s)    # print(name)    calc(1)    for i in range(0,len(ans)):        print(ans[i])\n\nJava 解题代码\nimport java.util.Scanner;import java.util.Vector;public class Main {  static  int n;  static int m;//选m个数  static Vector&lt;String&gt; name = new Vector&lt;String&gt;();  static Vector&lt;String&gt; ans = new Vector&lt;String&gt;();  static Vector&lt;Integer&gt; chosen = new Vector&lt;Integer&gt;();  static &lt;object&gt; void calc(int x) {      if (chosen.size() &gt; m || chosen.size() + (n - x + 1) &lt; m) //剪枝          return;      if (x == n + 1) { //选够了m个数输出          String ansTem = \"\";          for (int i = 0; i &lt; chosen.size(); i++)              ansTem += name.get(chosen.get(i) - 1) + \" \";          ans.addElement(ansTem);          return;      }      chosen.addElement(x);      calc(x + 1);      chosen.remove((Object)x);      calc(x + 1);  }  public static void main(String[] args) {      Scanner in = new Scanner(System.in);      n = in.nextInt();      m = in.nextInt();      for (int i = 0; i &lt; n; i++) {         String s;         s=in.next();         name.addElement(s);      }      calc(1);    for (int i =0; i &lt; ans.size(); i++)          System.out.println(ans.get(i) );  }}\n\n排列型枚举上面说过，组合型枚举就是让你在 n 个中，随机选出 m 个 ，问你有多少种方案，而且每一种方案选择了哪 m 个，这就是组合型枚举。\n而排列型枚举相对组合型枚举就简单了一点，就是 n 个的全排列，即从 n 个中选取 n 个但是关心内部的顺序。\n相比较组合只关心有多少个集合，而排列是关心集合内的排列方式。即排列型枚举就是寻找 Ann 问题。\n而且排列型枚举也是有着比较成熟的模板需要大家进行记忆。\nint n; //共计N个数int order[20];bool chosen[20];void calc(int k){    if (k == n + 1)    {        for (int i = 1; i &lt;= n; i++)            cout &lt;&lt; order[i] &lt;&lt; \" \";        puts(\"\");        return;    }    for (int i = 1; i &lt;= n; i++)    {        if (chosen[i])            continue;        order[k] = i;        chosen[i] = 1;        calc(k + 1);        chosen[i] = 0;        order[k] = 0;    }}int main(){    cin &gt;&gt; n;    calc(1);}\n\nPython 写法\norder = [0] * 20chosen = [0] * 20n = 0def calc(x):  if x == n + 1:      ansTem = ''      for i in range(1, n + 1):          print(order[i],end=' ')      print('')      return  for i in range(1,n+1):      if(chosen[i]==1) :          continue      order[x]=i      chosen[i]=1      calc(x+1)      chosen[i]=0      order[x]=0if __name__ == '__main__':  n = int(input())  # print(name)  calc(1)\n\nJava 写法\nstatic  int n;static int[] order =new int[20];static boolean[] chosen =new boolean[20];static &lt;object&gt; void calc(int x) {    if (x == n + 1) { //选够了m个数输出        String ansTem = \"\";        for (int i = 1; i &lt;=n ; i++)            System.out.println(order[i]);        return;    }    for (int i = 1; i &lt;= n; i++) {        if (chosen[i]) continue;        order[x] = i;        chosen[i] =true;        calc(x + 1);        chosen[i] = false;        order[x] = 0;    }}public static void main(String[] args) {    Scanner in = new Scanner(System.in);    n = in.nextInt();    for (int i = 0; i &lt; n; i++) {       String s;        s=in.next();        name.addElement(s);    }    calc(1);}\n\n不少同学问我 20 够不够，排列问题是阶乘阶的时间复杂度，如果超过这个复杂度，那么这个题也就不用做了，算不出来。\n所以肯定够用。\n41 2 3 41 2 4 31 3 2 41 3 4 21 4 2 31 4 3 22 1 3 42 1 4 32 3 1 42 3 4 12 4 1 32 4 3 13 1 2 43 1 4 23 2 1 43 2 4 13 4 1 23 4 2 14 1 2 34 1 3 24 2 1 34 2 3 14 3 1 24 3 2 1\n\n44 的排列就已经这么多了，大家可以尝试跑一下 1010。\n同样，我们再来看一个的问题来进行加深理解。\n座次问题题目描述:\n小 A 的学校，老师好不容易解决了蓝桥杯的报名问题，现在老师又犯愁了。现在有 N 位同学参加比赛，但是老师想给他们排座位，但是排列方式太多了。老师非常想弄明白最后的排座次的结果是什么样子的，到底有多少种结果。\n请设计一个程序帮助老师。\n最后输出各种情况的人名即可，一行一种情况，每种情况的名字按照报名即输入顺序排序。\n第一行 输入 N； 第二行 到 第 N+1 行 共输入 N 个人名。\n由于小 A 学校承办能力实在有限，所以其中 N 小于等于 10 人。\n样例:\n输入：3xiaowangxiaoAxiaoli输出：xiaowang xiaoA xiaolixiaowang xiaoli xiaoAxiaoA xiaowang xiaolixiaoA xiaoli xiaowangxiaoli xiaowang xiaoAxiaoli xiaoA xiaowang\n\n运行限制:\n1. 最大运行时间：1s2. 最大运行内存：128M\n\n题目解析：\n实际上还是排列型枚举，但是输出元素为人名，我们可以将人名存起来，输出的时候，根据数字下标找到提前存好的人名，就是按照上一道题的方式处理即可。\n答案解析C++ 代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n; //共计N个数vector&lt;string&gt; name;int order[20];bool chosen[20];void calc(int k){    if (k == n + 1)    {        for (int i = 1; i &lt;= n; i++)            cout &lt;&lt; name[order[i] - 1] &lt;&lt; \" \";        puts(\"\");        return;    }    for (int i = 1; i &lt;= n; i++)    {        if (chosen[i])            continue;        order[k] = i;        chosen[i] = 1;        calc(k + 1);        chosen[i] = 0;        order[k] = 0;    }}int main(){    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    {        string s;        cin &gt;&gt; s;        name.push_back(s);    }    calc(1);}\n\nPython 解题代码\nname = []order = [0] * 20chosen = [0] * 20n = 0def calc(x):  if x == n + 1:      ansTem = ''      for i in range(1, n + 1):          ansTem = ansTem + name[order[i]-1] + ' '      print(ansTem)      return  for i in range(1,n+1):      if(chosen[i]==1) :          continue      order[x]=i      chosen[i]=1      calc(x+1)      chosen[i]=0      order[x]=0if __name__ == '__main__':  n = int(input())  for i in range(n):      s = input()      name.append(s)  # print(name)  calc(1)\n\nJava 解题代码\npackage com.company;import java.util.Scanner;import java.util.Vector;public class Main {  static  int n;  static Vector&lt;String&gt; name = new Vector&lt;String&gt;();  static int[] order =new int[20];  static boolean[] chosen =new boolean[20];  static &lt;object&gt; void calc(int x) {      if (x == n + 1) { //选够了m个数输出          String ansTem = \"\";          for (int i = 1; i &lt;=n ; i++)              ansTem += name.get(order[i]-1) + \" \";          System.out.println(ansTem);          return;      }      for (int i = 1; i &lt;= n; i++) {          if (chosen[i]) continue;          order[x] = i;          chosen[i] =true;          calc(x + 1);          chosen[i] = false;          order[x] = 0;      }  }  public static void main(String[] args) {      Scanner in = new Scanner(System.in);      n = in.nextInt();      for (int i = 0; i &lt; n; i++) {         String s;          s=in.next();          name.addElement(s);      }      calc(1);  }}\n\n尺取法尺取法（双指针法、two pointers）是一种常用的优化技巧，特别适用于解决序列的区间问题。它的操作简单，易于编程，是一种线性高效的算法。\n尺取法的核心思想是维护一个区间（L,R），其中 L 为起点，R 为终点，该区间是序列内以 L 为起点的最短合法区间。关键在于 R 随着 L 的增大而增大。通过不断枚举 L，同时求解相应的 R，可以高效地解决问题。\n具体的实现步骤是，不断移动 L 指针，同时更新 R 指针，直到 R 随着 L 的增大而增大。因为 R 随着 L 的增大而增大，所以总的时间复杂度为 O(n)。\n通过维护两个指针，即左指针 l 和右指针 r。通过不断确定区间的左端点，让右指针 r 不断向右移动，直到满足条件停下，然后维护答案。这个过程重复进行，直到左指针 l 超过右指针 r 或满足其他特定情况（根据题目而定）。\n尺取法的应用范围广泛，特别适用于需要寻找满足某种条件的连续子序列的问题。通过灵活运用尺取法，可以在保持算法简洁的同时，提高解题效率。\n例题 奇怪的的动物园题目描述动物园正在展出由世上最受欢迎的 m 种动物组成的精彩展览。\n游客在购买门票时必须说明两个数字，a 和 b，代表他们希望观看的展览范围，从第 a 种动物到第 b 种动物（包含 a,b）。门票的价格是按照观看的动物数量计算的，即每种动物一元。\n小明希望在最小化购票花费的同时，能够欣赏到所有受欢迎的动物。\n请计算他应该选择哪些动物范围，即 a 和 b。\n若存在多组解，输出其中 a 最小的那组。\n输入格式第一行包含两个整数 n 和 m，分别表示动物园内的动物总数以及受欢迎的动物种类数量。\n第二行包含 n 个整数a**i，表示第 i 种动物的种类。\n输出格式一行包含两个整数 a,b。\n样例输入\n12 52 5 3 1 3 2 4 1 1 5 4 3\n\n样例输出\n2 7\n\n思路与算法这是一道使用尺取法（Two Pointers）的题目。我们维护两个指针 l 和 r，分别表示当前选择区间的左右端点。通过不断调整右指针 r，保证区间内包含所有受欢迎的动物。在滑动窗口的过程中，记录最小购票范围。\n具体的实现细节如下：\n\n使用 I 函数加入第 x 种动物的画，同时更新相应的计数和唯一动物数量。\n使用 D 函数删除第 x 种动物的画，同时更新相应的计数和唯一动物数量。\n不断移动右指针 r，并在保证区间内包含所有受欢迎的动物的前提下，更新最小购票范围。\n移动左指针 l，直到无法再删除动物，保证区间仍然包含所有受欢迎的动物。\n\n复杂度分析由于每个动物最多被插入和删除一次，算法的时间复杂度为O(n)，其中 n 是动物的数量。\n代码#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000005;int n, m, a[MAXN], b[MAXN], cnt, ans, ansl, ansr;// 加入第x种动物inline void I(int x) {    if (b[x] == 0) cnt++; // 如果该动物没有在当前区间中出现过，增加唯一动物数量    b[x]++; // 动物x的数量加1}// 删除第x种动物inline void D(int x) {    if (b[x] == 1) cnt--; // 如果删除后该动物不再在当前区间中出现，减少唯一动物数量    b[x]--; // 动物x的数量减1}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); // 读取每种动物的种类    ans = n;    for (int r = 1, l = 1; r &lt;= n; r++) {        I(a[r]); // 首先插入a[r]的动物        while (true) {            D(a[l]); // 先删a[l]的动物            if (cnt == m) l++; // 如果删了没事，加l            else {                I(a[l]);                break; // 删了有事，还留着            }        }        if (cnt == m &amp;&amp; r - l + 1 &lt; ans) {            ans = r - l + 1;            ansl = l;            ansr = r;        }    }    if (ansl != 0) printf(\"%d %d\", ansl, ansr);    else printf(\"1 %d\", n); // 输出+特判：选择任意一个≤n的区间不满足要求，则只好选择区间[1,n]    return 0;}MAXN = 1000005a = [0]*MAXNb = [0]*MAXNcnt=0ansl=0ansr=0def I(x):    global cnt    if b[x] == 0:        cnt += 1    b[x] += 1def D(x):    global cnt    if b[x] == 1:        cnt -= 1    b[x] -= 1n, m = map(int, input().split())a[1:n+1] = map(int, input().split())ans = nl = 1for r in range(1, n+1):    I(a[r])    while True:        D(a[l])        if cnt == m:            l += 1        else:            I(a[l])            break    if cnt == m and r - l + 1 &lt; ans:        ans = r - l + 1        ansl = l        ansr = rif ansl != 0:    print(ansl, ansr)else:    print(1, n)import java.util.Scanner;public class Main {    static final int MAXN = 1000005;    static int[] a ;    static int[] b;    static int cnt = 0;    static void I(int x) {        if (b[x] == 0) cnt++;        b[x]++;    }    static void D(int x) {        if (b[x] == 1) cnt--;        b[x]--;    }    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt();        a=new int[n+10];        b=new int[n+10];        int m = scanner.nextInt();        for (int i = 1; i &lt;= n; i++) a[i] = scanner.nextInt();        int ans = n;        int ansl = 0, ansr = 0;        for (int r = 1, l = 1; r &lt;= n; r++) {            I(a[r]);            while (true) {                D(a[l]);                if (cnt == m) l++;                else {                    I(a[l]);                    break;                }            }            if (cnt == m &amp;&amp; r - l + 1 &lt; ans) {                ans = r - l + 1;                ansl = l;                ansr = r;            }        }        if (ansl != 0) System.out.println(ansl + \" \" + ansr);        else System.out.println(\"1 \" + n);    }}\n\n这个算法通过维护两个指针，实现了在 O(n) 的时间复杂度内找到最小购票范围的目标。尺取法的思想在滑动窗口的过程中，通过不断调整左右指针来满足特定条件。\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]差分与前缀和","url":"/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/","content":"差分与前缀和差分与前缀和是一对互逆的操作，常常用于处理区间问题，差分法是解决区间加减问题，前缀和是解决区间求和问题的常用办法。\n知识点\n差分算法\n前缀和算法\n\n差分法差分法的应用主要是用于处理区间问题。当某一个数组要在很多不确定的区间，加上相同的一个数。我们如果每个都进行加法操作的话，那么复杂度  是平方阶的，非常消耗时间。\n如果我们采用差分法，将数组拆分，构造出一个新的拆分数组，通过对数组区间的端点进行加减操作，最后将数组和并就能完成原来的操作。\n这样处理后，时间复杂度降低为 ，虽然感觉操作变得更加复杂了，但是只用对边界操作确实比操作一整个区间的方法要优秀的多。\n听到这里也是吊足了胃口，那到底怎么对区间操作呢，请大家跟随我的讲解，慢慢理解。\n差分法的特点：\n\n将对于区间的加减操作转化为对于端点的操作；\n时间复杂度为 ；\n用于维护区间的增减但不能维护乘除；\n差分后的序列比原来的数组序列多一个数。\n\n差分算法解题的基本思路：\n\n设定 ；\n对于第 2 项到第 n 项，利用差分式 ；\n对于区间端点进行加减操作；\n进行差分还原（即前缀和）；\n注意，这里从 1 开始。如果从 0 开始，还需讨论  的情况。使用 1 的话，。\n\n差分法的一般步骤：\n假设有一个数组：\na = [1, 2, 3, 4, 5, 7, 2]\n\n差分后：\nb = [1, 1, 1, 1, 1, 2, -5]\n\n一般应用场景是对区间  进行  次加减操作。例如：\n\n从第二个元素到第五个元素每个加 \n从第二个元素到第四个元素每个减 \n从第一个元素到第三个元素每个加 \n\n对于每个  区间的加减操作都可转化为对端点  和  的操作。例如，从第二个元素到第五个元素每个加 ，可转化为  加  且  减 。\n原序列变成了：\n1 1 1 1 1 2 -51 4 1 1 1 -1 -5\n\n然后按照  复原：\n1 5 6 7 8 7 2\n\n去掉最后一项，跟原序列对比：\n1 2 3 4 5 7 21 5 6 7 8 7 2\n\n确实是都加上了 。\n继续操作：\n从第二个元素到第四个元素每个减 ，可转化为  减  且  加 。\n序列变成了：\n1 4 1 1 1 -1 -51 2 1 1 3 -1 -5\n\n然后按照  复原：\n1 3 4 5 8 7 2\n\n与上次复原后对比：\n1 5 6 7 8 7 2 1 3 4 5 8 7 2\n\n确实是按照操作执行了。\n注意，不需要每次都复原，只需在最后一次复原即可。\n最后直接做三次，最后还原：\n\n从第二个元素到第五个元素每个加 \n从第二个元素到第四个元素每个减 \n从第一个元素到第三个元素每个加 \n\n原序列差分后：\nb = [1 1 1 1 1 2 -5]\n\n\n第 2 个元素加 3\n第 6 个元素减 3\n第 2 个元素减 2\n第 5 个元素加 2\n第 1 个元素加 1\n第 4 个元素减 1\n\n差分序列变成：\n2 2 1 0 3 -1 -5\n\n复原后：\n2 4 5 5 8 7 5\n\n与原序列对比：\n1 2 3 4 5 7 2 2 4 5 5 8 7 5\n\n所以，差分算法是非常方便快捷的。\n差分与前缀和是逆操作，常在一起出现，但是先做差分还是先做前缀和就是两种不同的算法，做不做另一种操作也决定了算法不同，所以大家要根据题目分析，具体学会使用。\n大学里的树木要打药题目描述:\n教室外有 N 棵树，根据不同的位置和树种，学校要对其上不同的药。\n因为树的排列成线性，且非常长，我们可以将它们看作一条直线给他们编号。\n树的编号从  ~  且 。\n对于树的药是成区间分布，比如  号的树靠近下水道，所以他们要用驱蚊虫的药，  号的树，他们排水不好，容易涝所以要给他们用点促进根系的药。\n诸如此类，每种不同的药要花不同的钱。\n现在已知共有  个这样的区间，并且给你每个区间花的钱，请问最后，这些树木花了多少药费。\n输入:\n输入描述:\n每组输入的第一行有两个整数 （）和 （）。\n 代表马路的共计多少棵树，代表区间的数目， 和  之间用一个空格隔开。\n接下来的  行每行包含三个不同的整数，用一个空格隔开，表示一个区域的起始点  和终止点  的坐标，以及花费。\n输入样例:\n500 3150 300 4100 200 20470 471 19\n\n输出描述:\n输出包括一行，这一行只包含一个整数，所有的花费。\n输出样例:\n2662\n\n样例:\n输入样例:\n3000 8150 1130 21020 1200 3470 2071 11123  211 612 222 213 23 21  213 41232  2523 6\n\n输出样例:\n2662\n\n运行限制:\n1. 最大运行时间：1s 2. 最大运行内存：128M\n\n题目解析：\n\n利用 差分式。\n这里由于开始时都是 ，可以用，但是用完都还是 ，所以没有意义，所以直接跳过即可。\n\n依次读入区间的值，然后将对于区间的操作转化为对于区间端点操作加减。 由于我们从  开始，所以数目整体区间要右移  位。\n对于每个  区间的加减操作都转化为对端点  的操作。\n\n差分还原(前缀和)。\n\n\nfor (int i = 1; i &lt; n; i++)     b[i] = a[i] - a[i - 1]\n\n差分算法解决区间加减问题通用框架如下：\n//读入原始数据 n,m,a输入n,mfor(int i=1;i&lt;=n;i++){    输入a[i]}//差分for(int i=1;i&lt;=n;i++)    b[i]=a[i]-a[i-1]//区间操作while(m--){    输入l,r,value    b[l]+value    b[r+1]-value}//前缀和还原for(int i=1;i&lt;n;i++)    b[i]=b[i]+b[i-1]\n\n答案解析C++ 代码：\n#include &lt;iostream&gt;using namespace std;int b[100005];int main(){    int n; //n层    int m; // m个区间    cin &gt;&gt; n &gt;&gt; m;    while (m--)    {        int l, r, value;        cin &gt;&gt; l &gt;&gt; r &gt;&gt; value;        b[l+1] += value;        b[r + 1+1] -= value;    }    for (int i = 1; i &lt;= n; i++)        b[i] = b[i] + b[i - 1];    int sum = 0;    for (int i = 1; i &lt;= n; i++)        sum += b[i];    /*    也可以一次性搞定    int sum=b[1];    for(int i=1; i&lt;=n; i++){    b[i]=b[i]+b[i-1];    sum+=b[i]    }    */    cout &lt;&lt; sum &lt;&lt; endl;}\n\nPython 解题代码\n递推算法代码：\nb = [0] * 100005if __name__ == '__main__':    nm = input().split()    n = int(nm[0])    m = int(nm[1])    while (m &gt; 0):        m -= 1        lrv = input().split()        l = int(lrv[0])        r = int(lrv[1])        value = int(lrv[2])        b[l+1] += value        b[r + 1+1] -= value    for i in range(1, n+1):        b[i] = b[i - 1] + b[i]    sum = 0    for i in range(1,n+1):        sum += b[i]    print(sum)    #或者一次性解决    # sum = a[0]    #    # for i in range(1, n+1):    #    #     a[i] = a[i - 1] + a[i]    #    #     sum += a[0]    # print(sum)\n\nJava 解题代码\nimport java.util.Scanner;public class Main {  static int b[]=new int [100005];  public static void main(String[] args) {      Scanner in = new Scanner(System.in);      int n; //n层      int m; // m个区间      n = in.nextInt();      m = in.nextInt();      while(m&gt;0)      {          m--;          int l,r,value ;          l = in.nextInt();          r = in.nextInt();          value = in.nextInt();          b[l+1]+=value;          b[r+1+1]-=value;      }      for(int i=1; i&lt;=n; i++)          b[i]=b[i]+b[i-1];      int sum=0;      for(int i=1;i&lt;=n;i++)          sum+=b[i];  /*  也可以一次性搞定  int sum=a[0];  for(int i=1; i&lt;n; i++){  a[i]=a[i]+a[i-1];  sum+=a[i]  }  */      System.out.println(sum);  }}\n\n前缀和前缀和法的应用主要也是用于处理区间问题。\n前缀和是指某序列的前  项和，可以把它理解为数学上的数列的前  项和。当对于某一数组区间进行多次询问， 的和时，如果正常处理，那么我们每次都要 。查询  次，那么时间复杂度也是  也是平方阶的。\n如果我们采用前缀和，构造出一个前缀和数组，通过对于端点的值的减法操作就能  的求出  的和。然后  次查询的，就将复杂度降低为 。\n同差分一样，感觉操作变得更加复杂了，但是只用对端点值的操作确实比一整个区间相加的方法要优秀的多。听到这里大家很期待了，我们接着进行讲解。\n前缀和的特点：\n\n将对于区间的求和操作转化为对于端点值的减法的操作；\n区间求和操作的时间复杂度为 ；\n数组存放时要从  开始；\n前缀和数组比原来的数组序列多一个数，第  个元素为 。\n\n前缀和算法解题的基本思路：\n\n利用  差分式；\n从第 1 项到  项，且第  项无数据默认为 ；\n对于区间求和的操作转化为端点值相减。\n\n前缀和的一般解题过程：\n首先假设有一个数组：1 2 3 4 5 7 2前缀和后：0 1 3 6 10 15 22 24一般应用场景：让你对区间 [l,r] 求和操作N次如：从第二个元素到第五个元素的和从第二个元素到第四个元素的和从第一个元素到第三个元素的和....这里我们先演示前三个：对于每个 [l,r] 区间的求和操作转化为区间端点的加减操作sum[l,r] =[r]-[l-1]从第二个元素到第五个元素的和：转化为：[5]-[1]那么Sum[2,5]=[5]-[1]=14且 2+3+4+5=14确实是相等的，就是这么神奇。我们继续操作：从第二个元素到第四个元素的和转化为：[4]-[1]那么Sum[2,4]=[4]-[1]=9且 2+3+4=9我们继续操作：从第一个元素到第三个元素的和转化为：[3]-[0]那么Sum[1,3]=[3]-[0]=6且 1+2+3=6符合题意，验证结束，咱么做个题目看一看\n\n大学里的树木要维护题目描述:\n教室外有  棵树，根据不同的位置和树种，学校已经对其进行了多年的维护。因为树的排列成线性，且非常长，我们可以将它们看作一条直线给他们编号。\n树的编号从  且 。由于已经维护了多年，每一个树都由学校的园艺人员进行了维护费用的统计。\n每棵树的前期维护费用各不相同，但是由于未来需要要打药，所以有些树木的维护费用太高的话，就要重新种植。由于维护费用也称区间分布，所以常常需要统一个区间里的树木的维护开销。\n现在园艺人员想知道，某个区间内的树木维护开销是多少。共计  个区间需要查询。\n输入描述:\n每组输入的第一行有两个整数 （）和 （）。\n 代表马路的共计多少棵树， 代表区间的数目， 和  之间用一个空格隔开。接下来的一行，包含  个数，每个数之间用空格隔开。\n接下来的行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。\n输入样例:\n10 37 5 6 4 2 5 0 8 5 31 52 63 7\n\n输出描述:\n输出包括  行，每一行只包含一个整数，所有的花费。\n输出样例:\n242217\n\n样例:\n输入样例\n30 28172 723 580 822 718 798 941 625 450 716 540 252 16 666 115 679 274 323 875 233 99 538 881 486 610 462 319 878 930 7356 227 213 167 209 170 2113 277 1910 232 1421 2215 176 1316 2321 2111 155 129 118 2210 163 815 275 164 80 274 87 2120 21\n输出样例\n81406804791867053708106176576647262077847637106843383902991589504017066401298444845894651639041391339046804332\n\n运行限制:\n1. 最大运行时间：1s2. 最大运行内存：128M\n\n题目解析：\n\n利用 前缀和式在输入时求出前缀和；\n依次读入区间的值，然后将对于区间的求和操作转化为对于区间端点操作加减，对于每个 [l,r] 区间的求和操作都转化为对端点[r]-[l-1]的操作。\n输出答案。\n\n前缀和一般解题过程：\n输 入 N 和 M输入 N 个值 并计算前缀和for( int i=1;i&lt;=N;i++)    输入a[i]    并计算sum[i]=sum[i-1]+a[i]输入 M 个区间，计算结果while(M)    M-=1    输入 L , R    计算 [r]-[l-1]，并输出\n\n答案解析C++ 代码：\n#include &lt;iostream&gt;using namespace std;int a[100005];int sum[100005];int main(){    int n;    int m;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)    {        cin &gt;&gt; a[i];        sum[i] = a[i] + sum[i - 1];    }    while (m &gt; 0)    {        m -= 1;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        cout &lt;&lt; sum[r] - sum[l - 1] &lt;&lt; endl;    }}\n\n这个代码有个问题，虽然是能通过的，但是他是一个输入对应一个输出的，我们之前讲过，这对大部分的测评机是没问题。\n终端输出：\n10 37 5 6 4 2 5 0 8 5 31 5242 6223 717Process returned 0 (0x0)   execution time : 1.741 sPress any key to continue.\n\n但是如果有想要规规矩矩的处理，或者说题目要求必须全部读入后输出。我们可这样操作。\n#include&lt;bits/stdc++.h&gt;using namespace std;int a[100005];int sum[100005];vector&lt;int&gt;ss;int main(){    int n ;    int m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a[i];        sum[i]=a[i]+sum[i-1];    }    while(m&gt;0)    {        m-=1;        int l,r;        cin&gt;&gt;l&gt;&gt;r;        ss.push_back(sum[r]-sum[l-1]);    }    for(auto sss:ss) cout&lt;&lt;sss&lt;&lt;endl;}\n\n终端输出：\n10 37 5 6 4 2 5 0 8 5 31 52 63 7242217Process returned 0 (0x0)   execution time : 6.235 sPress any key to continue.\n\n都可以，大家看自己需求和心情选择即可。\nPython 解题代码\n普通代码：\na = [0] * 100005sum1 = [0] * 100005if __name__ == '__main__':    nm = input().split()    n = int(nm[0])    m = int(nm[1])    a = input().split()    a = list(map(int, a))    # split 分割后都是 字符 这里是转化成数字    #print(a)    for i in range(1, n + 1):        # print(i)        sum1[i] = sum1[i - 1]        sum1[i] += a[i - 1]  # 分割完后，a[]是从0开始,所以要减1    while m &gt; 0:        m -= 1        lrv = input().split()        l = int(lrv[0])        r = int(lrv[1])        print(sum1[r] - sum1[l - 1])\n\n特殊代码：\na = [0] * 100005sum1 = [0] * 100005if __name__ == '__main__':    nm = input().split()    n = int(nm[0])    m = int(nm[1])    a = input().split()    a = list(map(int, a))    # split 分割后都是 字符 这里是转化成数字    # print(a)    for i in range(1, n + 1):        # print(i)        sum1[i] = sum1[i - 1]        sum1[i] += a[i - 1]  # 分割完后，a[]是从0开始,所以要减1    ans = []    while m &gt; 0:        m -= 1        lrv = input().split()        l = int(lrv[0])        r = int(lrv[1])        ans.append(sum1[r] - sum1[l - 1])    for i in ans:        print(i)\n\nJava 解题代码\n普通算法：\nimport java.util.Scanner;public class Main {    static int a[]=new int [100005];    static int sum[]=new int [100005];    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        int n; //n层        int m; // m个区间        n = in.nextInt();        m = in.nextInt();        for(int i=1;i&lt;=n;i++)        {            a[i]= in.nextInt();            sum[i]=a[i]+sum[i-1];        }        while(m&gt;0)        {            m--;            int l,r;            l = in.nextInt();            r = in.nextInt();            System.out.println((sum[r]-sum[l-1]));        }    }}\n\n特殊代码：\nimport java.util.Scanner;import java.util.Vector;public class Main {    static int a[]=new int [100005];    static int sum[]=new int [100005];    static Vector ans=new Vector&lt;Integer&gt;();    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        int n; //n层        int m; // m个区间        n = in.nextInt();        m = in.nextInt();        for(int i=1;i&lt;=n;i++)        {             a[i]= in.nextInt();            sum[i]=a[i]+sum[i-1];        }        while(m&gt;0)        {            m--;            int l,r;            l = in.nextInt();            r = in.nextInt();            ans.addElement(sum[r]-sum[l-1]);        }        for(Object ab:ans){            System.out.println(ab);        }    }}\n\n总结我们这节课讲了差分和前缀和的知识点，并且也讲了怎样使用差分，怎样使前缀和，也讲了差分和前缀和最常见的两种情况。\n差分和前缀和是很多思维题的解题技巧，必须要掌握熟练才能拿到简单题目的全部分数。\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]搜索算法","url":"/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","content":"深度优先搜索Depth First Search 即 DFS，意为深度优先搜索，是所有的搜索手段之一。它是从某个状态开始，不断进行状态转移，直到不能转移后，向后回退，一直到遍历完所有的状态。\n本章题目难度较大，请大家仔细研读讲解和代码。\n知识点1.DFS 算法设计原理与实现方法 2.经典题型精讲\n深度优先搜索基本概念作为搜索算法的一种，DFS 主要是用于解决 NP 完全问题。但是，深度优先搜索算法的时间复杂度较高，深度优先搜索是  的阶乘级算法，它的效率非常低，在数据规模变大时，此算法就难以解决当前的问题了。\n所以搜索算法使用于状态节点较小规模的问题。\nDFS 的设计步骤按照定义设计：\n\n确定该题目的状态（包括边界）\n\n找到状态转移方式\n\n找到问题的出口，计数或者某个状态\n\n设计搜索\n\n\n伪代码：\nint check(参数){    if(满足条件)        return 1;    return 0;}bool pd(参数){    相应操作}void dfs(int step){        判断边界pd()        {            不在边界内，即回溯        }        尝试每一种可能        {               满足check条件               标记               继续下一步dfs(step+1)               恢复初始状态（回溯的时候要用到）        }}\n\nDFS 题目讲解状态搜索代表： N 皇后问题题目链接\n难度: 简单\n标签: DFS\n题目描述:\n在  的方格棋盘放置了  个皇后，使得它们不相互攻击（即任意  个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成  角的斜线上。你的任务是，对于给定的 ，求出有多少种合法的放置方法。\n输入描述:\n输入中有一个正整数 ，表示棋盘和皇后的数量\n输出描述:\n为一个正整数，表示对应输入行的皇后的不同放置数量。\n输入输出样例:\n示例:\n输入:\n5\n\n输出:\n10\n\n运行限制:\n最大运行时间：1s 最大运行内存: 256M\n\n解题思路:\n下面是用递归的深度优先搜索求解  皇后问题的算法描述：\n这里用一个  的矩阵来表示棋盘，但是我们不需要定义这样的数组，只要心中有  的期盼即可。\n\n算法开始：\n当前行设为第一行，当前列设为第一列，从第一行第一列开始搜索，即只能让皇后从第一行放到第  行。\n这样在每次判断是否满足情况时我们不用去判断是否皇后在相同行。\n我们只用判断之前的  到  个皇后的位置和当前第  个皇后的位置是否属于同一列或者斜线，判断是否同一列。\n\n判断边界：\n在当前行，当前列的位置上判断是否满足条件(即保证经过这一点的行,列与斜线上都没有两个皇后)，若不满足，跳到第  步，即不符合边界条件。\n首先说一下，什么叫不符合边界条件，不只是跳出了搜索范围，剪枝也可以从这里开始，比如这里不满足条件，向下继续搜索也不会再有结果。\n这可以理解为超出边界的剪枝，我们的边界只得可能存在解的范围，这里已经超出有解的范围，必然要被踢出。\n判断条件：\n我们用数组  来表示第  个皇后的位置在第  行第  列，我们不用考虑是否在同一行的问题你，我们只用判断之前的  到  个皇后的位置和当前第  个皇后的位置是否属于同一列或者斜线。\n判断是否属于同一列： 就判断  是否等于 ; 判断是否属于同一斜线：等同于判断行之差是否等于列之差也，即 。\n\n搜索过程：\n调用 Check 函数。\n如果 边界条件，就继续调用放下一个皇后的位置\n\nCheck 函数:\n如果当搜索到第  行的时候，即代表前  行已经搜索完了，所以这个时候正好求出了一个解，记录加一。\n\n在当前位置上不满足条件的情形，进行回溯。\n\n\nC++ 语言描述:\n#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int x[15] = {0};int sum,n;int PD(int k){    for(int i=1; i&lt;k; i++)    {        if(abs(k-i)==abs(x[k]-x[i]))            return 0;        else if (x[k]==x[i])            return 0;        //即判断是否符合条件来放,i表示皇后所在的行数，x[i]表示所在的列数，        //所以前面那个条件用来判断两个皇后是否在对角线上,后面用来判断是否在同一列上。        //行数不需要判断，因为他们本身的i就代表的是行数    }    return 1;}bool check(int a){    if(a&gt;n)        sum++;    else        return 0;    return 1;}void DFS(int a){    if(check(a))        return ;    else        for(int i=1; i&lt;=n; i++)        {            x[a]=i;                //第a个皇后放的列数            if(PD(a))                    //判断是否能放这步                DFS(a+1);                    //能的话进行下一个皇后的放置            else continue ;                    //不能就下一列        }}int main(){    cin&gt;&gt;n;    //表示几个皇后    DFS(1);    //每次都从第一个皇后开始    cout&lt;&lt;sum&lt;&lt;endl;    return 0;}\n\nPython 语言描述：\n x = [0] * 15n = 0sum = 0def pd(k):    for i in range(1, k):        if abs(k - i) == abs(x[k] - x[i]):            return 0        elif x[k] == x[i]:            return 0        # 即判断是否符合条件来放,i表示皇后所在的行数，x[i]表示所在的列数，        # 所以前面那个条件用来判断两个皇后是否在对角线上,后面用来判断是否在同一列上。        # 行数不需要判断，因为他们本身的i就代表的是行数    return 1def check(a):    if a &gt; n:        global sum        sum += 1    else:        return False    return Truedef DFS(a):    if check(a):        return    else:        for i in range(1, n + 1):            x[a] = i            # 第a个皇后放的列数            if pd(a):                # 判断是否能放这步                DFS(a + 1)                # 能的话进行下一个皇后的放置            else:                continue                #   不能就下一列if __name__ == '__main__':    n = int(input())    # 不能就下一列    DFS(1)    # 每次都从第一个皇后开始    print(sum)\n\nJava 语言描述:\nimport java.util.Scanner;import static java.lang.Math.abs;public class Main {    static int x[] = new int[15];    static int sum, n;    static boolean PD(int k) {        for (int i = 1; i &lt; k; i++) {            if (abs(k - i) == abs(x[k] - x[i]))                return false;            else if (x[k] == x[i])                return false;            //即判断是否符合条件来放,i表示皇后所在的行数，x[i]表示所在的列数，            //所以前面那个条件用来判断两个皇后是否在对角线上,后面用来判断是否在同一列上。            //行数不需要判断，因为他们本身的i就代表的是行数        }        return true;    }    static boolean check(int a) {        if (a &gt; n)            sum++;        else            return false;        return true;    }    static void DFS(int a) {        if (check(a))            return;        else            for (int i = 1; i &lt;= n; i++) {                x[a] = i;                //第a个皇后放的列数                if (PD(a))                    //判断是否能放这步                    DFS(a + 1);                    //能的话进行下一个皇后的放置                else continue;                //不能就下一列            }    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        n = in.nextInt();        //表示几个皇后        DFS(1);        //每次都从第一个皇后开始        System.out.println(sum);    }}\n\n图的路径搜索代表-路径之谜题目链接\n难度: 中等\n标签: DFS, 2016, 国赛\n题目描述:\n小明冒充  星球的骑士，进入了一个奇怪的城堡。\n城堡里边什么都没有，只有方形石头铺成的地面。\n假设城堡地面是  个方格。如下图所示。\n\n按习俗，骑士要从西北角走到东南角。可以横向或纵向移动，但不能斜着走，也不能跳跃。每走到一个新方格，就要向正北方和正西方各射一箭。（城堡的西墙和北墙内各有  个靶子）同一个方格只允许经过一次。但不必走完所有的方格。如果只给出靶子上箭的数目，你能推断出骑士的行走路线吗？有时是可以的，比如上图中的例子。\n本题的要求就是已知箭靶数字，求骑士的行走路径（测试数据保证路径唯一）\n输入:\n第一行一个整数  ()，表示地面有  个方格。\n第二行  个整数，空格分开，表示北边的箭靶上的数字（自西向东）\n第三行  个整数，空格分开，表示西边的箭靶上的数字（自北向南）\n输出：\n输出一行若干个整数，表示骑士路径。\n为了方便表示，我们约定每个小格子用一个数字代表，从西北角开始编号: 0,1,2,3 \n输入输出样例：\n输入\n42 4 3 44 3 3 3\n\n比如，上图中的方块编号为：\n\n\n\n箭靶\n2\n4\n3\n4\n\n\n\n4\n0\n1\n2\n3\n\n\n3\n4\n5\n6\n7\n\n\n3\n8\n9\n10\n11\n\n\n3\n12\n13\n14\n15\n\n\n输出\n0 4 5 1 2 3 7 11 10 9 13 14 15\n\n运行限制:\n最大运行时间：1s 最大运行内存: 128M\n\n解题思路:\n这里用一个  的矩阵来表示城堡的位置，横向、纵向标号 。\n我们采用逆推法，既然原题目是走到哪里射一支箭，那我们就走到那里之后拔一支箭，如果最后得到所有的靶子上都没有箭了，由于题目的路径唯一，那就证明我们找到了题目所要求的路径。\n\n算法开始：\n当前行设为第一行，当前列设为第一列，从第一行第一列开始搜索。\n然后从左上角初始位置，按照题目意思进行寻路。\n\n判断边界：\n在当前行，当前列的位置上判断是否满足条件，若不满足，跳到第  步，即不符合边界条件。 判断条件如下：\n\n==1 标记数组已经被标记,已被走过，不能再走，超出边界\n 从左侧走出方格。\n 从右侧走出方格。\n 从上侧走出方格。\n 从下侧走出方格。\n 没走到右下角，箭用完了。\n 没走到右下角，箭用完了\n\n\n搜索过程：\n调用 Check 函数。 如果边界条件满足，就继续调用搜索，找到下一步的位置\n\ncheck(参数):\n如果当搜索到  时，且靶子上的箭都没了，按就找到了答案。\n按照题目输出即可。\n\n在当前位置上不满足条件的情形，进行回溯，并还原现场\n\n\nC++ 语言描述:\n#include &lt;bits/stdc++.h&gt;using namespace std;struct PII{    int first;    int second;};const int N = 30;int rol[N];int col[N];int n;//格子数 长宽从1到nbool flag[N][N]; //用来标记是否走过vector&lt;PII&gt; res;//---------图的路径搜索常用方向移动表示-------int dx[4]= {0,1,-1,0};int dy[4]= {1,0,0,-1};// 两两组合形成上下左右四个方向//      1------------------&gt; x//      |//      |//      |//      |//      |//      |//      |//      ↓//      y// dx[0]=0 dy[0]=1 那么代表向下的方向// dx[1]=1 dy[1]=0 那么代表向右的方向// dx[2]=-1 dy[0]=0 那么代表向左的方向// dx[3]=0 dy[1]=-1 那么代表向上的方向//--------------------------------------------bool  check(int x, int y) //判断走过的路径的箭靶数是否与目标相同{    if(x==n &amp;&amp; y==n)    {        for(int i=1; i&lt;=n; i++)        {            if(col[i]!=0)            {                return false;            }            //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果        }        for(int i=1; i&lt;=n; i++)        {            if(rol[i]!=0)            {                return false;            }            //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果        }        for(int i=0; i&lt;res.size(); i++)        {            int x=res[i].first;            //x 轴坐标            int y=res[i].second;            //y 轴坐标            int sum=n*(x-1)+y-1 ;            // 通过计算的到为题目要求的坐标系            cout &lt;&lt;sum&lt;&lt; \" \";        }        cout &lt;&lt; endl;        return false;        // 成功终止    }    return true; //继续搜索    //关于终止还是继续我们交给判定即可}bool pd(int x2,int y2) //边界判断{    if(flag[x2][y2]==1)        return 0;    //已被走过，不能再走，超出边界    else if(x2&lt;1)        return 0;    //从左侧走出方格    else if(x2&gt;n)        return 0;    //从右侧走出方格    else if(y2&lt;1)        return 0;    //从上侧走出方格    else if(y2&gt;n)        return 0;    //从下侧走出方格    else if(col[x2]&lt;=0)        return 0;    //没走到右下角，箭用完了    else if(rol[y2]&lt;=0)        return 0;    //没走到右下角，箭用完了    else return 1;    //符合边界条件，可以继续执行搜索}void dfs(int x,int y){    if(!check(x,y))    {        return ;        //包含不符合规则的地方，回溯，用于剪枝    }    else    {        for(int i=0; i&lt;4; i++)        {            int xt=dx[i]+x;            int yt=dy[i]+y;            if(!pd(xt,yt))            {                continue ;                //不符合要求继续换方向搜索            }            else            {                //因为要进行位置转移，我们给它起个名字，叫作案现场                //比如向下移动                flag[xt][yt]=true;                col[xt]--;                rol[yt]--;                res.push_back({xt,yt});                dfs(xt,yt);                //搜索回溯后，因为没有找到正确答案，所以要回复作案现场，返回到搜索之前                res.pop_back();                flag[xt][yt]=false;                col[xt]++;                rol[yt]++;            }        }    }}int main(){    cin &gt;&gt; n;    for(int i=1; i&lt;=n; i++)        cin &gt;&gt; rol[i];    for(int i=1; i&lt;=n; i++)        cin &gt;&gt; col[i];    flag[1][1]=true;    col[1]--;    rol[1]--;    res.push_back({1,1});    dfs(1,1);    return 0;}\n\nPython 语言描述:\nn = 0flag = [[0 for i in range(26)] for i in range(27)]resX = [0 for i in range(1000)]resY = [0 for i in range(1000)]resCount = 0# ---------图的路径搜索常用方向移动表示-------dx = [0, 1, -1, 0]dy = [1, 0, 0, -1]# 两两组合形成上下左右四个方向#      1------------------&gt; x#      |#      |#      |#      |#      |#      |#      |#      ↓#      y# dx[0]=0 dy[0]=1 那么代表向下的方向# dx[1]=1 dy[1]=0 那么代表向右的方向# dx[2]=-1 dy[0]=0 那么代表向左的方向# dx[3]=0 dy[1]=-1 那么代表向上的方向# --------------------------------------------def check(x, y):    global n    if x == n &amp; y == n:        # print(\"check point1\")        for i in range(1, n + 1):            if (col[i] != 0):                return False                # 如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果        for i in range(1, n + 1):            if (rol[i] != 0):                return False        for i in range(0, resCount):            x2 = resX[i]            # x 轴坐标            y2 = resY[i]            # y 轴坐标            sum = n * (x2 - 1) + y2 - 1            # 通过计算的到为题目要求的坐标系            print(sum, end=\" \")        return False        # 成功终止    else:        return True  # 继续搜索        # 关于终止还是继续我们交给判定即可def pd(x2, y2):    global n    # print(\"x2 :\", x2,\"y2 :\", y2, \" n \", n)    if flag[x2][y2] == 1:        # print(\"checkPoint3\")        return False        # 已被走过，不能再走，超出边界    elif x2 &lt; 1:        # print(\"checkPoint5\")        return False    # 从左侧走出方格    elif x2 &gt; n:        # print(\"checkPoint6\")        return False    # 从右侧走出方格    elif col[x2] &lt;= 0:        # print(\"checkPoint8\")        return False    # 没走到右下角，箭用完了    elif y2 &lt; 1:        # print(\"checkPoint7\")        return False    # 从上侧走出方格    elif y2 &gt; n:        # print(\"y2 :\",y2,\" n \",n)        return False    # 从下侧走出方格    elif rol[y2] &lt;= 0:        # print(\"checkPoint9\")        return False    # 没走到右下角，箭用完了    else:        return True# 符合边界条件，可以继续执行搜索def dfs(x, y):    if not check(x, y):        return    # 包含不符合规则的地方，回溯，用于剪枝    else:        for i in range(0, 4):            xt = dx[i] + x            yt = dy[i] + y            # print(xt, yt)            if not pd(xt, yt):                # print(\"CheckPoint\", xt, yt)                continue                # 不符合要求继续换方向搜索            else:                # 因为要进行位置转移，我们给它起个名字，叫作案现场                # 比如向下移动                col[xt] -= 1                rol[yt] -= 1                flag[xt][yt] = 1                global resCount                resX[resCount] = xt                resY[resCount] = yt                resCount += 1                # print(\"---------123-------\")                # print(flag)                # print(\"----------------\")                dfs(xt, yt)                # 搜索回溯后，因为没有找到正确答案，所以要回复作案现场，返回到搜索之前                resCount -= 1                flag[xt][yt] = 0                # print(\"--------321--------\")                # print(flag)                # print(\"----------------\")                col[xt] += 1                rol[yt] += 1if __name__ == '__main__':    n = int(input())    # print(\"----------------\")    # print(flag)    # print(\"----------------\")    rol = input().split()    rol = list(map(int, rol))    rol = [0] + rol    col = input().split()    col = list(map(int, col))    col = [0] + col    flag[1][1] = 1    # print(\"----------------\")    # print(flag)    # print(\"----------------\")    col[1] -= 1    rol[1] -= 1    resX[resCount] = 1    resY[resCount] = 1    resCount += 1    dfs(1, 1)\n\n然而需要注意的是上面代码会超时，我们要对其进行优化，因为同样的计算 Python 运行时间相比 C++ 要长很多，这里给 C++ 和 Python 相同的时间，确实是难为 Python 了。 因为上面是为了给大家系统的将一个框架，而这道题目的时间复杂度相对较高，Python 的运行时间是 C++ 10 倍甚至几十倍，这个题目，同样的复杂度，Python 给的时间是不好通过这个题目的，我优化了十几遍，确实通过不了。\nJava 语言描述:\nimport java.util.Scanner;import java.util.Vector;import static java.lang.Math.abs;public class Main {    static final int N = 30;    static int rol[]=new int [N];    static int col[]=new int [N];    static int n;//格子数 长宽从1到n    static  boolean flag[][]=new boolean[N][N]; //用来标记是否走过    static int resX[]=new int [1000];    static int resY[]=new int [1000];    static int resCount=0;//---------图的路径搜索常用方向移动表示-------    static int dx[]= {0,1,-1,0};    static  int dy[]= {1,0,0,-1};// 两两组合形成上下左右四个方向//      1------------------&gt; x//      |//      |//      |//      |//      |//      |//      |//      ↓//      y// dx[0]=0 dy[0]=1 那么代表向下的方向// dx[1]=1 dy[1]=0 那么代表向右的方向// dx[2]=-1 dy[0]=0 那么代表向左的方向// dx[3]=0 dy[1]=-1 那么代表向上的方向//--------------------------------------------    static boolean  check(int x, int y) //判断走过的路径的箭靶数是否与目标相同    {        if(x==n &amp;&amp; y==n)        {            for(int i=1; i&lt;=n; i++)            {                if(col[i]!=0)                {                    return false;                }                //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果            }            for(int i=1; i&lt;=n; i++)            {                if(rol[i]!=0)                {                    return false;                }                //如果箭靶上的数目不为0，根据逆推，我们通过当前路径得不到箭靶上的结果            }            for(int i=0; i&lt;resCount; i++)            {                int x2= resX[i];                //x 轴坐标                int y2=resY[i];                //y 轴坐标                int sum=n*(x2-1)+y2-1 ;                // 通过计算的到为题目要求的坐标系                System.out.print(sum+\" \");            }            System.out.println();            return false;            // 成功终止        }        return true; //继续搜索        //关于终止还是继续我们交给判定即可    }    static boolean pd(int x2,int y2) //边界判断    {        if(flag[x2][y2] )            return false;            //已被走过，不能再走，超出边界        else if(x2&lt;1)            return false;            //从左侧走出方格        else if(x2&gt;n)            return false;            //从右侧走出方格        else if(y2&lt;1)            return false;            //从上侧走出方格        else if(y2&gt;n)            return false;            //从下侧走出方格        else if(col[x2]&lt;=0)            return false;            //没走到右下角，箭用完了        else if(rol[y2]&lt;=0)            return false;            //没走到右下角，箭用完了        else return true;        //符合边界条件，可以继续执行搜索    }    static void dfs(int x,int y)    {        if(!check(x,y))        {            return ;            //包含不符合规则的地方，回溯，用于剪枝        }        else        {            for(int i=0; i&lt;4; i++)            {                int xt=dx[i]+x;                int yt=dy[i]+y;                if(!pd(xt,yt))                {                    continue ;                    //不符合要求继续换方向搜索                }                else                {                    //因为要进行位置转移，我们给它起个名字，叫作案现场                    //比如向下移动                    flag[xt][yt]=true;                    col[xt]--;                    rol[yt]--;                    resX[resCount]=xt;                    resY[resCount++]=yt;                    dfs(xt,yt);                    //搜索回溯后，因为没有找到正确答案，所以要回复作案现场，返回到搜索之前                    resCount--;                    flag[xt][yt]=false;                    col[xt]++;                    rol[yt]++;                }            }        }    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        n = in.nextInt();        for(int i=1; i&lt;=n; i++)            rol[i]=in.nextInt();        for(int i=1; i&lt;=n; i++)             col[i]=in.nextInt();        flag[1][1]=true;        col[1]--;        rol[1]--;        resX[resCount]=1;        resY[resCount++]=1;        dfs(1,1);    }}\n\n最大数字给定一个正整数  。你可以对  的任意一位数字执行任意次以下  种操 作：\n\n将该位数字加  。如果该位数字已经是  , 加  之后变成  。\n\n将该位数字减  。如果该位数字已经是  , 减  之后变成  。\n\n\n你现在总共可以执行  号操作不超过  次,  号操作不超过  次。 请问你最大可以将  变成多少?\n解题思路:\n看上去  的范围貌似很大，达到了 1e17 的范围，但其实我们最多只需要考虑这最多 17 位数，所以可以想到爆搜得到答案。\n一个数的大小是从左到右依次判断，所以我们从最左边开始枚举，我们无需关注后面的数，要利用自己的 1 号操作和 2 号操作 保证当前这个数位的数一定要尽可能最大\n然后分别考虑两种操作，首先两种操作不可能混用，因为它们是抵消的效果，所以要么对这个数全使用 1 操作，要么 2 操作。假设某个数位的值为 x,首先考虑 1 号操作，使用后可以让该数位变大，出于贪心考虑，我们想让它变成 9，那么需要进行 9-x 次 1 号操作，当然可能此时 1 号操作并不足以让我们将 x 变成 9，但我们还是使用剩余的全部的次数将其变大，所以每次考虑 1 号操作应该使用的操作数 t 应该为 t=min(n,9-x),此时 x 将变为 x+t，然后进行下一位的判断。\n其次我们考虑 2 号操作，这个的判断比较简单，它是让某个值减小，唯一能让某个数变大的机会就是将其减到 0 后再减就会变成 9。那么这样操作需要的次数就是 x+1，如果操作次数不够，那我们宁愿不使用，因为这只会让这个数位变得更小。\n在深搜 dfs 的过程中，参数记录遍历到第几个数位以及此时累计的和，当搜索完所有数位后，将此时的和与答案进行一个取 max，最后的值则为答案。\nC++ 语言描述：\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;char c[20];LL ans=0;//n:1号操作剩余次数  m:2号操作剩余次数int n,m;void dfs(int i,LL v){    int x=c[i]-'0';    if(c[i]){        //应该使用的操作次数        int t=min(n,9-x);        n-=t;        dfs(i+1,v*10+x+t);        //回溯        n+=t;        //考虑操作2是否能够使用        if(m&gt;x){            m-=x+1;            dfs(i+1,v*10+9);            //回溯            m+=x+1;        }    }else{        //答案取max        ans=max(ans,v);    }}int main(){    scanf(\"%s%d%d\",c,&amp;n,&amp;m);    dfs(0,0);    printf(\"%lld\\n\",ans);    return 0;}\n\nJava 语言描述:\nimport java.io.*;public class Main {    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));    static String t;    static int a, b, m;    static long ans = 0;    // i 表示考虑到第i位  v表示当前的值是多少    static void dfs(int i, long v) {        if (i == m) {            ans = Math.max(ans, v);            return;        }        int c = t.charAt(i) - '0';        //考虑第一种使用        int g = Math.min(a, 9 - c);        a -= g;        dfs(i + 1, v * 10 + c + g);        //回溯        a += g;        //考虑第二种使用   我一定要减到9  只有b&gt;c 才能减到9        if (b &gt; c) {            b -= c + 1;            dfs(i + 1, v * 10 + 9);            //回溯            b += c + 1;        }    }    public static void main(String[] args) throws IOException {        String[] s = br.readLine().trim().split(\" \");        t = s[0];        m = t.length();        a = Integer.parseInt(s[1]);        b = Integer.parseInt(s[2]);        dfs(0, 0);        out.println(ans);        out.flush();    }}\n\nPython 语言描述:\nimport syst = \"\"a = 0b = 0m = 0ans = 0def dfs(i, v):    global ans, a, b, t    if i == m:        ans = max(ans, v)        return    c = int(t[i])    # 考虑第一种使用    g = min(a, 9 - c)    a -= g    dfs(i + 1, v * 10 + c + g)    # 回溯    a += g    # 考虑第二种使用   我一定要减到9  只有b&gt;c 才能减到9    if b &gt; c:        b -= c + 1        dfs(i + 1, v * 10 + 9)        # 回溯        b += c + 1def main():    global ans, a, b, t, m    line = sys.stdin.readline().strip()    s = line.split()    t = s[0]    m = len(t)    a = int(s[1])    b = int(s[2])    dfs(0, 0)    print(ans)if __name__ == \"__main__\":    main()\n\n实验总结DFS 是一种非常重要的回溯算法，它是通过递归设计转移状态，再加上边界判断，与结果检查，构成的基本搜索框架。\nDFS 最重要的就是设计回溯，所谓回溯就是还原现场，保证在执行另一分支的时候能够确保所有的改变只受当前状态的影响，所以在一条路走不通时就要修改。特殊的修改可以达到特殊的回溯效果，回溯时剪枝，回溯时调整路线，都是可以的。\nDFS 是算法学习的基础工具，很重要，必须要学会。\n\nshow: step version: 1.0 enable_checker: true\n\n广度优先搜索BFS，其英文全称是 Breadth First Search，意为广度优先搜索，是所有的搜索手段之一。它是从某个状态开始，将所有节点加入一个先进先出的队列，然后一层一层进行状态转移，并且展开节点。\n本章题目难度较大，请大家仔细研读讲解和代码。\n知识点1.BFS 算法设计原理与实现方法 2.经典题型精讲\n广度优先搜索基本概念作为搜索算法的一种，BFS 相较于 DFS 而言，BFS 是一层一层展开的，那么对于有多个终态时，最先找到的一定是最短的。\n广度优先搜索算法的设计步骤按照定义设计：\n\n确定该题目的状态（包括边界）\n\n找到状态转移方式\n\n找到问题的出口，计数或者某个状态\n\n设计搜索\n\n\n会发现我们前期要找到的参数基本一致，所以在一般情况下 BFS 和 DFS 可以相互转换。\n伪代码：\nint check(参数){    if(满足条件)        return 1;    return 0;}bool pd(参数){    相应操作}void bfs(){    1. 把根节点放入队列尾端    2. 每次从队列中取出一个节点    3. Check 判断是不是答案，如果是结束算法 return;    4. 把当前取出的节点扩展，如果扩展后的节点经Pd()后符合要求，就放入队列，不符合就不放。    5. 转到步骤2，循环执行}如果所有节点被扩展完了，没有找到答案就无解。\n\n长草题目链接\n难度: 简单\n标签: 模拟, BFS, 2020, 省模拟赛\n题目描述:\n小明有一块空地，他将这块空地划分为  行  列的小块，每行和每列的长度都为 1。\n小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。\n这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，\n这四小块空地都将变为有草的小块。请告诉小明， 个月后空地上哪些地方有草。\n输入描述:\n输入的第一行包含两个整数 。\n接下来  行，每行包含  个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 ，表示种了草。\n接下来包含一个整数 。 其中，，。\n输出描述:\n输出  行，每行包含  个字母，表示  个月后空地的状态。如果为小数点，表示为空地，如果字母为 ，表示长了草。\n输入输出样例:\n示例:\n输入:\n4 5.g..........g.......2\n\n输出:\ngggg.gggg.ggggg.ggg.\n\n运行限制:\n最大运行时间：1s 最大运行内存: 256M\n\n解题思路:\n这个题目简直就是为了广度优先搜索设置模板题，由于这个题目时输出广度优先搜索 K 次扩展后的终态，那我们就不用设置 Check 函数。\n这里用一个  的矩阵来表示草地。\n\n算法开始：\n将字母为 g 的草地的位置加入队列，然后向下执行\n\n判断边界：\n判断是否已经长了草，判断是否超出边界范围\n\n搜索过程：\n不断从队列取出一个节点，进行上下左右的扩展，执行 2 判断边界，符合就放入队列，不符合就跳过。\n执行 K 次扩展，输出草地状态。\n\ncheck(参数)：\n这里不需要进行 Check\n\n\nC++ 语言描述:\n#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 1005;struct PII{    int first;    int second;};// C++ 有个数据类型叫 pair 上面的就可以定义为 pair&lt;int,int&gt; 用起来比较方便。PII tempPair;//临时结点char Map[M][M];//---------图的路径搜索常用方向移动表示-------int dx[4]= {0,1,-1,0};int dy[4]= {1,0,0,-1};// 两两组合形成上下左右四个方向//      1------------------&gt; x//      |//      |//      |//      |//      |//      |//      |//      ↓//      y// dx[0]=0 dy[0]=1 那么代表向下的方向// dx[1]=1 dy[1]=0 那么代表向右的方向// dx[2]=-1 dy[0]=0 那么代表向左的方向// dx[3]=0 dy[1]=-1 那么代表向上的方向int n;// n 行int m;// m 列int k;// k 次queue&lt;PII &gt; q; //广度优先搜索所用的队列int len;//记录节点数量方便后续k的计算bool pd(int x, int y){    if(x&lt;1)        return 0;    // /x 轴坐标 左侧越界    else if(x&gt;n)        return 0;    //x 轴坐标 右侧越界    else  if(y&lt;1)        return 0;    //y 轴坐标 上侧越界    else if(y&gt;m)        return 0;    //y 轴坐标 下侧越界    else if(Map[x][y]=='g')        return 0;    //已经长草了    else return 1;    // 在范围内，且没长草}void BFS(){    //BFS    while(!q.empty()&amp;&amp;k&gt;0)    {        tempPair = q.front();        q.pop();        //这两步是取出队首的节点        int x = tempPair.first;//横坐标        int y = tempPair.second;//纵坐标        for(int i=0; i&lt;4; i++)        {            int nowx = x+dx[i]; //扩展后的横坐标            int nowy = y+dy[i]; //扩展后的纵坐标            if(pd(nowx,nowy))            {                q.push({nowx,nowy});                Map[nowx][nowy]='g';            }            //符合要求执行扩展，不符合要求，忽略即可。        }        len--; //没取出一个节点len  -1        if(len==0)        {            //当len =0 时，代表当前层扩展完了，那么就代表第一个月扩展完了            k--; // 所以k--            len = q.size(); // 当前层扩展完了，那就该扩展下一层了，所以len又被赋值为下一层的节点数目的值        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1; i&lt;=n; i++)    {        for(int j=1; j&lt;=m; j++)        {            cin&gt;&gt;Map[i][j];            if(Map[i][j]=='g')            {                tempPair.first=i;                tempPair.second=j;               // cout&lt;&lt;i&lt;&lt;\"\"&lt;&lt;j&lt;&lt;endl;                q.push(tempPair);//将初始有树的结点加入队列            }        }    }    len = q.size();//记录第一层的节点数量方便后续k的计算    cin&gt;&gt;k;    BFS();    for(int i=1; i&lt;=n; i++)    {        for(int j=1; j&lt;=m; j++)        {            cout&lt;&lt;Map[i][j];        }        cout&lt;&lt;endl;    }    return 0;}\n\nPython 语言描述:\n# 请在此输入您的代码from queue import Queuedx = [0, 1, -1, 0]dy = [1, 0, 0, -1]# 两两组合形成上下左右四个方向#      1------------------&gt; x#      |#      |#      |#      |#      |#      |#      |#      ↓#      y# dx[0]=0 dy[0]=1 那么代表向下的方向# dx[1]=1 dy[1]=0 那么代表向右的方向# dx[2]=-1 dy[0]=0 那么代表向左的方向# dx[3]=0 dy[1]=-1 那么代表向上的方向Map = []q = Queue()n = 0m = 0k = 0length = 0def pd(x, y):    global n, m, Map    if x &lt; 0:        return False    # x 轴坐标左侧越界    elif x &gt;= n:        return False    # x 轴坐标右侧越界    elif y &lt; 0:        return False    # y轴坐标上侧越界    elif y &gt;= m:        return False    # y 轴坐标下侧越界    elif Map[x][y] == 'g':        return False    # 已经长草了    else:        return True    # 在范围内，且没长草def BFS():    global k, q, n, m, Map, length    while k &gt; 0 &amp; (not q.empty()):        tempPair = q.get()        x = tempPair[0]  # 横坐标        y = tempPair[1]  # 纵坐标        nowx=x+1        if (pd(nowx, y)):            q.put((nowx, y))            Map[nowx][y] = 'g'        nowx=x-1        if (pd(nowx, y)):            q.put((nowx, y))            Map[nowx][y] = 'g'        nowy=y+1        if (pd(x, nowy)):            q.put((nowx, nowy))            Map[x][nowy] = 'g'        nowy=y-1        if (pd(x, nowy)):            q.put((nowx, nowy))            Map[x][nowy] = 'g'        length -= 1        if length == 0:            k -= 1            length = q.qsize()if __name__ == '__main__':    n, m = map(int, input().split())    Map = [[0 for _ in range(m)] for _ in range(n)]  # Python 动态开数组会减少运行时间    for i in range(n):        input_ = input()        for j in range(m):            Map[i][j] = input_[j]            if Map[i][j] == 'g':                q.put((i, j))    k = int(input())    length = q.qsize()    BFS()    for i in range(n):        str_temp = ''        for j in range(m):            str_temp += Map[i][j]        print(str_temp)\n\n重点:\nPython 的 Queue 非常耗费时间，强烈建议大家使用 list 进行模拟\n下面是用 List 模拟，使用 Queue 耗时 3000 ms , 使用 list 模拟仅消耗 54 ms 所以大家使用 Python 编写代码的时候还是使用 List 尽量避免 Queue 的使用。\n# 请在此输入您的代码from queue import Queuedx = [0, 1, -1, 0]dy = [1, 0, 0, -1]# 两两组合形成上下左右四个方向#      1------------------&gt; x#      |#      |#      |#      |#      |#      |#      |#      ↓#      y# dx[0]=0 dy[0]=1 那么代表向下的方向# dx[1]=1 dy[1]=0 那么代表向右的方向# dx[2]=-1 dy[0]=0 那么代表向左的方向# dx[3]=0 dy[1]=-1 那么代表向上的方向Map = []q = []qfront = 0qend = 0n = 0m = 0k = 0length = 0def pd(x, y):    if x &lt; 0:        return False    # x 轴坐标左侧越界    elif x &gt;= n:        return False    # x 轴坐标右侧越界    elif y &lt; 0:        return False    # y轴坐标上侧越界    elif y &gt;= m:        return False    # y 轴坐标下侧越界    elif Map[x][y] == 'g':        return False    # 已经长草了    else:        return True    # 在范围内，且没长草def BFS():    global k, q, n, m, Map, length, qend, qfront    # print(\"K Length\", k, length)    while k &gt; 0 and length &gt; 0:        tempPair = q[qfront]        qfront += 1        x = tempPair[0]  # 横坐标        y = tempPair[1]  # 纵坐标        for i in range(4):            nowx = x + dx[i]  # 扩展后的横坐标            nowy = y + dy[i]  # 扩展后的纵坐标            if (pd(nowx, nowy)):                q.append((nowx,nowy))                qend += 1                Map[nowx][nowy] = 'g'        length -= 1        if length == 0:            k -= 1            length = qend - qfrontif __name__ == '__main__':    n, m = map(int, input().split())    Map = [[0 for _ in range(m)] for _ in range(n)]  # Python 动态开数组会减少运行时间    for i in range(n):        input_ = input()        for j in range(m):            Map[i][j] = input_[j]            if Map[i][j] == 'g':                q.append((i,j))                qend += 1    k = int(input())    length = qend - qfront    BFS()    for i in range(n):        str_temp = ''        for j in range(m):            str_temp += Map[i][j]        print(str_temp)\n\nJava 语言描述:\nimport java.util.*;import java.util.concurrent.LinkedBlockingQueue;import static java.lang.Math.abs;public class Main {    static final int M = 1005;    static class PII    {        public int first;        public int second;    };    static String Map[]=new String[M];//---------图的路径搜索常用方向移动表示-------    static int dx[]= {0,1,-1,0};    static  int dy[]= {1,0,0,-1};// 两两组合形成上下左右四个方向//      1------------------&gt; x//      |//      |//      |//      |//      |//      |//      |//      ↓//      y// dx[0]=0 dy[0]=1 那么代表向下的方向// dx[1]=1 dy[1]=0 那么代表向右的方向// dx[2]=-1 dy[0]=0 那么代表向左的方向// dx[3]=0 dy[1]=-1 那么代表向上的方向    static int n;// n 行    static int m;// m 列    static int k;// k 次    static Queue&lt;PII &gt; q= new LinkedBlockingQueue&lt;&gt;();    //广度优先搜索所用的队列    static int len;//记录节点数量方便后续k的计算    static boolean pd(int x, int y)    {        if(x&lt;1)            return false;            // /x 轴坐标 左侧越界        else if(x&gt;n)            return false;            //x 轴坐标 右侧越界        else  if(y&lt;1)            return false;            //y 轴坐标 上侧越界        else if(y&gt;m)            return false;            //y 轴坐标 下侧越界        else if(Map[x].charAt(y)=='g')            return false;            //已经长草了        else return true;        // 在范围内，且没长草    }    static void BFS()    {        //BFS        while(q.size()!=0&amp;&amp;k&gt;0)        {            PII tempPair= q.peek();            q.poll();            //这两步是取出队首的节点//            System.out.println(q.size());            int x = tempPair.first;//横坐标            int y = tempPair.second;//纵坐标            for(int i=0; i&lt;4; i++)            {                int nowx = x+dx[i]; //扩展后的横坐标                int nowy = y+dy[i]; //扩展后的纵坐标                if(pd(nowx,nowy))                {                    PII tempPair2=new PII();//临时结点                    tempPair2.first=nowx;                    tempPair2.second=nowy;                    q.add(tempPair2);                    StringBuilder strBuilder = new StringBuilder(Map[nowx]);                    strBuilder.setCharAt(nowy, 'g');                    Map[nowx]=strBuilder.toString();                }                //符合要求执行扩展，不符合要求，忽略即可。            }            len--; //没取出一个节点len  -1            if(len==0)            {                //当len =0 时，代表当前层扩展完了，那么就代表第一个月扩展完了                k--; // 所以k--                len = q.size(); // 当前层扩展完了，那就该扩展下一层了，所以len又被赋值为下一层的节点数目的值            }        }    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        n = in.nextInt();        m = in.nextInt();        for(int i=1; i&lt;=n; i++)        {            Map[i]=new String(\" \" +in.next());            for(int j=1; j&lt;=m; j++)            {                char temChar = Map[i].charAt(j);                if(temChar=='g')                {                    PII tempPair=new PII();//临时结点                    tempPair.first=i;                    tempPair.second=j;                    q.offer(tempPair);//将初始有草的结点加入队列                }            }        }        len = q.size();//记录第一层的节点数量方便后续k的计算        k= in.nextInt();        BFS();        for(int i=1; i&lt;=n; i++)        {            System.out.println(Map[i]);        }    }}\n\n走迷宫题目链接\n难度: 简单\n标签: BFS\n题目描述:\n给定一个  的网格迷宫 。 的每个格子要么是道路，要么是障碍物（道路用  表示，障碍物用  表示）。\n已知迷宫的入口位置为 ，出口位置为 。问从入口走到出口，最少要走多少个格子。\n输入:\n输入第  行包含两个正整数 ，分别表示迷宫的大小。\n接下来输入一个  的矩阵。若  表示其为道路，否则表示其为障碍物。\n最后一行输入四个整数 ，表示入口的位置和出口的位置。\n，，，。\n输出：\n输出仅一行，包含一个整数表示答案。\n若无法从入口到出口，则输出 。\n输入输出样例：\n输入\n5 51 0 1 1 01 1 0 1 10 1 0 1 11 1 1 1 11 0 0 0 11 1 5 5\n\n输出\n8\n\n运行限制:\n最大运行时间：1s 最大运行内存: 128M\n\n解题思路:\n\n算法开始：\n我们以起点开始做 BFS ，将入口压入栈开始执行 BFS 算法\n\n判断边界：\n在当前行，当前列的位置上判断是否满足条件，若不满足，跳到第 5 步，即不符合边界条件。 判断条件如下：\n\n &gt;= 1 标记数组已经被标记，已被走过，不能再走，超出边界\n\n 从左侧走出方格\n\n 从右侧走出方格\n\n 从上侧走出方格\n\n 从下侧走出方格\n\n != 1 没有路不能走\n\n\n\n搜索过程：\n调用 Check 函数。\n如果边界条件满足，就继续调用搜索，找到下一步的位置\n每次找到下一个位置的时候，令其  = 当前 \n这样既能用  数组标记又能使用  数组存步数，从  开始，即开始节点是  ，所以最后要减去  。\n\ncheck(参数)：\n如果当搜索到 终点, 终点 时，就找到了终点，此时他的  数组就存储了他的步数，但是是从  开始的。\n\n\nC++ 语言描述:\n#include &lt;bits/stdc++.h&gt;using namespace std;int vis[150][150]; //用于存储是否访问过，并且存储长度char G[150][150]; //用于存储题目给出的地图int n,m,ans=0;int dx[4] = {0,0,-1,1};int dy[4] = {1,-1,0,0};//上下左右移动，不会的看前面的代码struct node{    int x;    int y;};node Start,End;bool pd(int x,int y){    if(x&lt;1)        return 0;    //从左侧走出方格    else if(x&gt;n)        return 0;    //从右侧走出方格    else if(y&lt;1)        return 0;    //从上侧走出方格    else if(y&gt;m)        return 0;    //从下侧走出方格    else if( vis[x][y]!=0)        //已经访问了        return 0;    else if(G[x][y]!='1') return 0;    //不是路不能走    else return 1;}bool  check(int x, int y){    if(x == End.x&amp;&amp; y == End.y)   //找到终点，把距离给他    {        ans  =  vis[x][ y];        return 1;    }    else    return 0;}void bfs(){    queue&lt;node&gt;q;    node now,next;    q.push(Start);     //将起点压人队列中    vis[Start.x][Start.y] = 1;    while(!q.empty())    {        now = q.front();        if(check(now.x,now.y))            return ;        q.pop();     //将队列最前面的弹出。        for(int i=0; i&lt;4; i++)  //四个方向        {            int nextx = now.x + dx[i];            int nexty = now.y + dy[i];            if(pd(nextx,nexty))  //判断是否符合条件            {                next.x=nextx;                next.y=nexty;                q.push(next);                vis[nextx][nexty] = vis[now.x][now.y]+1; //步数+1            }        }    }}int main(){    cin&gt;&gt;n&gt;&gt;m;    //memset(vis,0,sizeof(vis));    for(int i=1; i&lt;=n; i++)    {        for(int j=1; j&lt;=m; j++)        {            cin&gt;&gt;G[i][j];        }    }    cin&gt;&gt;Start.x&gt;&gt;Start.y&gt;&gt;End.x&gt;&gt;End.y;    ans = 0;    bfs();    cout&lt;&lt;ans-1&lt;&lt;endl;    return 0;}\n\nPython 语言描述:\ndx = [0, 1, -1, 0]dy = [1, 0, 0, -1]G = []Vis = []# --------队列模拟-----------q = []                   # |                         # |qfront = 0               # |                         # |qend = 0                 # |# --------队列模拟-----------n = 0m = 0ans = 0startX=0startY=0endX=0endY=0def pd(x, y):    if x &lt; 1:        return False    # x 轴坐标左侧越界    elif x &gt; n:        return False    # x 轴坐标右侧越界    elif y &lt; 1:        return False    # y轴坐标上侧越界    elif y &gt; m:        return False    # y 轴坐标下侧越界    elif Vis[x][y]!=0:        return False    #已经访问了    elif G[x][y] != '1':        return False    # 已经访问了    else:        return True    # 在范围内，且没长草def check( x,  y):    global ans    if x == endX and y == endY :  #找到终点，把距离给他        ans  =  Vis[x][y];        return True;    else   :        return False;def BFS():    global qend ,qfront    q.append((startX,startY))    qend+=1    Vis[startX][startY]=1    while qend-qfront!=0:        tempPair = q[qfront]        qfront+=1        x = tempPair[0]  # 横坐标        y = tempPair[1]  # 纵坐标        if check(x,y):            return        for i in range(4):            nowx = x + dx[i]  # 扩展后的横坐标            nowy = y + dy[i]  # 扩展后的纵坐标            if (pd(nowx, nowy)):                q.append((nowx,nowy))                qend+=1                Vis[nowx][nowy] = Vis[x][ y] + 1if __name__ == '__main__':    n, m = map(int, input().split())    G = [[0 for _ in range(m+10)] for _ in range(n+10)]  # Python 动态开数组会减少运行时间    Vis = [[0 for _ in range(m+10)] for _ in range(n+10)]  # Python 动态开数组会减少运行时间    for i in range(n):        input_ = input().split()        for j in range(m):            G[i+1][j+1] = input_[j]    startX ,startY , endX ,endY = map(int, input().split())    BFS()    print(ans-1)\n\nJava 语言描述:\nimport java.util.*;import java.util.concurrent.LinkedBlockingQueue;import static java.lang.Math.abs;public class Main {    static final int M = 1005;    static class node {        public int x;        public int y;        public node(int x, int y) {            this.x = x;            this.y = y;        }    }    static int n, m, ans = 0;    static int vis[][] = new int[150][150]; //用于存储是否访问过，并且存储长度    static int G[][] = new int[150][150];  //用于存储题目给出的地图    static node Start, End;//---------图的路径搜索常用方向移动表示-------    static int dx[] = {0, 1, -1, 0};    static int dy[] = {1, 0, 0, -1};    static Queue&lt;node&gt; q = new LinkedBlockingQueue&lt;&gt;();    //广度优先搜索所用的队列    static boolean pd(int x, int y) {        if (x &lt; 1)            return false;            // /x 轴坐标 左侧越界        else if (x &gt; n)            return false;            //x 轴坐标 右侧越界        else if (y &lt; 1)            return false;            //y 轴坐标 上侧越界        else if (y &gt; m)            return false;            //y 轴坐标 下侧越界        else if (vis[x][y] != 0)            //已经访问了            return false;        else if (G[x][y] != 1)            //不能走            return false;        else return true;        // 在范围内，且没长草    }    static boolean check(int x, int y) {        if (x == End.x &amp;&amp; y == End.y)   //找到终点，把距离给他        {            ans = vis[x][y];            return true;        } else return false;    }    static void BFS() {        q.add(Start);        vis[Start.x][Start.y] = 1;        node now, next;        while (q.size() != 0) {            now = q.peek();            if (check(now.x, now.y))                return;            q.poll();            //这两步是取出队首的节点            for (int i = 0; i &lt; 4; i++)  //四个方向            {                int nextx = now.x + dx[i];                int nexty = now.y + dy[i];                if (pd(nextx, nexty))  //判断是否符合条件                {                    next = new node(nextx, nexty);                    q.add(next);                    vis[nextx][nexty] = vis[now.x][now.y] + 1; //步数+1                }            }        }    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        n = in.nextInt();        m = in.nextInt();        for (int i = 1; i &lt;= n; i++) {            for (int j = 1; j &lt;= m; j++) {                G[i][j] = in.nextInt();            }        }        int startX = in.nextInt();        int startY = in.nextInt();        int endX = in.nextInt();        int endY = in.nextInt();        Start=new node(startX,startY);        End=new node(endX,endY);        BFS();        System.out.println(ans-1);    }}\n\n迷宫下图给出了一个迷宫的平面图，其中标记为  的为障碍，标记为  的为可以通行的地方。\n010000000100001001110000\n\n迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这个它的上、下、左、右四个方向之一。\n对于上面的迷宫，从入口开始，可以按 DRRURRDDDR 的顺序通过迷宫， 一共  步。其中 、、、 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（ 行  列），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。\n请注意在字典序中 。\n010101010010110010010101100101101001000010001010100000100010000010101001000010000000100110011010010101111011010010001000001101001011100011000000010000010000000010101000110100001010000010101010110010110001111100000010100001001010001010000010110000000011001000110101000010101100011010011010101011110111000110110101010010010010100000010001010011100000001010000010100010011010101011111001100001000011101000111000001010100001100010000001000101001100001001110001101000011100100010010101010101010100011010000001000010010000010100101010111010001010101000010111100100101001001000010000010101010100100100010100000000100000001010110011110100011000001010101000111010101001110000100001100001011001111011010000100010101010100001101010100101000010100000111011101001100000001011000100001011001011010010111000000001001010100100000001010010000100010000010001111010100100101001010101101001010100011010101101110000110101110010100001000011000000101001010000010001110000100000100011000011010110100000010010100100100001110110100101000101000000001110110010110101101010100001001010000100001101010100001000100010010001000101011010000100011001000100001010100101010101111101001000000100101000000110010100101001000001000000000010110100000010011101110010010000111010010110111010000000011010001000100010000000100001110100000011001110101000101000100010001111100010101001010000001000100000101001010010101100000001001010100010111010000011110000100001000000011011100000000100000000101110000001100111010111010001000110111010101101111000\n\n解题思路:\n本题是一道简单的搜索题，需要注意的是要按照题目给定的字典序进行搜索，最后输出路径。\n我们使用  搜索记录路径，用  打印路径。\nC++ 语言描述：\n#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 2000string maze[maxn]= {                  \"01010101001011001001010110010110100100001000101010\",                  \"00001000100000101010010000100000001001100110100101\",                  \"01111011010010001000001101001011100011000000010000\",                  \"01000000001010100011010000101000001010101011001011\",                  \"00011111000000101000010010100010100000101100000000\",                  \"11001000110101000010101100011010011010101011110111\",                  \"00011011010101001001001010000001000101001110000000\",                  \"10100000101000100110101010111110011000010000111010\",                  \"00111000001010100001100010000001000101001100001001\",                  \"11000110100001110010001001010101010101010001101000\",                  \"00010000100100000101001010101110100010101010000101\",                  \"11100100101001001000010000010101010100100100010100\",                  \"00000010000000101011001111010001100000101010100011\",                  \"10101010011100001000011000010110011110110100001000\",                  \"10101010100001101010100101000010100000111011101001\",                  \"10000000101100010000101100101101001011100000000100\",                  \"10101001000000010100100001000100000100011110101001\",                  \"00101001010101101001010100011010101101110000110101\",                  \"11001010000100001100000010100101000001000111000010\",                  \"00001000110000110101101000000100101001001000011101\",                  \"10100101000101000000001110110010110101101010100001\",                  \"00101000010000110101010000100010001001000100010101\",                  \"10100001000110010001000010101001010101011111010010\",                  \"00000100101000000110010100101001000001000000000010\",                  \"11010000001001110111001001000011101001011011101000\",                  \"00000110100010001000100000001000011101000000110011\",                  \"10101000101000100010001111100010101001010000001000\",                  \"10000010100101001010110000000100101010001011101000\",                  \"00111100001000010000000110111000000001000000001011\",                  \"10000001100111010111010001000110111010101101111000\"};bool vis[maxn][maxn];//标记int dir[4][2]={{1,0},{0,-1},{0,1},{-1,0}};//D L R Ubool in(int x,int y){    return x&lt;30&amp;&amp;x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;y&lt;50;}struct node{    int x,y,d;    char pos;//存储D L R U};node father[maxn][maxn];//当前节点的父节点node now,nex;//指向当前和下一个位置void dfs(int x,int y)//递归打印{    if(x==0&amp;&amp;y==0)//找到起点开始正向打印路径        return;    else        dfs(father[x][y].x,father[x][y].y);    cout&lt;&lt;father[x][y].pos;}void bfs(int x,int y){    queue&lt;node&gt; q;    now.x=x;    now.y=y;    now.d=0;    q.push(now);    vis[x][y]=true;    while(!q.empty())    {        now=q.front();        q.pop();        for(int i=0;i&lt;4;i++)//走下左右上按字典序的四个方向        {            int tx=now.x+dir[i][0];            int ty=now.y+dir[i][1];            if(in(tx,ty)&amp;&amp;!vis[tx][ty]&amp;&amp;maze[tx][ty]!='1')//判断是否超出范围，是否用过，是否为1            {                vis[tx][ty]=true;//标记为用过                nex.x=tx;                nex.y=ty;                nex.d=now.d+1;                q.push(nex);//压入队列                father[tx][ty].x=now.x;//存储父节点坐标                father[tx][ty].y=now.y;                if(i==0)//存储路径                    father[tx][ty].pos='D';                else if(i==1)                    father[tx][ty].pos='L';                else if(i==2)                    father[tx][ty].pos='R';                else if(i==3)                    father[tx][ty].pos='U';            }        }    }}int main(){    bfs(0,0);    dfs(29,49);//打印路径    return 0;}\n\nJava 语言描述:\nimport java.util.*;public class Main {    private static String[] nn= {                  \"01010101001011001001010110010110100100001000101010\",                  \"00001000100000101010010000100000001001100110100101\",                  \"01111011010010001000001101001011100011000000010000\",                  \"01000000001010100011010000101000001010101011001011\",                  \"00011111000000101000010010100010100000101100000000\",                  \"11001000110101000010101100011010011010101011110111\",                  \"00011011010101001001001010000001000101001110000000\",                  \"10100000101000100110101010111110011000010000111010\",                  \"00111000001010100001100010000001000101001100001001\",                  \"11000110100001110010001001010101010101010001101000\",                  \"00010000100100000101001010101110100010101010000101\",                  \"11100100101001001000010000010101010100100100010100\",                  \"00000010000000101011001111010001100000101010100011\",                  \"10101010011100001000011000010110011110110100001000\",                  \"10101010100001101010100101000010100000111011101001\",                  \"10000000101100010000101100101101001011100000000100\",                  \"10101001000000010100100001000100000100011110101001\",                  \"00101001010101101001010100011010101101110000110101\",                  \"11001010000100001100000010100101000001000111000010\",                  \"00001000110000110101101000000100101001001000011101\",                  \"10100101000101000000001110110010110101101010100001\",                  \"00101000010000110101010000100010001001000100010101\",                  \"10100001000110010001000010101001010101011111010010\",                  \"00000100101000000110010100101001000001000000000010\",                  \"11010000001001110111001001000011101001011011101000\",                  \"00000110100010001000100000001000011101000000110011\",                  \"10101000101000100010001111100010101001010000001000\",                  \"10000010100101001010110000000100101010001011101000\",                  \"00111100001000010000000110111000000001000000001011\",                  \"10000001100111010111010001000110111010101101111000\"};    private static char[][] tu=new char[30][50];    private static int[][] dis=new int[30][50];    private static int[][] step= {{1,0},{0,-1},{0,1},{-1,0}};    private static char[] direction= {'D','L','R','U'};//    保存经过的每一个点位置信息，采用(x)*m+y的公式表示(x,y);x,y从0开始，位置也是从来开始。m:大于最长边的随便一个数//    起点:0;终点:29*50-49    private static Queue&lt;Integer&gt; location=new LinkedList&lt;Integer&gt;();//    广度优先遍历求每一个位置到终点的距离，并存放在dis中//    广度优先遍历寻找所有从终点到起点的路线    public static void bfs() {//x,y当前位置;        int x,y;//当前位置坐标        //不为空，继续循环        while(!location.isEmpty()) {            int l=location.poll();//获取当前位置的坐标            x=l/50;//获取当前位置x            y=l%50;//获取当前位置y            for(int i=0;i&lt;4;i++) {//探索四个方向                int xx=x+step[i][0];                int yy=y+step[i][1];                if(xx&gt;=0&amp;&amp;xx&lt;30&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;50&amp;&amp;tu[xx][yy]=='0'&amp;&amp;dis[xx][yy]==0) {                    dis[xx][yy]=dis[x][y]+1;//当前位置的距离+1等于本次探索位置的距离                    location.add(xx*50+yy);                    if(xx==0&amp;&amp;yy==0) {                        break;                    }                }            }        }    }//    深度优先遍历，从起点到终点    public static String dfs() {        dis[29][49]=0;//        起点        int x=0;        int y=0;        String route=\"\";        while(x!=29||y!=49) {            for(int i=0;i&lt;4;i++) {                int xx=x+step[i][0];                int yy=y+step[i][1];                if(xx&gt;=0&amp;&amp;xx&lt;30&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;50&amp;&amp;tu[xx][yy]=='0') {                    if(dis[x][y]==dis[xx][yy]+1) {                        x=xx;                        y=yy;                        route+=direction[i];                        break;                    }                }            }        }        return route;    }    public static void main(String[] args) {        long num=0;        for(int i=0;i&lt;30;i++) {            tu[i]=nn[i].toCharArray();        }        location.add(29*50+49);        bfs();        String route=dfs();        System.out.println(route);    }}\n\nPython 语言描述:\nfrom collections import dequen,m=30,50M=[[int(i) for i in input()]for j in range(n)]vis=[[0]*m for i in range(n)]go=[['']*m for i in range(n)]q=deque([(0,0)])vis[0][0]=1while q:    x,y=q.popleft()    if x==n-1 and y==m-1:        print(go[-1][-1])        break    for i,j,k in [[1,0,'D'],[0,-1,'L'],[0,1,'R'],[-1,0,'U']]:        a,b=x+i,y+j        if 0&lt;=a&lt;n and 0&lt;=b&lt;m and M[a][b]==0 and vis[a][b]==0:            vis[a][b]=1            q.append((a,b))            go[a][b]=go[x][y]+k\n\n实验总结BFS 是广度优先搜索，是将某节点所有的“枝蔓”加入搜索队列，然后去除队列的首部的节点，重复进行该动作，这样就能由开始状态“一圈一圈的查找”。 BFS 拥有一个性质，那么就是先找到的节点，所经过的步骤一定最短。它一般用于寻找在近的状态，也是一个非常基础的算法，希望大家认真学习。\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]简单数论","url":"/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA/","content":"1 模运算\n定义：模运算为 a 除以 m 的余数，记为 a mod m，有 a mod m = a % m。\n模运算是大数运算中的常用操作。\n如果一个数太大，无法直接输出，或者不需要直接输出，可以把它取模后，缩小数值再输出。\nPython 虽然能直接计算大数，不用担心数据溢出，但是大数乘法太耗时，所以也常用取模来缩小数值。\n一个简单应用，判断奇偶：a%2=0，a 是偶数；a%2=1，a 是奇数\n\n例题：刷题统计 2022 年第十三届省赛，lanqiaoOJ 题号 2098【问题描述】 小明决定从下周一开始努力刷题准备蓝桥杯竞赛。他计划周一至周五每天做 a 道题目，周六和周日每天做 b 道题目。请你帮小明计算，按照计划他将在第几天实现做题数大于等于 n 题？\n【输入格式】 输入一行包含三个整数 a, b 和 n。\n【输出格式】 输出一个整数代表天数。\n【评测用例规模与约定】 对于 50%的评测用例，1 ≤ a, b, n ≤ 106106；对于 100%的评测用例，1 ≤ a, b, n ≤ 10181018。\n题目解析求余数的简单题，利用求余，把计算复杂度降为 O(1)。\nC++ 代码：\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    ll a,b,n; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n;    ll week = a*5+b*2;     //每周做题    ll days = (n/week)*7;  //周数    n %= week;             //剩下的做题数    if(n&lt;=a*5) days += n/a+(n%a?1:0);  //在周一到周五内    else{                  //周六和周日        days += 5, n -= a*5;        days += n/b+(n%b?1:0);    }    cout&lt;&lt;days;    return 0;}\n\nJava 代码：\nimport java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        long a = sc.nextLong(), b = sc.nextLong(), n = sc.nextLong();        long week = a * 5 + b * 2;  //每周做题        long days = (n / week) * 7; //周数*7天        n %= week;                  //余下不够一周的做题数        if (n &lt;= a * 5)            days += n / a + (n % a != 0 ? 1 : 0); //在周一到周五内        else {                       //周六和周日            days += 5;            n -= a * 5;            days += n / b + (n % b != 0 ? 1 : 0);        }        System.out.println(days);        sc.close();    }}\n\nPython 代码：\na, b, n = map(int, input().split())week = a * 5 + b * 2  #每周做题days = (n // week) * 7  #天数n %= week  #余数if n &lt;= a * 5:    days += n // a + (n % a != 0)  #在周一到周五内else:  #周六和周日    days += 5    n -= a * 5    days += n // b + (n % b != 0)print(days)\n\n2 快速幂幂运算 an，当 n 很大时，如果一个个乘，时间是 O(n) 的，速度很慢，此时可以用快速幂，在 O(logn) 的时间内算出来。 快速幂的一个解法：分治法，算 a2，然后再算(a2) 2，…，一直算到 an，代码也容易写。\n\n标准的快速幂：用位运算实现。\n基于位运算的快速幂，原理是倍增。\n\n快速幂原理以 a11a11 为例说明如何用倍增法做快速幂。\n（1）幂次与二进制的关系。把 a11a11 分解成幂 a8、a2、a1a8、a2、a1 的乘积：a11=a8+2+1=a8×a2×a1a11=a8+2+1=a8×a2×a1。其中a1、a2、a4、a8…a1、a2、a4、a8…的幂次都是 2 的倍数，所有的幂 aiai 都是倍乘关系，逐级递推，代码： a *= a\n（2）幂次用二进制分解。如何把 11 分解为 8+2+1？利用数的二进制的特征，n = 1110 = 10112 = 23+21+20 = 8+2+1，把 n 按二进制处理就可以。\n（3）如何跳过那些没有的幂次？例如 1011 需要跳过 a4a4。做个判断，用二进制的位运算实现：\n\nn &amp; 1 取 n 的最后一位，并且判断这一位是否需要跳过。\nn &gt;&gt;= 1 把 n 右移一位，目的是把刚处理过的 n 的最后一位去掉。 幂运算的结果往往很大，一般会先取模再输出。 根据取模的性质有：an mod m=(a mod m)n mod manmodm=(amodm)nmodm\n\n例题：快速幂 lanqiaoOJ 题号 1514【题目描述】给定 b, p, k，求(bp) mod k。其中 2≤b, p, k≤109。 【输入描述】三个整数 b，p，k。 【输出描述】输出(bp) mod k。\n题目解析C++ 代码：\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;     //变量改用较大的long longll fastPow(ll a, ll n, ll mod){    ll ans = 1;    a %= mod;          //重要，防止下面的ans*a越界    while(n) {        if(n &amp; 1)   ans = (ans*a) % mod;   //取模        a = a*a % mod;                     //取模        n &gt;&gt;= 1;    }    return ans;}int main(){    ll b,p,k;    cin&gt;&gt;b&gt;&gt;p&gt;&gt;k;    cout &lt;&lt; fastPow(b,p,k);    return 0;}\n\nJava 代码：\nimport java.util.Scanner;public class Main {    static long fastPow(long a, long n, long mod) {        long ans = 1;        a %= mod;   //重要，防止下面的ans*a越界        while (n &gt; 0) {            if ((n &amp; 1) == 1) {                ans = (ans * a) % mod;  //取模            }            a = (a * a) % mod;  //取模            n &gt;&gt;= 1;        }        return ans;    }    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        long b = sc.nextLong(), p = sc.nextLong(), k = sc.nextLong();        System.out.println(fastPow(b, p, k));        sc.close();    }}\n\nPython 代码：\ndef fast_pow(a, n, mod):    ans = 1    a %= mod  #重要，防止下面的ans*a越界    while n &gt; 0:        if n &amp; 1 == 1:            ans = (ans * a) % mod  #取模        a = (a * a) % mod  #取模        n &gt;&gt;= 1    return ansb, p, k = map(int, input().split())print(fast_pow(b, p, k))\n\nGCD 定义、性质最大公约数 Greatest Common Divisor(GCD)：整数 a 和 b 的 GCD 是指能同时整除 a 和 b  的最大整数，记为 gcd(a, b)。由于-a 的因子和 a 的因子相同，因此 gcd(a, b) = gcd(|a|,  |b|)。编码时只关注正整数的最大公约数。 性质： （1）gcd(a, b) = gcd(a, a+b) = gcd(a, k·a+b) （2）gcd(ka, kb) = k·gcd(a, b) （3）定义多个整数的最大公约数：gcd(a, b, c) = gcd(gcd(a, b), c)。 （4）若 gcd(a, b) = d，则 gcd(a/d, b/d) = 1，即 a/d 与 b/d 互素。这个定理很重要。 （5）gcd(a+cb, b) = gcd(a, b)\nC++福利： c++函数 std::__gcd()，可以返回负数，可以带多个参数。\n#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    cout&lt;&lt;__gcd(15, 81)&lt;&lt;\"\\n\";    // 输出  3    cout&lt;&lt;__gcd(0, 44)&lt;&lt;\"\\n\";     // 输出  44    cout&lt;&lt;__gcd(0, 0)&lt;&lt;\"\\n\";      // 输出  0    cout&lt;&lt;__gcd(-6, -15)&lt;&lt;\"\\n\";   // 输出  -3    cout&lt;&lt;__gcd(-17,289)&lt;&lt;\"\\n\";   // 输出  -17    cout&lt;&lt;__gcd(17,-289)&lt;&lt;\"\\n\";   // 输出  17    return 0;}\n\n手写 GCD 代码手写 gcd 函数，常用欧几里得算法。 辗转相除法求 gcd： gcd(a, b) = gcd(b, a mod b) 这是最常用的方法，极为高效。 设 a &gt; b，辗转相除法的计算复杂度为O((log2a)3)O((log2a)3)。\n可输出负数，和库函数一样:\n#include&lt;bits/stdc++.h&gt;using namespace std;int gcd(int a, int b){     return b? gcd(b, a%b):a; }int main(){    cout&lt;&lt;gcd(15, 81)&lt;&lt;\"\\n\";    // 输出  3    cout&lt;&lt;gcd(0, 44)&lt;&lt;\"\\n\";     // 输出  44    cout&lt;&lt;gcd(0, 0)&lt;&lt;\"\\n\";      // 输出  0    cout&lt;&lt;gcd(-6, -15)&lt;&lt;\"\\n\";   // 输出  -3    cout&lt;&lt;gcd(-17,289)&lt;&lt;\"\\n\";   // 输出  -17    cout&lt;&lt;gcd(17,-289)&lt;&lt;\"\\n\";   // 输出  17    return 0;}// 或者使用如下编码方式：// int GCD(int a,int b)// {//     if(b==0)//         return a;//     return GCD(b,a%b);// }public class Main {    static int gcd(int a, int b) {        return b == 0 ? a : gcd(b, a % b);    }    public static void main(String[] args) {        System.out.println(gcd(15, 81));   // 输出  3        System.out.println(gcd(0, 44));    // 输出  44        System.out.println(gcd(0, 0));     // 输出  0        System.out.println(gcd(-6, -15));  // 输出  -3        System.out.println(gcd(-17, 289)); // 输出  17        System.out.println(gcd(17, -289)); // 输出  17    }}// 或者使用如下编码方式：// static int GCD(int a,int b)// {//     if(b==0)//         return a;//     return GCD(b,a%b);// }def gcd(a, b):    return a if b == 0 else gcd(b, a % b)print(gcd(15, 81))   # 输出  3print(gcd(0, 44))    # 输出  44print(gcd(0, 0))     # 输出  0print(gcd(-6, -15))  # 输出  -3print(gcd(-17, 289)) # 输出  17print(gcd(17, -289)) # 输出  17# 或者使用如下编码方式：# def GCD(a,b):#     if b==0:#         return a#     return GCD(b,a%b)\n\nLCM最小公倍数 LCM (the Least Common Multiple) 。· a 和 b 的最小公倍数 lcm(a,b)(a,b),从算术基本定理推理得到。 算术基本定理：任何大于 1 的正整数 n 都可以唯一分解为有限个素数的乘积：\nn=p1c1p2c2…pmcm\\rm{n}=\\rm{p}_1^{c1}\\rm{p}_2^{c2}\\ldots\\rm{p}m^{cm}n=p1c1p2c2…pmcm,其中c1c1 都是正整数，pi\\rm{p}{\\rm{i}}pi 都是素数且从小到大。\n推导 LCM： 设:a=p1c1p2c2…pmcm,b=p1f1p2f2…pmfm:a=p1c1p2c2…pmcm,b=p1f1p2f2…pmfm\n那么：gcd(a, b)=p1min⁡c1,f1p2min⁡c2,f2…pmmin⁡cm,fmb)=p1minc1,f1p2minc2,f2…pmmincm,fm\nIcm(a,b)=p1max⁡c1,f1p2max⁡c2,f2…pmmax⁡cm,fm(a,b)=p1maxc1,f1p2maxc2,f2…pmmaxcm,fm\n推出：gcd(a, b)lcm(a, b)=ab\n即：\nlcm(a,b):=:a∗b/gcd(a,b):=:a/gcd(a,:b)∗b.lcm(a,b):=:a∗b/gcd(a,b):=:a/gcd(a,:b)∗b.\nlcm()手写代码//c or c++int lcm(int a, int b){    //需要的时候把int改成long long   return a / gcd(a, b) * b;  //先做除法再做乘法，防止先做乘法溢出}# Pythondef lcm(a, b):    return a // gcd(a, b) * b  #先做除法再做乘法，防止先做乘法溢出//javastatic int lcm(int a, int b) {    return a / gcd(a, b) * b; //先做除法再做乘法，防止先做乘法溢出}\n\n核桃的数量 2013 年第四届省赛 lanqiaoOJ 题号 210【题目描述】小张是软件项目经理，他带领 3  个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是： 1.各组的核桃数量必须相同  2.各组内必须能平分核桃（当然是不能打碎的） 3.尽量提供满足 1, 2 条件的最小数量（节约闹革命嘛） 【输入格式】输入三个正整数 a, b, c，表示每个组正在加班的人数，用空格分开（a,b,c&lt; 30）【输出格式】输出一个正整数，表示每袋核桃的数量。\n题目解析简单题，答案就是三个数字的最小公倍数。\n#include&lt;bits/stdc++.h&gt;using namespace std;int lcm(int a, int b){ return a / __gcd(a, b) * b;}int main(){    int a,b,c;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;    int k = lcm(a,b);    cout&lt;&lt;lcm(k,c)&lt;&lt;endl;    return 0;}import java.util.Scanner;public class Main {    static int gcd(int a, int b) {        return b == 0 ? a : gcd(b, a % b);    }    static int lcm(int a, int b) {        return a / gcd(a, b) * b;    }    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int a = sc.nextInt();        int b = sc.nextInt();        int c = sc.nextInt();        int k = lcm(a, b);        System.out.println(lcm(k, c));        sc.close();    }}def gcd(a, b):    return a if b == 0 else gcd(b, a % b)def lcm(a, b):    return a // gcd(a, b) * ba, b, c = map(int, input().split())k = lcm(a, b)print(lcm(k, c))\n\n5 素数的判断素数定义：只能被 1 和自己整除的正整数。注：1 不是素数，最小素数是 2。\n判断一个数 n 是不是素数：当n≤1014n≤1014时，用试除法；n &gt; 1014 时，试除法不够用，需 要用高级算法，例如 Miller Rabin 算法。\n试除法： 用[2,n-1]内的所有数去试着除 n，如果都不能整除，就是素数。 优化：把[2,n-1]缩小到[2,n][2,n]。证明：若 n = axb, 设 a≤nn ,则 b≥nn,如果 a 是 n 的因子，说明 n 不是素数，b 不用再试且 b 一定也是。\nC++ 实现：#include &lt;iostream&gt;#include &lt;cmath&gt;bool is_prime(long long n){    if(n &lt;= 1)        return false; // 1不是素数    for(long long i = 2; i &lt;= sqrt(n); i++)        if(n % i == 0)            return false; // 能整除，不是素数    return true; // 全不能整除，是素数}int main() {    long long number = 29; // 例子：要检查是否为素数的数值    if (is_prime(number))        std::cout &lt;&lt; number &lt;&lt; \" 是素数。\" &lt;&lt; std::endl;    else        std::cout &lt;&lt; number &lt;&lt; \" 不是素数。\" &lt;&lt; std::endl;    return 0;}\n\nJava 实现：import java.util.Scanner;public class Main {    static boolean isPrime(long n) {        if (n &lt;= 1)            return false; // 1不是素数        for (long i = 2; i &lt;= Math.sqrt(n); i++)            if (n % i == 0)                return false; // 能整除，不是素数        return true; // 全不能整除，是素数    }    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        System.out.print(\"输入一个要检查是否为素数的数值：\");        long number = scanner.nextLong(); // 例子：要检查是否为素数的数值        if (isPrime(number))            System.out.println(number + \" 是素数。\");        else            System.out.println(number + \" 不是素数。\");    }}\n\nPython 实现：def is_prime(n):    if n &lt;= 1:        return False  # 1不是素数    for i in range(2, int(n ** 0.5) + 1):        if n % i == 0:            return False  # 能整除，不是素数    return True  # 全不能整除，是素数number = 29  # 例子：要检查是否为素数的数值if is_prime(number):    print(number, \"是素数。\")else:    print(number, \"不是素数。\")\n\n6 素数筛素数的筛选：给定 n，求 2~n 内所有的素数。 一个个地判断很慢，所以用“筛子”筛所有的整数，把非素数筛掉，剩下的就是素数。 常用两种筛法：埃氏筛、欧拉筛。\n埃氏筛:\n初始队列{2、3，4，5，6，7，8，9，10，11，12，13，…，n}，操作步骤： （1）输出最小的素数 2，筛掉 2 的倍数，得{2，3，4，5，6，7，8，9，10，11，12，13，…} （2）输出最小的素数 3，筛掉 3 的倍数，得{2，3，4，5，6，7，8，9，10，11，12，13，…} （3）输出最小的素数 5，筛掉 5 的倍数，得{2，3，4，5，6，7，8，9，10，11，12，13，…} 继续以上步骤，直到队列为空。\nC++ 实现：int primes[N],cnt;bool bprime[N];void getPrime(int n){    memset(bprime,false,sizeof(bprime));    bprime[0]=true;    bprime[1]=true;    for(int i=2;i&lt;=n;i++){        if(!bprime[i]){            prime[cnt++]=i;            for(LL j=i*2;j&lt;=n;j+=i)                bprime[j]=true;        }    }}\n\nJava 实现：int[] primes = new int[N];int cnt;boolean[] bprime = new boolean[N];void getPrimes(int n) {    Arrays.fill(bprime, false);    bprime[0] = true;    bprime[1] = true;    for (int i = 2; i &lt;= n; i++) {        if (!bprime[i]) {            primes[cnt++] = i;            for (int j = i * 2; j &lt;= n; j += i) {                bprime[j] = true;            }        }    }}\n\nPython 实现：primes = [0] * Ncnt = 0bprime = [False] * Ndef getPrimes(n):    global cnt, primes, bprime    bprime[0] = True    bprime[1] = True    for i in range(2, n+1):        if not bprime[i]:            primes[cnt] = i            cnt += 1            for j in range(i*2, n+1, i):                bprime[j] = True\n\n但是埃氏筛法的缺点：例如 6 会被 3 整除，6 会被 2 整除，会被筛两次，所以我们再给出欧氏线性筛法：\nC++ 实现：int primes[N],cnt;bool bPrime[N];void getPrimes(int n){    memset(bPrime,false,sizeof(bPrime));    for(int i=2;i&lt;=n;i++){        if(!bPrime[i])            primes[cnt++]=i;        for(int j=0;j&lt;cnt&amp;&amp;i*primes[j]&lt;n;j++){            bPrime[i*primes[j]]=true;            if(i%primes[j]==0)                break;        }    }}\n\nJava 实现：static int[] primes = new int[N], bPrime = new int[N];static int cnt;public static void getPrimes(int n) {    Arrays.fill(bPrime, 0, n + 1, 0);    for (int i = 2; i &lt;= n; i++) {        if (bPrime[i] == 0)            primes[cnt++] = i;        for (int j = 0; j &lt; cnt &amp;&amp; i * primes[j] &lt;= n; j++) {            bPrime[i * primes[j]] = 1;            if (i % primes[j] == 0)                break;        }    }}\n\nPython 实现：N = 1000005primes = [0] * Nbprime = [False] * Ncnt = 0def getPrimes(n: int):    global cnt    for i in range(2, n+1):        if not bprime[i]:            primes[cnt] = i            cnt += 1        j = 0        while j &lt; cnt and i * primes[j] &lt;= n:            bprime[i * primes[j]] = True            if i % primes[j] == 0:                break            j += 1\n\n例题：质数 lanqiaoOJ 题号 1557【题目描述】给定一个正整数 N，请你输出 N 以内（不包含 N）的质数以及质数的个数。 【输入描述】一个正整数 N，n&lt;1000 【输出描述】两行，第 1 行包含若干个素数，从小到大输出，用空格分开。第 2 行一个整数，表示素数个数。\n输入： 10\n输出： 2 3 5 7 4\n题目为模板题目，实现方式如下，其中：\n\nbprime[i]记录数 i 的状态，若 bprime [i]=1，表示它被筛掉，不是素数。\n用 primes[]存放素数，prime[0]是第一个素数 2。\nCnt 是素数个数计数\n\nC++ 实现：#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6;int primes[N],cnt;bool bprime[N]; //true表示被筛掉，不是素数void getPrimes(int n){ //埃氏筛，计算[2, n]内的素数        memset(bprime,false,sizeof(bprime));        bprime[0]=true;        bprime[1]=true;        for(int i=2;i&lt;=n;i++){            if(!bprime[i]){                primes[cnt++]=i;                for(int j=i*2;j&lt;=n;j+=i)                    bprime[j]=true;            }        }    }int main(){    int n;    cin &gt;&gt;n;    getPrimes(n-1);    for(int i=0;i&lt;cnt;i++)  cout &lt;&lt; primes[i]&lt;&lt;\" \";    cout &lt;&lt; endl;    cout &lt;&lt; cnt;}\n\nJava 实现：public class Main {    static final int N = 1000000;    static int[] primes = new int[N];    static boolean[] bprime = new boolean[N];    static int cnt;    public static void getPrimes(int n) {        bprime[0] = true;        bprime[1] = true;        for (int i = 2; i &lt;= n; i++) {            if (!bprime[i]) {                primes[cnt++] = i;                for (int j = i * 2; j &lt;= n; j += i) {                    bprime[j] = true;                }            }        }    }    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        getPrimes(n - 1);        for (int i = 0; i &lt; cnt; i++) {            System.out.print(primes[i] + \" \");        }        System.out.println();        System.out.println(cnt);    }}\n\nPython 实现：N = 10**6primes = []bprime = [False] * Ndef getPrimes(n):    global primes    global cnt    bprime[0] = True    bprime[1] = True    for i in range(2, n+1):        if not bprime[i]:            primes.append(i)            cnt += 1            for j in range(i*2, n+1, i):                bprime[j] = Truen = int(input())cnt = 0getPrimes(n-1)for p in primes:    print(p, end=' ')print()print(cnt)\n\n7 分解质因子任何一个正整数 n 都可以唯一地分解为有限个素数的乘积：n=p1c1p2c2…pmcmn=p1c1p2c2…pmcm,其中cici都是正整数，p*i 都是素数且从小到大。 分解质因子也可以用试除法。求 n 的质因子：\n\n第一步，求最小质因子p1p1。逐个检查从2到 nn 的所有素数，如果它能整除 n，就是最小质因子。然后连续用 p1p1除 n，目的是去掉 n 中的 p1p1,得到 n1n1。\n第二步，再找 n1n1的最小质因子。逐个检查从 p1p1 到 n1n1 的所有素数。从 p1p1开始试除， 是因为 n1n1没有比 p1p1小的素因子，而且 n1n1的因子也是 n 的因子。\n继续以上步骤，直到找到所有质因子。\n\n我们直接看一个例题：\n【题目描述】求出区间[a,b]中所有整数的质因数分解。 【输入描述】输入一行，包含 2 个整数 a，b。2&lt;=a&lt;=b&lt;=10000 【输出描述】每行输出一个数的分解，形如 k=a1×a2×a3×…，k 从小到大，a 从小到大。\n输入： 3 10\n输出： 3=34=2×25=56=2×37=78=2×2×29=3×310=2×53=34=2×25=56=2×37=78=2×2×29=3×310=2×5\n直接对每个数进行分解，然后打印出它的因数。\nC++ 实现：#include&lt;bits/stdc++.h&gt;using namespace std;int p[20];  //p[]记录因子，p[1]是最小因子。一个int数的质因子最多有10几个int c[40];  //c[i]记录第i个因子的个数。一个因子的个数最多有30几个int factor(int n){    int m = 0;    for(int i = 2; i &lt;= sqrt(n); i++)        if(n%i == 0){            p[++m] = i, c[m] = 0;            while(n%i == 0)            //把n中重复的因子去掉                n/=i, c[m]++;        }    if(n&gt;1)                           //没有被除尽，是素数        p[++m] = n, c[m] = 1;    return m;                         //共m个因子}int main(){    int a,b;   cin&gt;&gt;a&gt;&gt;b;    for(int i=a;i&lt;=b;i++){        int m = factor(i);        cout&lt;&lt;i&lt;&lt;\"=\";        for(int j=1;j&lt;=m;j++){ //第j个因子            for(int k=1;k&lt;=c[j];k++){    //第j个因子的个数                cout &lt;&lt;p[j];                if(k&lt;c[j]) cout &lt;&lt;\"*\";            }            if(j&lt;m) cout &lt;&lt;\"*\";        }        cout&lt;&lt;endl;    }    return 0;}\n\nJava 实现：import java.util.Scanner;public class Main {    static int[] p = new int[20];  // p[] 记录因子，p[1] 是最小因子。一个 int 数的质因子最多有 10 几个    static int[] c = new int[40];  // c[i] 记录第 i 个因子的个数。一个因子的个数最多有 30 几个    static int factor(int n) {        int m = 0;        for (int i = 2; i &lt;= Math.sqrt(n); i++) {            if (n % i == 0) {                p[++m] = i;                c[m] = 0;                while (n % i == 0) {                    n /= i;                    c[m]++;                }            }        }        if (n &gt; 1) {            p[++m] = n;            c[m] = 1;        }        return m;    }    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int a = sc.nextInt(), b = sc.nextInt();        for (int i = a; i &lt;= b; i++) {            int m = factor(i);            System.out.print(i + \"=\");            for (int j = 1; j &lt;= m; j++) {                for (int k = 1; k &lt;= c[j]; k++) {                    System.out.print(p[j]);                    if (k &lt; c[j]) {                        System.out.print(\"*\");                    }                }                if (j &lt; m) {                    System.out.print(\"*\");                }            }            System.out.println();        }    }}\n\nPython 实现：import mathp = [0] * 20  # p[] 记录因子，p[1] 是最小因子。一个 int 数的质因子最多有 10 几个c = [0] * 40  # c[i] 记录第 i 个因子的个数。一个因子的个数最多有 30 几个def factor(n):    m = 0    for i in range(2, int(math.sqrt(n)) + 1):        if n % i == 0:            m += 1            p[m], c[m] = i, 0            while n % i == 0:                n //= i                c[m] += 1    if n &gt; 1:        m += 1        p[m], c[m] = n, 1    return ma, b = map(int, input().split())for i in range(a, b+1):    m = factor(i)    print(f'{i}=', end='')    for j in range(1, m+1):        for k in range(1, c[j]+1):            print(p[j], end='')            if k &lt; c[j]:                print('*', end='')        if j &lt; m:            print('*', end='')    print()\n\n15 届蓝桥杯 14 天省赛冲刺营 1 期 - 简单数论 - 蓝桥云课 (lanqiao.cn)\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]知识梳理","url":"/2024/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/","content":"动态规划基础线性DP\n\n\n动态规划分析步骤\n模板题——破损的楼梯\"\"\"3367 破损的楼梯https://www.lanqiao.cn/problems/3367/learning这是一个典型的线性DP问题，dp[i]表示到达第i阶楼梯的方法数状态转移方程：dp[i]=dp[i-1]+dp[i-2]状态压缩：dp[i]只与dp[i-1]和dp[i-2]有关，所以可以压缩时间复杂度：O(n)空间复杂度：O(n)\"\"\"N = int(1e5 + 10)mod = int(1e9 + 7)n, m = map(int, input().split())a = list(map(int, input().split()))vis = [0] * Nfor i in a: vis[i] = 1dp = [0] * Ndp[0] = 1dp[1] = 1 - vis[1]for i in range(2, n + 1):    if vis[i]:        continue    dp[i] = (dp[i - 1] + dp[i - 2]) % modprint(dp[n])\n\nn,m=map(int,input().split())a=list(map(int,input().split()))dp=[0]*(n+1)tp=[0]*(n+1)for i in a:  tp[i]=1dp[0]=1dp[1]=1-tp[1]for i in range(2,n+1):  if tp[i]==1:    continue  dp[i]=dp[i-1]+dp[i-2]mod=10**9+7print(dp[i]%mod)\n\n\n\n二维DP\n分析步骤\n模板题——数字三角形import osimport sys# 请在此输入您的代码N = int(input())dp = [list(map(int, input().split())) for _ in range(N)]for i in range(1, N):    for j in range(i + 1):        if j == 0:            dp[i][j] += dp[i - 1][j]        elif j == i:            dp[i][j] += dp[i - 1][j - 1]        else:            dp[i][j] += max(dp[i - 1][j - 1], dp[i - 1][j])print(max(dp[N - 1]))\n\n\n\n模板题——摆花'''n种花凑 m盆 每种&lt;a[i]1.分解子问题前i种花，一共j盆，答案是dp[n][m]2.状态转移前i种花有j盆方案数  如何由前i-1种有j盆得出.以下每一种选择是一种方案第i种花可以选0盆,前i-1种花有j盆：dp[i][j] = dp[i-1][j]第i种花可以选1盆,前i-1种花有j-1盆：：dp[i][j] = dp[i-1][j-1]...第i种花可以选a[i]盆,前i-1种花有j-a[i]盆：：dp[i][j] = dp[i-1][j-a[i]]3.边界条件，每种花都不选前i种花 0盆 是 一种方案 dp[i][0] = 1'''MOD = 10 ** 6 + 7n, m = map(int, input().split())a = [0] + list(map(int, input().split()))dp = [[0] * (m + 1) for i in range(n + 1)]for i in range(n+1):    dp[i][0] = 1# 状态转移,当下做出的选择，利用之前dp,求dp[i][j]for i in range(1,n+1):    for j in range(1,m+1):        for k in range(min(a[i],j)+1):            dp[i][j]+=dp[i-1][j-k]            dp[i][j]%=MODprint(dp[n][m])\n\n模板题——选数异或n,x = map(int,input().split())a = [0] + list(map(int,input().split()))Mod = 998244353''' dp[i][j]前i个正整数有j个子序列异或成 j 的方案；答案dp[n][x] dp[i][j] = 选第i个数字 + 不选第i个数字          = dp[i - 1][j ^ a[i]] + dp[i - 1][j]             (因为如果选了第i个数字，那么a[i] ^ 前数 = j, 所以：前数 = j ^ a[i])'''dp = [[0] * (64) for _ in range(n + 1)]# 初始化为 0dp[0][0] = 1for i in range(1, n + 1):    for j in range(64):        dp[i][j] = (dp[i-1][j] + dp[i-1][j ^ a[i]]) % Modprint(dp[n][x])\n\nLIS最长上升子序列\n\n模板题——蓝桥勇士n=int(input())a=[0]+list(map(int,input().split()))dp=[1]*(n+1)for i in range(1,n):  for j in range(i+1,n+1):    if a[i]&lt;a[j]:      dp[j]=max(dp[j],dp[i]+1)print(max(dp))\n\n模板题——合唱队形n = int(input())a = [0] + list(map(int, input().split()))dp1 = [0] * (n + 1)  # dp1[i]表示以i结尾的最长上升子序列长度dp2 = [0] * (n + 1)  # dp2[i]表示以i出发的最长下降子序列长度for i in range(1, n + 1):    dp1[i] = 1    for j in range(1, i):        if a[i] &gt; a[j]:            dp1[i] = max(dp1[i], dp1[j] + 1)for i in range(n, 0, -1):    dp2[i] = 1    for j in range(i + 1, n + 1):        if a[i] &gt; a[j]:            dp2[i] = max(dp2[i], dp2[j] + 1)ans = max((dp1[i] + dp2[i] - 1) for i in range(1, n + 1))print(n-ans)\n\nLCS最长公共子序列\n\n模板题——最长公共子序列import osimport sys# 这段代码实现的是计算两个序列（a 和 b）的最长公共子序列（Longest Common Subsequence, LCS）的长度。LCS 是一种在计算两个序列相似度时常用的度量方法。这个问题通常通过动态规划来解决。现在，我将逐步解释这段代码的各个部分：# 输入处理n, m = map(int, input().split())a = [0] + list(map(int, input().split()))b = [0] + list(map(int, input().split()))# 首先，通过 input().split() 获取两个整数 n 和 m，分别表示序列 a 和 b 的长度。# 接着，读取这两个序列，并在序列前面各自加上一个 0 作为哨兵值。这样做是为了让序列的索引从 1 开始，方便后续操作。# 初始化动态规划数组dp = [[0] * (m + 1) for _ in range(2)]  # 注意这里是 m，不是 nnow = 0; old = 1# 初始化一个二维动态规划数组 dp，但这里只用到了两行（range(2)），目的是节省空间。因为在计算当前状态时，只需要用到前一行（即上一状态）的数据。m + 1 是因为考虑到从 0 开始到 m 的所有可能位置。# now 和 old 变量用来在这两行之间切换，表示当前行和上一行。# 动态规划过程for i in range(1, n + 1):    now, old = old, now    for j in range(1, m + 1):        dp[now][j] = max(dp[now][j - 1], dp[old][j])        if a[i] == b[j]:             dp[now][j] = max(dp[now][j], dp[old][j - 1] + 1)# 这部分是动态规划的核心。# 外层循环遍历序列 a，内层循环遍历序列 b。# dp[now][j] = max(dp[now][j - 1], dp[old][j])：当前状态是基于之前状态的最大值，这表示如果当前字符不匹配，LCS 长度不变。# 如果当前位置的字符相等（a[i] == b[j]），则检查上一个状态的值并加一，即 dp[now][j] = max(dp[now][j], dp[old][j - 1] + 1)。这反映了找到了一个公共元素，因此当前的最长公共子序列长度增加了 1。# 输出结果print(dp[now][m])# 最后，打印出最长公共子序列的长度，即在遍历完两个序列后，dp 数组最后一个元素（dp[now][m]）的值。# 通过这种方式，代码高效地计算了两个序列的最长公共子序列的长度，同时通过只使用两行的动态规划数组大大减少了空间复杂度。\n\n\n背包DP01背包\n\n\n模板题——小明的背包1#dp[i][j]    前i件物品，总体积不超过j 的最大价值n,v=map(int,input().split())dp=[[0]*(v+1) for i in range(n+1)]for i in range(1,n+1):    wi,vi=map(int,input().split())    for j in range(0,v+1):        if j&gt;=wi:            dp[i][j]=max(dp[i-1][j],dp[i-1][j-wi]+vi)        else:            dp[i][j]=dp[i-1][j]            print(dp[n][v])\n\n\n\n滚动数组优化\n\n\nn,V=map(int,input().split())dp=[0]*(V+1)for i in range(1,n+1):  w,v=map(int,input().split())  for j in range(V,w-1,-1):    dp[j]=max(dp[j],dp[j-w]+v)print(dp[V])\n\n完全背包\n\n\n\n模板题——小明的背包2\n# dp[i][j]=max(dp[i-1][j],dp[i][j-wi]+vi)  不取或在先前基础上取第i种（所以可以取多次）n,v=map(int,input().split())dp=[[0]*(v+1) for i in range(n+1)]for  i in range(1,n+1):    wi,vi=map(int,input().split())    for j in range(0,v+1):        if (j&gt;=wi):            dp[i][j]=max(dp[i-1][j],dp[i][j-wi]+vi)        else:            dp[i][j]=dp[i-1][j]print(dp[n][v])\n\n滚动数组优化import osimport sysN, V = map(int, input().split())items = []for _ in range(N):    w, v = map(int, input().split())    items.append((w, v))dp = [0] * (V + 1)for i in range(1, V + 1):    for w, v in items:        if i &gt;= w:            dp[i] = max(dp[i], dp[i - w] + v)print(dp[V])'''读取输入的商场物品数量N和小明的背包容量V，以及每种物品的体积和价值。初始化一个长度为V+1的动态规划数组dp，dp[i]表示背包容量为i时所能获得的最大价值。使用动态规划求解，外层循环遍历背包容量从1到V，内层循环遍历每种物品，更新dp[i]的值为dp[i-w]+v和当前dp[i]的较大值。输出dp[V]即为小明所能获得的最大价值。'''\n\n\n\n多重背包\n\n模板题——小明的背包3\n\n#dp[i][j] =max(dp[i][j],dp[i-1][j-k*wi]+k*vi)  k属于(0，si)n,v=map(int,input().split())dp=[[0]*(v+1) for i in range(n+1)]for i in range(1,n+1):    wi,vi,si=map(int,input().split())    for j in range(0,v+1):        for k in range(0,min(si,j//wi)+1):            dp[i][j]=max(dp[i][j],dp[i-1][j-k*wi]+k*vi)print(dp[n][v])\n\n滚动数组优化N,V=map(int,input().split())w,v,s=[[0]*(N+1) for _ in range(3)]dp=[0 for _ in range(V+1)]for i in range(1,N+1):  w[i],v[i],s[i]=map(int,input().split())for i in range(1,N+1):  for j in range(s[i]):    for k in range(V,0,-1):      if w[i]&lt;=k:        dp[k]=max(dp[k-w[i]]+v[i],dp[k])print(dp[-1])\n\n\n\n二维费用背包&amp;分组背包\n\n模板题——小蓝的神秘行囊import sysn, v, m = map(int, sys.stdin.readline().split())dp = [[0]*(v + 1) for _ in range(m + 1)]for _ in range(n):    volume, mass, value = map(int, sys.stdin.readline().split())    for i in range(m, 0, -1):        for j in range(v, 0, -1):            if i &gt;= mass and j &gt;= volume:                dp[i][j] = max(dp[i][j], dp[i-mass][j-volume] + value)print(dp[m][v])\n\nn,v,m=map(int,input().split())dp=[[0]*(m+1) for i in range(v+1)]for i in range(1,n+1):    vi,mi,wi=map(int,input().split())    for j in range(v,vi-1,-1):        for k in range(m,mi-1,-1):            dp[j][k] =max(dp[j][k],dp[j-vi][k-mi]+wi)           print(dp[v][m])\n\n树形DP自上而下树形DPfrom collections import defaultdictn = int(input())val = [0] + [int(x) for x in input().split()]edges = defaultdict(list)f = [[0, val[i]] for i in range(n + 1)]def add_edge(from_node, to_node):    edges[from_node].append(to_node)def dfs(u, fa):    for v in edges[u]:        if v == fa:            continue        dfs(v, u)        f[u][0] += max(f[v][0], f[v][1])        f[u][1] += f[v][0]for _ in range(n - 1):    u, v = map(int, input().split())    add_edge(u, v)    add_edge(v, u)dfs(1, 0)print(max(f[1][0], f[1][1]))\n\n\n\n自下而上树形DPimport sysfrom collections import defaultdictN = 100005a = [0]*Ndp = [[0]*2 for _ in range(N)]e = defaultdict(list)def dfs(u):    for v in e[u]:        dfs(v)        dp[u][1] += dp[v][0]        dp[u][0] += max(dp[v])    dp[u][1] += a[u]def main():    global N, a, dp, e    n = int(sys.stdin.readline())    st = set(range(1, n+1))    for i in range(1, n+1):        a[i] = int(sys.stdin.readline())    for _ in range(1, n):        x, y = map(int, sys.stdin.readline().split())        e[y].append(x)        st.discard(x)    rt = st.pop()    dfs(rt)    print(max(dp[rt]))if __name__ == \"__main__\":    main()\n\n\n\n路径相关树形DPN = 2005e = [[] for _ in range(N)]w = [[] for _ in range(N)]dp = [0]*Nn, m, k = 0, 0, 0dep = [0]*Nf = [0]*Nt = []def dfs(u):    global dp, e, w    for v in e[u]:        dfs(v)        dp[u] += dp[v]    for t in w[u]:        sum = dp[u]        for nw in t['vec']:            sum -= dp[nw]            for v in e[nw]:                sum += dp[v]        dp[u] = max(dp[u], sum + t['val'])def main():    global n, m, f, e, dep, dp, w, t    n, m = map(int, input().split())    for i in range(2, n+1):        f[i] = int(input())        e[f[i]].append(i)        dep[i] = dep[f[i]] + 1    for i in range(1, m+1):        x, y, val = map(int, input().split())        t.clear()        while x != y:            if dep[x] &gt; dep[y]:                t.append(x)                x = f[x]            else:                t.append(y)                y = f[y]        t.append(x)        w[x].append({'vec': list(t), 'val': val})    dfs(1)    print(dp[1])if __name__ == \"__main__\":    main()\n\n\n\n换根DPfrom collections import defaultdictdef dfs(u, dep, fa):  # 传入当前节点u,深度，父节点    global sum_depth    sum_depth += dep  # 加上当前节点u的深度    # 遍历u的所有子节点    for v in e[u]:        if v == fa:            continue        dfs(v, dep + 1, u)  # 遍历到子节点        siz[u] += siz[v]  # 通过这一步，可以统计u所有子节点数def dfs2(u, fa):  # 用来跟新其余节点为根的解    for v in e[u]:        if v == fa:            continue        # dp[v] = dp[u] - siz[v] + (n - siz[v])        dp[v] = dp[u] - 2 * siz[v] + n  # 当前节点v的解=左边变化值+右边变化值        dfs2(v, u)n = int(input())dp = [0] * (n + 1)  # 用来更新不同节点为根时的深度和siz = [1] * (n + 1)  # 以i为根节点，其左子树的节点数，初始值为1表示仅包含该节点# 建树e = defaultdict(list)for _ in range(n - 1):    u, v = map(int, input().split())    e[u].append(v)    e[v].append(u)# 第一遍dfs,找到以1为根节点的深度和sum_depth = 0  # 用来记录深度和dfs(1, 0, 0)# 第二遍dfs，求出其余点作为根的答案dp[1] = sum_depth  # 6dfs2(1, 0)  # dp=[0, 6, 5, 9, 8, 8]print(max(dp))\n\n\n\n区间DP\n\n普通区间DP模板题——石子合并n = int(input())a = [0] + list(map(int, input().split()))f = [[float('inf')] * (n+1) for _ in range(n+1)]for i in range(1, n+1):    f[i][i] = 0    a[i] += a[i-1]for length in range(2, n+1):    for i in range(1, n-length+2):        j = i + length - 1        for k in range(i, j):            f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + a[j] - a[i-1])print(f[1][n])\n\n模板题——涂色s = input()n = len(s)f = [[float('inf')] * n for _ in range(n)]for i in range(n):    f[i][i] = 1for length in range(2, n+1):    for i in range(n - length + 1):        j = i + length - 1        if s[i] == s[j]:            f[i][j] = min(f[i + 1][j], f[i][j - 1])        else:            for k in range(i, i + length - 1):                f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j])print(f[0][n - 1])\n\n模板题——制作回文串m, n = map(int, input().split())s = input()w1 = [0] * 30w2 = [0] * 30f = [[0] * n for _ in range(n)]for i in range(m):    ch, weight1, weight2 = input().split()    w1[ord(ch) - ord('a')] = int(weight1)    w2[ord(ch) - ord('a')] = int(weight2)for length in range(2, n+1):    for i in range(n - length + 1):        j = i + length - 1        if s[i] == s[j]:            if length == 2:                f[i][j] = 0            else:                f[i][j] = f[i + 1][j - 1]        else:            f[i][j] = min(                f[i + 1][j] + min(w1[ord(s[i]) - ord('a')], w2[ord(s[i]) - ord('a')]),                f[i][j - 1] + min(w1[ord(s[j]) - ord('a')], w2[ord(s[j]) - ord('a')])            )print(f[0][n - 1])\n\n\n\n环形区间DP模板题——能量项链n = int(input())v = [0] * (2 * n + 2)a = [0] + list(map(int, input().split()))for i in range(1, n + 1):    v[i] = a[i]    v[i + n] = v[i]f = [[0] * (2 * n + 1) for _ in range(2 * n + 1)]for length in range(2, n + 1):    for i in range(1, 2 * n - length + 2):        j = i + length - 1        for k in range(i, j):            f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + v[i] * v[k + 1] * v[j + 1])ans = 0for i in range(1, n + 1):    ans = max(ans, f[i][i + n - 1])print(ans)\n\n\n\n状压DP\n\n模板题——例1\nMAXN = 105N, M, K = map(int, input().split())a = [0] * MAXNf = [float('inf')] * (1 &lt;&lt; 20)for i in range(N):    for j in map(int, input().split()):        a[i] |= 1 &lt;&lt; (j - 1)f[0] = 0for i in range(N):    for S in range(1 &lt;&lt; M):        if f[S] &gt; MAXN:            continue        f[S | a[i]] = min(f[S | a[i]], f[S] + 1)print(f[(1 &lt;&lt; M) - 1] if f[(1 &lt;&lt; M) - 1] &lt; MAXN else -1)\n\n模板题——例2\nimport mathmaxn = 2100000f = [float('inf')] * maxnlowbit = [0] * maxnline = [[0] * 20 for _ in range(20)]x = [0.0] * maxny = [0.0] * maxneps = 1e-8def equ(a1, b1, c1, a2, b2, c2):    y = (a1 * c2 - a2 * c1) / (a1 * b2 - a2 * b1)    x = (c1 - b1 * y) / a1    return x, yfor i in range(1, (1 &lt;&lt; 18)):    j = 1    while (i &amp; (1 &lt;&lt; (j - 1))):        j += 1    lowbit[i] = jn = int(input())for i in range(1, n + 1):    x[i], y[i] = map(float, input().split())for i in range(1, n + 1):    for j in range(1, n + 1):        if math.isclose(x[i], x[j], abs_tol=eps):            continue        a, b = equ(x[i] * x[i], x[i], y[i], x[j] * x[j], x[j], y[j])        if math.isclose(a, 0, abs_tol=eps):            continue        for k in range(1, n + 1):            if math.isclose(a * x[k] * x[k] + b * x[k], y[k], abs_tol=eps):                line[i][j] |= (1 &lt;&lt; (k - 1))for i in range(1, (1 &lt;&lt; n)):    j = lowbit[i]    f[i | (1 &lt;&lt; (j - 1))] = min(f[i | (1 &lt;&lt; (j - 1))], f[i] + 1)    for k in range(1, n + 1):        f[i | line[j][k]] = min(f[i | line[j][k]], f[i] + 1)print(f[(1 &lt;&lt; n) - 1])\n\n\n\n数位DP期望DP数据结构链表，栈，队列链表\n\n模板题——约瑟夫环n,k,m=map(int,input().split())a=list(range(1,n+1))i=k-1while a:    i=(i+(m-1))%len(a)    print(a.pop(i))\n\n\n\n栈\n模板题——小蓝的括号串1n=int(input())s=input()a=[]ok=Truefor c in s:    if c == '(':        a.append(c)    else:        if len(a) == 0:            ok = False            break        a.pop()if ok and len(a) == 0:    print('Yes')else:    print('No')\n\n队列\n\n\n模板题——队列操作N=int(input())a=[]for i in range(N):    s=list(map(int,input().split()))    if s[0]==1:        a.append(s[1])    elif s[0]==2:        if a:            print(a.pop(0))        else:            print(\"no\")    else:        print(len(a))\n\n堆\n\n\n优先队列\n\n\n模板题——小蓝的神奇复印机from queue import PriorityQueue,QueueN,X=map(int,input().split())a=list(map(int,input().split()))q=Queue()pq=PriorityQueue()for i,x in enumerate(a):  q.put((i,x))  pq.put(-x)time=0while True:  i,x=q.get()  if -x==pq.queue[0]:    pq.get()    time+=1    if i==X:      print(time)      break  else:    q.put((i,x))\n\nST表RMQ问题\n并查集基础并查集基础\n\n模板题——蓝桥幼儿园# def Findroot(x):#     while x!=p[x]:#         x=p[x]#     return x'''使用路径压缩'''def Findroot(x):    if x==p[x]:return x    #路径压缩    p[x]=Findroot(p[x])    return p[x]def Merge(x,y):    rootx,rooty=Findroot(x),Findroot(y)    p[rootx]=rootydef Query(x,y):    rootx,rooty=Findroot(x),Findroot(y)    return rootx==rootyn,m=map(int,input().split())p=list(range(n+1))for _ in range(m):    op,x,y=map(int,input().split())    if op ==1:        Merge(x,y)    else:        if Query(x,y):            print(\"YES\")        else:            print(\"NO\")\n\n路径压缩\n模板题——星球大战import osimport sysM = 200010; N = 2 * Mn, m = map(int, input().split())father = [0] * (n + 10)                 #并查集板块def init():    for i in range(n + 10):        father[i] = idef find_father(x):    if x != father[x]: father[x] = find_father(father[x])    return father[x]def unite(x, y):    father[find_father(x)] = find_father(y)come = [0] * N; to = [0] * N;   #存储每个边g = [[] for _ in range(N)]      #邻接表for i in range(m):    a, b = map(int, input().split())    g[a].append(b); g[b].append(a)    come[i] = a; to[i] = b broken = [0] * (n + 10)                     #记录每个点是否被修坏destroy = []k = int(input())for i in range(k):    b = int(input())    broken[b] = 1    destroy.append(b)init()res = n - k             #先计算所有剩下星球的连通块数，(最后一轮的结果)for i in range(m):    l = come[i]; r = to[i]    fl, fr = find_father(l), find_father(r)    if not broken[l] and not broken[r] and fl != fr:        res -= 1        #unite(l, r)        father[fl] = frans = [res]for i in range(len(destroy) - 1, -1, -1):       #顺序破坏，相当于倒序修建    c = destroy[i]    broken[c] = 0    res += 1                                    #修好一个星球，连通块会多一个    for j in g[c]:        fc, fp = find_father(c), find_father(j)        if not broken[j] and fc != fp:            res -= 1            father[fc] = fp    ans.append(res)for i in range(len(ans) - 1, -1, -1):           #倒序输出结果    print(ans[i])\n\n可撤销并查集\n\n\n\n\n\n\n\n\n\n\n可撤销并查集定义\n\n算法原理\n带权并查集\n\n\n\n\n树上问题树的基本概念\n\n二叉树 \t\n\n模板题——完全二叉树的权值import maths = []n = int(input())x = list(map(int, input().split()))deep = int(math.log(n, 2)) + 1  # 完全二叉树求深度公式for i in range(deep):  # 按层数来遍历    s.append(sum(x[2 ** i - 1:2 ** i + 2 ** i - 1]))  # 切片出每层的节点，并计算其权值print(s.index(max(s)) + 1)  # 找出权值最大的层级，并返回其索引\n\n\n树的遍历\n先序遍历\n\n中序遍历\n后序遍历\n层序遍历\n树的遍历\n\n模板题——欧涛爬树import syssys.setrecursionlimit(100000)input=sys.stdin.readlinedef dfs(u,fa):#进行判断是否是叶子节点    path.append(s[u])    flag=True    for v in G[u]:        if v==fa:continue        dfs(v,u)        flag=False    if flag:        S.add(''.join(path))    path.pop()while True:    try:        n=int(input())        #邻接表进行存放树        G=[[] for _ in range(n+1)]        s=' '+input()        for _ in range(n-1):            u,v=map(int,input().split())            G[u].append(v)            G[v].append(u)        path=[]        S=set()        dfs(1,-1)        print(len(S))    except:        break\n\n\n\ndef read():    import sys    return sys.stdin.readline().strip()def dfs(root, fa):    path.append(s[root])    flag = True    for to in vis[root]:        if to == fa:            continue        dfs(to, root)        flag = False    if flag:        result.add(\"\".join(path))    path.pop()# 多次输入模板while True:    try:        n = int(read())        s = read()        vis = [[] for _ in range(n)]        for _ in range(n - 1):            u, v = map(int, read().split())            u -= 1            v -= 1            vis[u].append(v)            vis[v].append(u)        result = set()        path = []        dfs(0, -1)        print(len(result))    except:        break\n\n\n\n树的直径与重心树的直径\n\n\n模板题——直径import osimport sysinput = sys.stdin.readlinesys.setrecursionlimit(100000)def dfs(u, fa, pre=None):    global S    if d[u] &gt; d[S]: S = u    for v, w in G[u]:        if v == fa: continue        d[v] = d[u] + w        if pre: pre[v] = u        dfs(v, u, pre)n = int(input())G = [[] for i in range(n + 1)]d = [0] * (n + 1)pre = [0] * (n + 1)for _ in range(n - 1):    u, v, w = map(int, input().split())    G[u].append([v, w])    G[v].append([u, w])S = 1dfs(1, 0)d[S] = 0dfs(S, 0, pre)L = [S]L_list = set()while S != 0:    L_list.add(S)    S = pre[S]for u in L_list:    for i, (v, w) in enumerate(G[u]):        if v in L_list:            G[u][i] = [v, w - 1]S = 1dfs(1, 0)d[S] = 0dfs(S, 0)L2 = d[S]print(L)print(L - L2)\n\n\nLCA最近公共祖先\n\n\n模板题——最近公共祖先LCA查询import osimport sys#设置deep数组表示深度。#front数组，表示节点u,前2**i层的爹是谁？？？n=int(input())tree=[[] for _ in range(n+1)]fornt=[[0]*(21) for _ in range(n+1)]#如果你是0你就是孤儿。deep=[0]*(n+1)#0节点没有层数。for i in range(n-1):  u,v=map(int,input().split())  tree[u].append(v)def dfs(er,die):  if die==0:    deep[er]=1#这是第一层,同时，第一层也没有爹啊，也不需要更新如何层数相关节点。  else:    deep[er]=deep[die]+1#更新层数。    fornt[er][0]=die#上一层的点，就是die。    for cc in range(1,21):      if fornt[fornt[er][cc-1]][cc-1]!=0:        fornt[er][cc]=fornt[fornt[er][cc-1]][cc-1]        #倍增法。2**i层之上的点=        #2**(cc-1)上面的点的上面2**(cc-1)的点。就，无限套娃。    for i in tree[er]:    dfs(i,er)#儿子变成新的爹。dfs(1,0)#儿子是根，爹不存在。def find(x,y):  #第一步，拉升。将x拉到和y一个水平。一开始走2**20步，太大，就走2**19步，然后走一半，再走一半  #就像那个乌龟与跑步哥一样。二进制原理使得这个步数遍历后一定是一个高度。  for i in range(20,-1,-1):    if deep[fornt[x][i]]&gt;=deep[y] and fornt[x][i]!=0:      x=fornt[x][i]#自动判断能走不能走，能走则走一大步。x提升到别的节点。  #此时提升必定一样了。  if x==y:    return x#原来你就是我爹！    else:#不是？我们再度提升吧！神明！    for i in range(20,-1,-1):      if fornt[x][i]!=fornt[y][i] and fornt[x][i]!=0 and fornt[y][i]!=0:#相等反而不能决定什么，因为可能不是最近的公共祖先        x=fornt[x][i]        y=fornt[y][i]    return fornt[y][0]#最后，y上面的就是自己的公共祖先。q=int(input())for i in range(q):  x,y=map(int,input().split())  if deep[x]&lt;deep[y]:#我们设x是深节点。    x,y=y,x  print(find(x,y))\n\n\n\n树上差分\n问题引入\n\n\n\n\n\n模板题——import sysimport mathfrom collections import defaultdictmaxn = 110000n, k = map(int, sys.stdin.readline().split())maxx = int(math.log2(n))edge = defaultdict(list)head = [0] * (n + 1)dep = [0] * (n + 1)dlt = [0] * (n + 1)fa = [[0] * 20 for _ in range(n + 1)]cnt = 0def add_edge(a, b, dis):    global cnt    cnt += 1    edge[cnt] = [head[a], b, dis]    head[a] = cnt    cnt += 1    edge[cnt] = [head[b], a, dis]    head[b] = cntfor _ in range(n - 1):    a, b, dis = map(int, sys.stdin.readline().split())    add_edge(a, b, dis)dfs(1)for _ in range(k):    a, b, x = map(int, sys.stdin.readline().split())    dlt[a] += x    dlt[b] += x    c = lca(a, b)    dlt[c] -= 2 * xdfs1(1)for i in range(1, n + 1):    print(dlt[i], end=' ')print()\n\n\n\nDFS序\n\n\n\n\n\n\n\n\n\n\n\n\n模板题——异或和dfs序和树状数组n, m = map(int, input().split())v = [0] + list(map(int, input().split()))g = [[] for _ in range(n + 1)]for _ in range(n - 1):    u, va = map(int, input().split())    g[u].append(va)    g[va].append(u)tree = [0] * (n + 1)a = [[0, 0] for _ in range(n + 1)] # 存dfs序cnt = 0def dfs(node, fa):    global cnt    cnt += 1    a[node][0] = cnt    for i in g[node]:        if i != fa:            dfs(i, node)    a[node][1] = cntdfs(1, 0)def lowbit(x):    return x &amp; (-x)def update(x, d):    while x &lt;= n:        tree[x] ^= d        x += lowbit(x)        def query(x):    ans = 0    while x:        ans ^= tree[x]        x -= lowbit(x)    return ansfor i in range(1, n + 1):    update(a[i][0], v[i])for _ in range(m):    o = list(map(int, input().split()))    if o[0] == 2:        print(query(a[o[1]][1]) ^ query(a[o[1]][0] - 1))    else:        x, y = o[1], o[2]        update(a[x][0], v[x] ^ y)        v[x] = y\n\n模拟暴力代码n, m = map(int, input().split())a = [0] + list(map(int, input().split()))g = [[] for i in range(n + 1)]for _ in range(n - 1):    c, d =map(int, input().split())    g[c].append(d)    g[d].append(c)dep = [0] * (n + 1)dep[1] = 1def depth(node, fa):    for i in g[node]:        if i != fa:            dep[i] = dep[node] + 1            depth(i, node)depth(1, 0)def dfs(node):    for i in g[node]:        if dep[i] &gt; dep[node]:            li.append(a[i])            dfs(i)def query(n):    global li    li = [a[n]]    dfs(n)    ans = li[0]    for i in range(1, len(li)):        ans = ans ^ li[i]    print(ans)def change(x, y):    a[x] = yfor _ in range(m):    o = list(map(int, input().split()))    if o[0] == 2: query(o[1])    else: change(o[1], o[2])\n\n利用邻接表打印树结构，然后根据子树根节点寻找打印子树的元素，存到列表中，最后对列表的所有元素（即子树的所有点）进行异或和运算\nimport osimport sysn, m = map(int, input().split())  # 读取输入的 n 和 mvalue = list(map(int, input().split()))  # 读取输入的值列表value.insert(0, 0)  # 在值列表的最前面插入 0,根节点为1，索引从1开始yihuo = []  # 存储异或运算结果的列表tree = [[] for _ in range(n + 1)]  # 初始化邻接表,表示树结构for i in range(n - 1):  # 读取 n-1 次输入    a, b = map(int, input().split())    a, b = min(a, b), max(a, b)    tree[a].append(b)  # 在 a 结点的邻接表中添加 b 结点，说明b为a的子节点for i in range(m):  # 读取 m 次操作输入    op = list(map(int, input().split()))    if op[0] == 1:  # 如果是操作 1        value[op[1]] = op[2]  # 更新点权    else:  # 如果是操作 2        x = op[1]#子树根节点        vis = [x]  # 把子树存到该列表里        qfront = 0  # 队列的头指针        qend = 1  # 队列的尾指针        while qfront != qend:  # 当队列不为空时            if tree[vis[qfront]] != []:  # 该节点有子节点                vis.extend(tree[vis[qfront]])  # 将子节点存到子树中                qend += len(tree[vis[qfront]])  # 更新队列的尾指针            qfront += 1  # 更新队列的头指针        ans = value[vis[0]]  # 初始化异或运算的结果        for i in range(1, len(vis)):  # 遍历访问列表中的结点            ans ^= value[vis[i]]  # 对每个结点的值进行异或运算        yihuo.append(ans)  # 将异或运算的结果加入到结果列表中for i in yihuo:  # 遍历结果列表    print(i)  # 输出每个异或运算的结果\n\n\n\n树链剖分\n\n重链部分\n\n\n\n\n\n\n\n\n树链部分的性质\n\n\n\n树形数据结构树状数组基础lowbit操作\n树状数组\n\n\n\n模板题——单点修改，区间查询N = 100100#初始化树状数组 为0f = [0] * N#求下标为x的最小区间长度def lowbit(x):    return x &amp; (-x)#树状数组更新函数def upd(pos,v):#pos：下标 v：值    #在下标为pos的区间加上v 并且在每个有包含pos的大区间加上v    #包含当前区间的大区间：在pos的位置上加lowbit(pos)便能得到大区间    while pos &lt;= n:        f[pos] += v        pos += lowbit(pos)#得到1-pos位置的前缀和def get(pos):    res = 0    while pos &gt; 0:#加上组成pos每一个区间的和        res += f[pos]        pos -= lowbit(pos)    return resn = int(input())data = input().split()for i in range(0,n):    x = int(data[i])    #树状数组初始化都为0，需要将原数组每个值通过upd方法将每个值加入树状数组    upd(i+1,x)m = int(input())for _ in range(m):    opt,a,b = map(int,input().split())    if opt == 1:        upd(a,b)#更新    else:        #区间[a,b] = [1,b] - [1,a-1]        print(get(b) - get(a-1))\n\nimport osimport sysN = int(input())n = list(map(int,input().split()))m = int(input())for i in range(m):  s,a,b = map(int,input().split())  if s == 1:    n[a-1] += b  if s == 2:    print(sum(n[a-1:b]))\n\nxxxxxxxxxx import osimport sys#设置deep数组表示深度。#front数组，表示节点u,前2i层的爹是谁？？？n=int(input())tree=[[] for _ in range(n+1)]fornt=[[0](21) for _ in range(n+1)]#如果你是0你就是孤儿。deep=[0](n+1)#0节点没有层数。for i in range(n-1):  u,v=map(int,input().split())  tree[u].append(v)def dfs(er,die):  if die==0:    deep[er]=1#这是第一层,同时，第一层也没有爹啊，也不需要更新如何层数相关节点。  else:    deep[er]=deep[die]+1#更新层数。    fornt[er][0]=die#上一层的点，就是die。    for cc in range(1,21):      if fornt[fornt[er][cc-1]][cc-1]!=0:        fornt[er][cc]=fornt[fornt[er][cc-1]][cc-1]        #倍增法。2i层之上的点=        #2**(cc-1)上面的点的上面2**(cc-1)的点。就，无限套娃。    for i in tree[er]:    dfs(i,er)#儿子变成新的爹。dfs(1,0)#儿子是根，爹不存在。def find(x,y):  #第一步，拉升。将x拉到和y一个水平。一开始走220步，太大，就走219步，然后走一半，再走一半  #就像那个乌龟与跑步哥一样。二进制原理使得这个步数遍历后一定是一个高度。  for i in range(20,-1,-1):    if deep[fornt[x][i]]&gt;=deep[y] and fornt[x][i]!=0:      x=fornt[x][i]#自动判断能走不能走，能走则走一大步。x提升到别的节点。  #此时提升必定一样了。  if x==y:    return x#原来你就是我爹！    else:#不是？我们再度提升吧！神明！    for i in range(20,-1,-1):      if fornt[x][i]!=fornt[y][i] and fornt[x][i]!=0 and fornt[y][i]!=0:#相等反而不能决定什么，因为可能不是最近的公共祖先        x=fornt[x][i]        y=fornt[y][i]    return fornt[y][0]#最后，y上面的就是自己的公共祖先。q=int(input())for i in range(q):  x,y=map(int,input().split())  if deep[x]&lt;deep[y]:#我们设x是深节点。    x,y=y,x  print(find(x,y))py\n树状数组\n模板题——殷老师排队import osimport sysdef lowbit(x):  return x &amp; (-x)def query(x):  ans = 0  while x:    ans += tree[x]    x -= lowbit(x)  return ans def add(x,y):  while x &lt;= n:    tree[x] += y    x += lowbit(x)n, m = map(int,input().split())a =[0] + list(map(int,input().split()))tree = [0] * (n + 1)for i in range(1,n+1):  add(i,a[i])for i in range(m):  lt = list(map(int,input().split()))  if lt[0] == 1:    x, y = lt[1], lt[2]    add(x,y - a[x])    a[x] = y  else:    x = lt[1]    ans = (2 * x - n - 2) * a[x] + query(n) - 2*query(x-1)    print(ans)\n\n二维树状数组\n\n\n模板题——\n树状数组上二分\n模板题——maxn = 110000ans = [0] * maxntree = [0] * maxna = [0] * maxndef lowbit(x):    return x &amp; -xdef add(pos, x):    while pos &lt; maxn:        tree[pos] += x        pos += lowbit(pos)def query(pos):    res = 0    while pos &gt; 0:        res += tree[pos]        pos -= lowbit(pos)    return resn = int(input())nums = list(map(int, input().strip().split()))for i in range(1, n + 1):    a[i] = nums[i - 1]    add(i, 1)for i in range(n, 0, -1):    l, r = 1, n    while l &lt;= r:        mid = (l + r) // 2        if query(mid) &lt; a[i] + 1:            l = mid + 1        else:            r = mid - 1    ans[i] = r    add(r, -1)for i in range(1, n + 1):    print(ans[i], end=' ')\n\n\n\n线段树-动态开点\n\n\n\n\n\n\n\n\n\n例题\nstruct Tree {    int l, r, n, ls, rs;}void update(int &amp;t, int l, int r, int pos, int n) {    if (!t) {        t = ++ cnt;        tree[t].l = l;        tree[t].r = r;    }    if (l == r) {        tree[t].n = n;        return;    }    int mid = (l + r) &gt;&gt; 1;    if (pos &lt;= mid) {        update(tree[t].ls, l, mid, pos, n);    } else {        update(tree[t].rs, mid + 1, r, pos, n);    }}int getnum(int t, int l, int r) {    if (!t) {        return 0;    }    if (tree[t].l == l &amp;&amp; tree[t].r == r) {        return tree[t].n;    }    int mid = (tree[t].l + tree[t].r) &gt;&gt; 1;    if (r &lt;= mid) {        return getnum(tree[t].ls, l, r);    } else if (l &gt; mid) {        return getnum(tree[t].rs, l, r);    } else {        return getnum(tree[t].ls, l, mid) + getnum(tree[t].rs, mid + 1, r);    }}\n\n\n\n线段树-标记永久化\n\n\n\n\n\n\n\n\n案例void build(int t, int l, int r, int *v) {    _l[t] = l;    _r[t] = r;    if (l == r) {        _v[t] = v[l];        return ;    }    int mid = (l + r) &gt;&gt; 1;    build(t &lt;&lt; 1, l, mid, v);    build(t &lt;&lt; 1 | 1, mid + 1, r, v);    _v[t] = _v[t &lt;&lt; 1] + _v[t &lt;&lt; 1 | 1];}void update(int t, int l, int r, int k) {    _v[t] += k * (r - l + 1);    if (_l[t] == l &amp;&amp; _r[t] == r) {        _laz[t] += k;        return ;    }    int mid = (_l[t] + _r[t]) &gt;&gt; 1;    if (r &lt;= mid) {        update(t &lt;&lt; 1, l, r, k);    } else if (l &gt; mid) {        update(t &lt;&lt; 1 | 1, l, r, k);    } else {        update(t &lt;&lt; 1, l, mid, k);        update(t &lt;&lt; 1 | 1, mid + 1, r, k);    }}int getv(int t, int l, int r, int sum) {    if (_l[t] == l &amp;&amp; _r[t] == r) {        return _v[t] + sum * (_r[t] - _l[t] + 1);;    }    int mid = (_l[t] + _r[t]) &gt;&gt; 1;    if (r &lt;= mid) {        return getv(t &lt;&lt; 1, l, r, sum + _laz[t]);    } else if (l &gt; mid) {        return getv(t &lt;&lt; 1 | 1, l, r, sum + _laz[t]);    } else {        return getv(t &lt;&lt; 1, l, mid, sum + _laz[t])            + getv(t &lt;&lt; 1 | 1, mid + 1, r, sum + _laz[t]);    }}\n\n\n\n线段树维护矩阵\n\n\n\nvoid build(int t, int l, int r) {    _l[t] = l;    _r[t] = r;    _v[t] = _E;    if (l == r) {        return ;    }    int mid = (l + r) &gt;&gt; 1;    build(t &lt;&lt; 1, l, mid);    build(t &lt;&lt; 1 | 1, mid + 1, r);}void update(int t, int pos, MATRIX &amp;v) {    if (_l[t] = _r[t]) {        _v[t] = v;        return ;    }    int mid = (_l[t] + _r[t]) &gt;&gt; 1;    if (pos &lt;= mid) {        update(t &lt;&lt; 1, pos, v);    } else {        update(t &lt;&lt; 1 | 1, pos, v);    }    _v[t] = _v[t &lt;&lt; 1] * _v[t &lt;&lt; 1 | 1];}MATRIX getv(int t, int l, int r) {    if (_l[t] == l &amp;&amp; _r[t] == r) {        return _v[t];    }    int mid = (_l[t] + _r[t]) &gt;&gt; 1;    if (r &lt;= mid) {        return getv(t &lt;&lt; 1, l, r);    } else if (l &gt; mid) {        return getv(t &lt;&lt; 1 | 1, l, r);    } else {        return getv(t &lt;&lt; 1, l, mid) * getv(t &lt;&lt; 1 | 1, mid + 1, r);    }}\n\n线段树维护哈希\n\n\n\n\n\nbs1= []bs2= []mod1 = 998244353mod2 = 19260817bas = 233s = []class asdf:    def __init__(self, h1, h2, length):        self.h1 = h1        self.h2 = h2        self.length = length        def __add__(self, c):        return asdf((self.h1 * bs1[c.length] + c.h1) % mod1, (self.h2 * bs2[c.length] + c.h2) % mod2, self.length + c.length)        def __eq__(self, c):        return self.h1 == c.h1 and self.h2 == c.h2 and self.length == c.lengthdef build(l, r, rt):    if l == r:        s[rt] = asdf(ord(a[l]), ord(a[l]), 1)        return s[rt]    s[rt] = build(l, (l + r) // 2, rt * 2) + build((l + r) // 2 + 1, r, rt * 2 + 1)    return s[rt]def query(l, r, rt, x, y):    if x &lt;= l and r &lt;= y:        return s[rt]    if y &lt;= (l + r) // 2:        return query(l, (l + r) // 2, rt * 2, x, y)    if x &gt; (l + r) // 2:        return query((l + r) // 2 + 1, r, rt * 2 + 1, x, y)    return query(l, (l + r) // 2, rt * 2, x, y) + query((l + r) // 2 + 1, r, rt * 2 + 1, x, y)def modify(l, r, rt, ad, ch):    if l == r:        s[rt] = asdf(ord(ch), ord(ch), 1)        return s[rt]    if ad &lt;= (l + r) // 2:        s[rt] = modify(l, (l + r) // 2, rt * 2, ad, ch) + s[rt * 2 + 1]    else:        s[rt] = s[rt * 2] + modify((l + r) // 2 + 1, r, rt * 2 + 1, ad, ch)    return s[rt]n = int(input())a = input()a = \"!\" + abs1.append(1)bs2.append(1)for i in range(n):    bs1.append(bs1[i]*bas%mod1)    bs2.append(bs2[i]*bas%mod2)s = [None] * (4 * (n+5))build(1, n, 1)q = int(input())for _ in range(q):    ls=input().split()    opt = ls[0]    if opt == '1':        ad = int(ls[1])        ch = ls[2]        modify(1, n, 1, int(ad), ch)    else:        l1 = int(ls[1])        r1 = int(ls[2])        l2 = int(ls[3])        r2 = int(ls[4])        x = query(1, n, 1, l1, r1)        y = query(1, n, 1, l2, r2)        if x == y:            print(\"YES\")        else:            print(\"NO\")\n\n\n\n可持久化线段树\n\n\n\n\n\n\n\n\n可持久化线段树struct NODE {    int v, ls, rs;}struct SEGTREE {    int cnt = 0;    int root[MAXN &lt;&lt; 5];    NODE node[MAXN &lt;&lt; 5];}void SEGTREE::update(int _t, int &amp;t, int l, int r, int pos, int k) {    if (!t) {        t = ++cnt;        node[t].v = node[_t].v;    }    if (l == r) {        node[t].v += k;        return;    }    int mid = (l + r) &gt;&gt; 1;    if (pos &lt;= mid) {        node[t].rs = node[_t].rs;        update(node[_t].ls, node[t].ls, l, mid, pos, k);    } else {        node[t].ls = node[_t].ls;        update(node[_t]).rs, node[t].rs, mid + 1, r, pos, k);    }    node[t].v = node[node[t].ls].v + node[node[t].rs].v;}int SEGTREE::getV(int t, int _l, int _r, int l, int r) {    if (!t) {        return 0;    }    if (l == _l &amp;&amp; r == _r) {        return node[t].v;    }    int mid = (_l + _r) &gt;&gt; 1;    if (r &lt;= mid) {        return getV(node[t].ls, _l, mid, l, r);    } else if (l &gt; mid) {        return getV(node[t].rs, mid + 1, _r, l, r);    } else {        return getV(node[t].ls, _l, mid, l, mid)            + getV(node[t].rs, mid + 1, _r, mid + 1, r);    }}\n\n\n\n模板题——区间第k小#include&lt;bits/stdc++.h&gt;using namespace std;#define lc(x) tr[x].l#define rc(x) tr[x].rconst int N=2e5+6;int n,m,a[N],b[N];struct Node { int l,r,s;//左右儿子，该节点在值域中的个数}tr[N*20];int idx,root[N];void build(int &amp;x,int l,int r){    x=++idx;    if(l==r)return ;    int mid=(l+r)&gt;&gt;1;    build(lc(x),l,mid);    build(rc(x),mid+1,r);}void update(int x,int &amp;y,int l,int r,int v){    y=++idx;    tr[y]=tr[x];    tr[y].s++;    if(l==r)return;    int mid=(l+r)&gt;&gt;1;    if(v&lt;=mid)        update(lc(x),lc(y),l,mid,v);    else        update(rc(x),rc(y),mid+1,r,v);}int query(int x,int y,int l,int r,int k){    if(l==r)return l;    int mid=(l+r)&gt;&gt;1;    int s=tr[lc(y)].s-tr[lc(x)].s;    if(k&lt;=s)        return query(lc(x),lc(y),l,mid,k);    else         return query(rc(x),rc(y),mid+1,r,k-s);}int main(){    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)    {        cin&gt;&gt;a[i];        b[i]=a[i];    }    sort(b+1,b+1+n);    int bn=unique(b+1,b+1+n)-b-1;    build(root[0],1,bn);    for(int i=1;i&lt;=n;i++)    {        int id=lower_bound(b+1,b+1+bn,a[i])-b;        update(root[i-1],root[i],1,bn,id);    }    while(m--)    {        int l,r,k;        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;        int id=query(root[l-1],root[r],1,bn,k);        cout&lt;&lt;b[id]&lt;&lt;'\\n';    }    return 0;}\n\n扫描线与二维数点\n\n\n\n二维数点\n\n\n#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000struct Point{    int x,y;}point[maxn];struct Rect{    int p1,p2,q1,q2,id;}rect[maxn];int n,m,ans[maxn];int len[maxn],cnt;bool cmp(const Point &amp;a,const Point &amp;b){    return a.x &lt; b.x;}bool cmp1(const Rect &amp;a,const Rect &amp;b){    return a.p1&lt;b.p1;}bool cmp2(const Rect &amp;a,const Rect &amp;b){    return a.q1&lt;b.q1;}struct Node{    int sum;}tree[maxn&lt;&lt;1];void pushup(int rt){    tree[rt].sum=tree[rt&lt;&lt;1].sum+tree[rt&lt;&lt;1|1].sum;}void add(int rt,int l,int r,int x){    if(l==r){        if(l==x)tree[rt].sum+=1;        return ;    }    int mid=(l+r)&gt;&gt;1;    if(x&lt;=mid)add(rt&lt;&lt;1,l,mid,x);    if(x&gt;mid)add(rt&lt;&lt;1|1,mid+1,r,x);    pushup(rt);}int query(int rt,int l,int r,int x,int y){    if(x&lt;=l&amp;&amp;r&lt;=y){        return tree[rt].sum;    }    int mid=(l+r)&gt;&gt;1;    int ans=0;    if(x&lt;=mid)ans+=query(rt&lt;&lt;1,l,mid,x,y);    if(y&gt;mid)ans+=query(rt&lt;&lt;1|1,mid+1,r,x,y);    pushup(rt);    return ans;}int main(){    scanf(\"%d%d\",&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++){        scanf(\"%d%d\",&amp;point[i].x,&amp;point[i].y);        len[++cnt]=point[i].x,len[++cnt]=point[i].y;    }    for(int i=1;i&lt;=m;i++){        int a,b,c,d;        scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d);        rect[i]={a,b,c,d,i};        len[++cnt]=a;len[++cnt]=b;len[++cnt]=c;len[++cnt]=d;    }    sort(len+1,len+cnt+1);    int tot=unique(len+1,len+cnt+1)-len-1;    for(int i=1;i&lt;=n;i++){        point[i].x=lower_bound(len+1,len+cnt+1,point[i].x)-len;        point[i].y=lower_bound(len+1,len+cnt+1,point[i].y)-len;    }    for(int i=1;i&lt;=m;i++){        rect[i].p1=lower_bound(len+1,len+cnt+1,rect[i].p1)-len;        rect[i].q1=lower_bound(len+1,len+cnt+1,rect[i].q1)-len;        rect[i].p2=lower_bound(len+1,len+cnt+1,rect[i].p2)-len;        rect[i].q1=lower_bound(len+1,len+cnt+1,rect[i].q2)-len;    }    sort(point+1,point+n+1,cmp);    sort(rect+1,rect+m+1,cmp1);    int pos=0;    for(int i=1;i&lt;=m;i++){        while(rect[i].p1&gt;point[pos+1].x&amp;&amp;pos&lt;=n){            pos+=1;            add(1,1,n,point[i].y);        }        ans[rect[i].id]-=query(1,1,n,rect[i].p2,rect[i].q2);    }    memset(tree,0,sizeof(tree));    sort(rect+1,rect+m+1,cmp);    pos=0;    for(int i=1;i&lt;=m;i++){        while(rect[i].q1&gt;=point[pos+1].x&amp;&amp;pos&lt;=n){            pos+=1;            add(1,1,n,pos[i].y);        }        ans[rect[i].id]+=query(1,1,n,rect[i].p2,rect[i].q2);    }    for(int i=1;i&lt;=m;i++)printf(\"%d\\n\",ans[i]);    return 0;}\n\n\n\n平衡树-Splay\n\n\n\n平衡树-FHQ_Treap无旋Treap\n无旋Treap的结构\n基本操作\n\n\n\n\n\n案例struct NODE {    int val;    int cnt;    int rev;    int prio;    int size;    int ch[2];}struct FHQTREAP {    int root;    int size;    NODE node[MAXN];}pair&lt;int, int&gt; split_by_val(int t, int val) {    if (!t) {        return {0, 0};    }    check_rev(t);    if (node[t].val &lt;= val) {        auto tmp = split_by_val(node[t].ch[1], val);        node[t].ch[1] = tmp.first;        update_size(t);        return {t, tmp.second};    } else {        auto tmp = split_by_val(node[t].ch[0], val);        node[t].ch[0] = tmp.second;        update_size(t);        return {tmp.first, t};    }}tuple&lt;int, int, int&gt; split_by_rank(int t, int k) {    if (!t) {        return {0, 0, 0};    }    check_rev(t);    int lt, mt, rt;    if (k &lt;= node[node[t].ch[0]].size()) {        tie(lt, mt, rt) = split_by_rank(node[t].ch[0], k);        node[t].ch[0] = rt;        update_size(t);        return {lt, mt, t};    } else if (k &gt; node[node[t]].ch[0].size() + node[t].cnt) {        tie(lt, mt, rt) = split_by_rank(node[t].ch[1], k - node[node[t].ch[0]].size() - node[t].cnt);        node[t].ch[1] = lt;        update_size(t);        return {t, mt, rt};    } else {        lt = node[t].ch[0];        rt = node[t].ch[1];        check_rev(lt);        check_rev(rt);        node[t].ch[0] = 0;        upda[t].ch[1] = 0;        update_size(t);        return {lt, t, rt};    }}int merge(int lt, int rt) {    if (!lt) {        return rt;    } else if (!rt) {        return lt;    }    check_rev(lt);    check_rev(rt);    if (node[lt].prio &lt; node[rt].prio) {        node[lt].ch[1] = merge(node[lt].ch[1], rt);        update_size(lt);        return lt;    } else {        node[rt].ch[0] = merge(lt, node[rt].ch[0]);        update_size(rt);        return rt;    }}void insert(int val) {    int lt, mt, rt;    tie(lt, rt) = split_by_val(root, val);    tie(lt, mt) = split_by_val(lt, val - 1);    if (!mt) {        mt = new_node(val);    } else {        node[mt].cnt ++;        update_size(mt);    }    root = merge(merge(lt, mt), rt);}void del(int val) {    int lt, mt, rt;    tie(lt, rt) = split_by_val(root, val);    tie(lt, mt) = split_by_val(lt, val - 1);    unode[mt].cnt --;    update_size(mt);    if (node[mt].cnt == 0) {        clear(mt);    } else {        lt = merge(lt, mt);    }    root = merge(lt, rt);}void reverse(int l, int r) {    int t1, t2, t3, t4, t5;    tie(t1, t2, t3) = split_by_rank(root, l - 1);    tie(t3, t4, t5) = split_by_ranl(t3, r - l + 2);    node[t3].rev = 1;    root = merge(merge(merge(merge(t1, t2), t3), t4), t5);}void check_rev(int t) {    if (node[t].rev) {        swap(node[t].ch[0], node[t].ch[1]);        node[node[t].ch[0]].rev ^= 1;        node[node[t].ch[1]].rev ^= 1;        node[t].rev = 0;    }}int rank(int val) {    auto tmp = split_by_val(root, val - 1);    int k = node[tmp.first].size + 1;    root = merge(tmp.first, tmp.second);    return k;}int kth(int &amp;t, int k) {    int lt, mt, rt;    tie(lt, mt, rt) = split_by_rank(t, k);    int val = node[mt].val;    t = merge(merge(lt, mt), rt);    return val;}int pre(int val) {    auto tmp = split_by_cal(root, val - 1);    int k = kth(tmp.first, node[tmp.first].size);    root = merge(tmp.first, tmp.second);    return k;}int nxt(int val) {    auto tmp = split_by_val(root, val);    int k = kth(tmp.second, 1);    root = merge(tmp.first, tmp.second);    return k;}\n\n单调栈\n\n模板题——百亿富翁def right_bigger():  ans=[-1]*n  stack=[]  for i in range(n):    while stack and h[stack[-1]]&lt;h[i]:      ans[stack[-1]]=i+1      stack.pop()    stack.append(i)  return ansdef left_bigger():  ans=[-1]*n  stack=[]  for i in range(n-1,-1,-1):    while stack and h[stack[-1]]&lt;h[i]:      ans[stack[-1]]=i+1      stack.pop()    stack.append(i)  return ansimport sysn=int(input())h=list(map(int,input().split()))print(*left_bigger())print(*right_bigger())\n\n\n\n分块字符串KMP&amp;字符串哈希模式匹配\n\nKMP算法\n\n\n\n模板题——斤斤计较的小ZNext = [0] * 1000010def get_next(T):    for i in range(1,len(T)):        j = Next[i]        while j &gt; 0 and T[i] != T[j]:            j = Next[j]        if T[i] == T[j]:            Next[i + 1] = j + 1        else:            Next[i + 1] = 0def KMP(s,t):    get_next(t)    ans = 0    j = 0    for i in range(len(s)):        while j &gt; 0 and s[i] != t[j]:            j =  Next[j]        if s[i] == t[j]:            j += 1        if j == len(t):            ans += 1            j =  Next[j]    return anst = input()s = input()print(KMP(s,t))\n\nprint((lambda s: input().count(s))(input()))\n\n字符串哈希\n\n模板题——斤斤计较的小Zt = input()s = input()m,n = len(t), len(s)B = 26mod = 1000000007hash = [0] * (n + 1)for i in range(1,n + 1):    hash[i] = hash[i - 1] * B + ord(s[i - 1]) - ord('A')    hash[i] %= modnumT = 0for c in t:    numT = numT * B + ord(c) - ord('A')    numT %= mod    p = (B ** m) % modans = 0for l in range(1,n +1):    r = l + m - 1    if r &gt; n:        break    if (hash[r] - hash[l - 1] * p % mod + mod) % mod == numT:        ans += 1print(ans)\n\nManacher\n模板\n字典树基础\n\n\n模板题——前缀判定class TreeNode():  def __init__(self):    self.nodes = {}    #插入  def insert(self,s):    curr = self    for i in s:      if i not in curr.nodes.keys():        curr.nodes[i] = TreeNode()      #往下走      curr = curr.nodes[i]    #检查是否为前缀  def pre(self,s):    curr = self    for i in s:      if i not in curr.nodes.keys():        return False      curr = curr.nodes[i]    return Truen,m = map(int,input().split())tree = TreeNode()for _ in range(n):  s = input()  tree.insert(s)for _ in range(m):  t = input()  if tree.pre(t):    print('Y')  else:    print('N')\n\n模板题——依依的瓶中信'''多个字符串，求公共前缀长度问题，用字典树同一个字符串不可与自身比较：构建树的时候打标记，查找的时候清除标记，若标记为0，则说明当前在于自己比较，直接返回。'''class TreeNode():  def __init__(self):    self.nodes = {}          #用于存放以当前点为根的子树    self.value = 1           #每可子树的权值，初始为1  def insert(self,s):#建树    for c in s:      if c not in self.nodes.keys():     #若不存在，则添加该子树        self.nodes[c] = TreeNode()      else:        self.nodes[c].value +=1       #若存在，则该子树的权值+1，      self = self.nodes[c]          #进入下一层#{1,a:{2,b:{2,c:{1,}}},b:{1,c:{1}}}  def commen_pre(self,t):  #查找    cnt = 0    for c in t:           #该题不用判断c是否存在，因为每个点都存在      if self.nodes[c].value -1 == 0:    #如果走到自己独有的节点上时，就返回其与其它子串的公共前缀长        return cnt      cnt += 1      self = self.nodes[c]   #进入下一层    return cnt    #若自己本身就是某个串的前缀，则返回自己的长度n = int(input())S =[]tree = TreeNode() #实例化根节点for i in range(n):  #建树  s = input()  S.append(s)  tree.insert(s)for s in S:      #查找、统计  print(tree.commen_pre(s))\n\n\n\n01tire\n\nmaxn = 210000ch = [[0]*2 for _ in range(maxn)]val = [0]*maxnn, ans, tot = 0, 0, 0def insert(x):    global tot    now = 0    for j in range(31, -1, -1):        pos = ((x &gt;&gt; j) &amp; 1)        if ch[now][pos] == 0:            tot += 1            ch[now][pos] = tot        now = ch[now][pos]    val[now] = xdef query(x):    now = 0    for j in range(31, -1, -1):        pos = ((x &gt;&gt; j) &amp; 1)        if ch[now][pos ^ 1] != 0:            now = ch[now][pos ^ 1]        else:            now = ch[now][pos]    return val[now]n = int(input())for i in range(1, n+1):    x = int(input())    insert(x)for i in range(1, n+1):    ans = max(ans, query(val[i]))print(ans)\n\n图论基础基本概念\n\n\n\nDFS&amp;BFS\n\nDFS模板题——帮派弟位n,m=map(int,input().split())G=[[] for i in range(n+1)]#bfs和图的结合rudu=[0]*(n+1) #计数，根结点是没有rudu的biaoji=[0]*(n+1)sum=[[0,i] for i in range(n+1)] #注意是二元组，记录子数数量，是先按数量排，再按序号排.然后是包括他自己的，所以初始化为1for _ in range(n-1):    l,r=map(int,input().split()) #表示序号为l的人附属于r    G[r].append(l) #表示r下面有l 可以看出r和谁相邻    rudu[l]+=1 #表明l头上是有父亲的for i in range(1,n+1): #找出谁的rudu为0，即找出谁是根结点    if rudu[i]==0:        root=idef dfs(u):    biaoji[u]=1 #打上标记    sum[u][0]=-1#为什么这里设置成-1，而不是1呢，因为题目要求如果手下相同的，序号小的排在前面，设置成-1就可以这样了。！    for v in G[u]: #遍历和u相邻的每个节点        if biaoji[v]==0: #如果没有打上标记            dfs(v)#遍历和u相邻的节点，就是遍历子节点            sum[u][0]+=sum[v][0] #遍历v子节点的同时，可以把v下的子节点也加上去dfs(root)sum.sort()for i,(x,y) in enumerate(sum,start=1):#输出小明的排列    if y==m:        print(i)        break\n\n\n\nBFS模板题——最少操作数from collections import dequedef bfs(s,t):    '''    :param s: 起点    :param t: 终点    :return:    '''    dis = [-1]*100001    queue = deque()    #1、将起点塞入到队列中，打上标记    queue.append(s)    dis[s] = 0    #2、当队列非空    while len(queue) != 0:        # 2.1 取出队首元素u        u = queue.popleft()        #2.2 判断u是否为终点        if u == t:            return dis[u]        #2.3 将u相连的所有点v，只要v未标记，则入队列        for v in [u-1,u+1,u*2]:            #特判：未越界、未标记            if 0&lt;=v&lt;=100000 and dis[v] == -1:                queue.append(v)                dis[v] = dis[u] + 1    return -1n,k = map(int,input().split())print(bfs(n,k))\n\nBFS模板题——混境之地4import osimport sys# 请在此输入您的代码#  3819 混境之地# BFS遍历  经典题目\"\"\"\"\"\"from collections import deque  # 使用队列INF = 0x3f3f3f3f   # 对应的十进制为：1061109567，一般的数据小于10^9，因此可将其作为一个边界def BFS(x, y, dist):    # 从(x, y)到每个点的最短时间    queue = deque()    vis = [[0] * m for i in range(n)]    # 1、将起点加入队列    queue.append([x, y])    dist[x][y] = 0  # 更新距离    vis[x][y] = 1  # 打标记    # 2、当队列非空    while len(queue) != 0:        x, y = queue.popleft()        # 对于每个相邻的点，都进行一次判断        for deltax, deltay in [(1, 0), (0, 1), (-1, 0), (0, -1)]:            xx, yy = x + deltax, y + deltay            # 未越界、未标记、非障碍物            if 0 &lt;= xx &lt; n  and 0 &lt;= yy &lt; m and g[xx][yy] != \"#\" and vis[xx][yy] == 0:                queue.append([xx, yy])                dist[xx][yy] = dist[x][y] + 1                vis[xx][yy] = 1n, m = map(int, input().split())A, B, C, D = map(int, input().split())A, B, C, D = A-1, B-1, C-1, D-1# 输入图g = [input() for i in range(n)]E = int(input())# dist1[i][j]表示起点到(i, j)的最短时间dist1 = [[INF] * m for i in range(n)]  # INF无穷大# dist2[i][j]表示终点到(i, j)的最短时间dist2 = [[INF] * m for i in range(n)]BFS(A, B, dist1)  # 起点做一遍BFS(C, D, dist2)  # 终点做一遍# 判断能否直接走到终点res = dist1[C][D]if res &lt;= E:    print(res)else:    # 枚举所有的圣泉    res = INF    for i in range(n):        for j in range(m):            # 能量E不可小于0，可以等于0            if g[i][j] == 'V' and dist1[i][j] &lt;= E:  # 不需要经过多个圣泉                res = min(dist1[i][j] + dist2[i][j], res)    # 如果走不到圣泉    if res == INF:        print('No')    else:        # 初始能量为E，总共距离为res，相当于，后面的res-E需要花费两倍时间，因为需要等待能量恢复        print((res - E) * 2 + E)\n\n拓扑排序\n\n\n模板题——走多远import osimport sysfrom collections import deque# INF = 0x3f3f3f3f# 针对有向无环图，在进行拓扑排序时，可以进行状态转移def topo():    q = deque()    # 1。将入度为0的点加入队列中    for i in range(1, n + 1):        if ru[i] == 0:            q.append(i)    # 2. 当队列非空    while len(q) != 0:        # 2.1 取出队首元素        u = q.popleft()        # 2.2 对于和u相连的每个点v        for v in G[u]:            # 从u走到v，说明dp[v]可以从dp[u]+1转移            dp[v] = max(dp[v], dp[u] + 1)            # 进行动态规划            ru[v] -= 1            if ru[v] == 0:                q.append(v)n, m = map(int, input().split())# 图的存储——邻接表G = [[] for i in range(n+1)]ru = [0] * (n + 1)for i in range(m):    u, v = map(int, input().split())    G[u].append(v)    ru[v] += 1# dp[i]表示走到i的最长路/最大值dp = [0] * (n + 1)topo()print(max(dp))\n\n模板题——最小字典序排列import osimport sys# 3351 最小字典序排列# 拓扑排序+优先队列# 需要字典序最小的拓扑序列，只需要将普通队列转换成优先队列即可from collections import dequefrom queue import PriorityQueuedef topo():    q = PriorityQueue()    # 1。将入度为0的点加入队列中    for i in range(1, n + 1):        if ru[i] == 0:            q.put(i) # append改为put    # 2. 当队列非空    ans = []    while not q.empty(): # 判断优先队列q是否非空    # while len(q.queue) != 0:        # 2.1 取出队首元素        u = q.get()  # popleft改为put        ans.append(u)        # 2.2 对于和u相连的每个点v        for v in G[u]:            # 进行动态规划            ru[v] -= 1            if ru[v] == 0:                q.put(v)    if len(ans) != n:        print(-1)    else:        print(*ans, sep = ' ')n, m = map(int, input().split())# 图的存储——邻接表G = [[] for i in range(n+1)]ru = [0] * (n + 1)for i in range(m):    u, v = map(int, input().split())    G[u].append(v)    ru[v] += 1topo()\n\n最短路Floyd\n\n模板题—— 蓝桥公园import sysinput=sys.stdin.readlinen,m,q=map(int,input().split())inf=int(1e18)dp=[[inf]*(n+1) for i in range(n+1)]for i in range(1,n+1):  dp[i][i]=0for i in range(1,m+1):  u,v,w=map(int,input().split())  dp[u][v]=dp[v][u]=min(dp[u][v],w)#Floyd 模板for k in range(1,n+1):  for i in range(1,n+1):    for j in range(1,n+1):      dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])for i in range(1,n+1):    for j in range(1,n+1):      if dp[i][j]==inf:        dp[i][j]=-1for _ in range(q):  s,e=map(int,input().split())  print(dp[s][e])\n\n# Floyd 算法  多个起点--多个终点  多源最短路算法（多对多）# 最简单的最短路径算法# 存图:最简单的矩阵存图# 效率不高，不能用于大图# 动态规划：求图上两点i,j之间的最短距离，按‘从小图到全图’的步骤，在逐步扩大图的过程中计算和更新最短路# 定义状态：dp[k][i][j]: i,j,k是点的编号，范围1--n# 状态dp[k][i][j]表示在包含1--k点的子图上，点对i,j之间的最短路# 状态转移方程 从子图1-k-1 扩展到子图 1-k# dp[k][i][j]=min(dp[k-1][i][j],dp[k-1][i][k]+dp[k-1][k][j])# 初始值：i,j直连 就是他们的边长； 若不直连，赋值为无穷大 / 0x3f3f3f3f3f3f3f3f# 滚动数组优化：dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])#                           不经过k     经过k# for k in range(1,n+1):# for i in range(1,n+1):# for j in range(1,n+1):# dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])# 只能用于n&lt;300 的小规模图def floyd():    global dp    for k in range(1,n+1):        for i in range(1, n + 1):            for j in range(1, n + 1):                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])# 蓝桥公园# n个点 m条边 q次查询n,m,q=map(int,input().split())INF = 0x3f3f3f3f3f3f3f3fdp=[[INF for _ in range(n+50)] for _ in range(n+50)]# 记录路径for i in range(1,m+1):    u,v,w=map(int,input().split())    dp[u][v]=dp[v][u]=min(dp[u][v],w)floyd()for _ in range(q):    start,end=map(int,input().split())    # 无法到达    if dp[start][end]==INF:        print(-1)    # 起点终点相同    elif start==end:        print(0)    else:        print(dp[start][end])# 1-12\n\nimport osimport sys# 请在此输入您的代码N, M, Q = map(int, input().split())weight = [[0 if i == j else sys.maxsize for i in range(N + 1) ] for j in range(N + 1)]  # 领接矩阵for i in range(M):    u, v, w = map(int, input().split())    weight[u][v] = min(weight[u][v], w)    weight[v][u] = weight[u][v]for k in range(1, N + 1):  # N次递推    for i in range(1, N + 1):        for j in range(i + 1, N + 1):  # 更新最小值                weight[i][j] = min(weight[i][j], weight[i][k] + weight[k][j])                weight[j][i] = weight[i][j]for i in range(Q):    st, ed = map(int, input().split())    t = weight[st][ed]    if t == sys.maxsize:        print(-1)    else:        print(t)\n\n模板题——城市间的交易import osimport sys# 请在此输入您的代码# 8336 城市间的交易INF =1e18n, m = map(int, input().split())# 产量、成本和售价a, p, s = [0] * (n+1), [0] * (n+1), [0] * (n+1)f = [[INF] * (n+1) for i in range(n+1)]g = [[0] * (n+1) for i in range(n+1)]for i in range(1, n+1):    a[i], p[i], s[i] = map(int, input().split())# 邻接矩阵初始化for i in range(1, m+1):    u, v, w = map(int, input().split())    f[u][v] = f[v][u] = min(f[u][v], w)for i in range(1, n+1):    f[i][i] = 0# Floydfor k in range(1, n+1):    for i in range(1, n+1):        for j in range(1, n+1):            f[i][j] = min(f[i][j], f[i][k]+f[k][j])# g[i][j]表示城市i的物品运输到城市j可得到的利润 = 城市j的售价 - 城市i的成本 - 从i到j的运输成本ans = 0for i in range(1, n+1):    # 求每个城市的利润    cnt = 0    for j in range(1, n+1):        g[i][j] = s[j] - p[i] - f[i][j]        cnt = max(cnt, g[i][j])    ans += a[i] * cntprint(ans)\n\nimport osimport sysn,m=map(int,input().split())res=[]for _ in range(n):  a,p,s=map(int,input().split())  res.append((a,p,s))inf=int(1e10)path=[[inf]*(n+1) for _ in range(n+1)]for _ in range(m):  u,v,w=map(int,input().split())  path[u][v]=path[v][u]=min(w,path[u][v])for i in range(1,1+n):  path[i][i]=0for k in range(1,n+1):  for i in range(1,n+1):    for j in range(1,n+1):      path[i][j]=min(path[i][j],path[i][k]+path[k][j])re=0for i in range(1,n+1):  result=0  for j in range(1,n+1):    if path[i][j]!=inf:       result=max(result,res[j-1][2]*res[i-1][0]-res[i-1][0]*res[i-1][1]-path[i][j]*res[i-1][0])  re+=resultprint(re)\n\nDijkstra\n\n\n模板题——蓝桥王国import osimport sys# 请在此输入您的代码# 1122_蓝桥王国_Dijkstra算法from queue import PriorityQueue  # 导入优先队列from collections import dequeINF = 1e18def dijkstra(s):    # 返回从s出发到所有点的最短路    # d[i]表示从s到i的最短路    d = [INF] * (n + 1)    # vis[i]表示是否出队列（注：与传统BFS不同）    vis = [0] * (n + 1)    q = PriorityQueue()    # 1.将起点入队列，更新距离    d[s] = 0    # 将距离放在前面，才能对距离使用优先队列    q.put((d[s], s))  # 入队用put()    # 当队列非空    while not q.empty():  # 或者写为： while len(q.queue) != 0:        dis, u = q.get()        # 每个点只有第一次出队列是有用的        if vis[u]: continue        vis[u] = 1  # 出队列打标记        # 对于从u出发，到达v，权重为w的边        for v, w in G[u]:            if d[v] &gt; d[u] + w:                d[v] = d[u] + w                q.put((d[v], v))    for i in range(1, n + 1):        if d[i] == INF:            d[i] = -1    # d.pop(0)    return d[1::] # 从1到最后# 皇宫编号为1# 输入n, m = map(int, input().split())G = [[] for i in range(n + 1)]  # 图的存储：邻接表。此题N为10^5，不能用邻接矩阵存图for i in range(m):    u, v, w = map(int, input().split())    G[u].append((v, w))print(*dijkstra(1)) # 列表前面加星号作用是将列表解开（unpacke）成多个独立的参数，传入函数。\n\n模板题——混境之地3import osimport sys# 3818 混境之地  Dijkstrafrom queue import PriorityQueue# 数据较大时可以进行如下优化import sysinput = sys.stdin.readlineINF = 1e18def get(c):    if c == '.':        return 0    else:        s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'        for i in range(len(s)):            if c == s[i]:                return i + 1        # return ord(c) - ord('A') + 1def dijkstra():    d = [[INF] * m for _ in range(n)]    vis = [[0] * m for _ in range(n)]    q = PriorityQueue()  # 创建优先队列    # 1.将起点塞入队列    d[x1][y1] = 0    q.put((d[x1][y1], x1, y1))    # 2.当队列非空    while not q.empty():        dis, x, y = q.get()        if x == x2 and y == y2:            return dis        # 每个点只有第一次出队列是有用的        if vis[x][y]:            continue        vis[x][y] = 1  # 出队列打标记        for d elta_x, delta_y in [[1, 0], [0, 1], [-1, 0], [0, -1]]:            xx, yy = x + delta_x, y + delta_y            # 判断未越界、未标记、非障碍物            if 0 &lt;= xx &lt; n and 0 &lt;= yy &lt; m and vis[xx][yy] == 0 and Map[xx][yy] != \"#\":                if d[xx][yy] &gt; d[x][y] + get(Map[xx][yy]):  # 写一个get函数获取权重                    d[xx][yy] = d[x][y] + get(Map[xx][yy])                    q.put((d[xx][yy], xx, yy))    return INF# 输入n, m = map(int, input().split())  # 地图大小x1, y1, x2, y2 = map(int, input().split())  # 起始点坐标x1, y1, x2, y2 = x1 - 1, y1 - 1, x2 - 1, y2 - 1# 地图Map = [input() for i in range(n)]e = int(input())  # 剩余能量# 如果能量支撑到达终点，返回Yes，否则，返回No.if e &gt;= dijkstra():  # 不传参，使用全局变量    print('Yes')else:    print('No')\n\n生成树Kruskal\n\n模板题——繁忙的都市def kruskal():    # 初始化    n, m = map(int, input().split())    Map = []    for _ in range(m):        u, v, w = map(int, input().split())        Map.append([w, u, v])  # 注意第一个参数是边权    Map.sort()    # 并查集    p = list(range(n+1))    def root(x):        if x != p[x]:            p[x] = root(p[x])        return p[x]    # 非连环时更新    _sum, _max = 0, 0    for w, u, v in Map:        root_u = root(u)        root_v = root(v)        if root_u != root_v:            p[root_u] = root_v            _sum += 1            _max = max(_max, w)    return _sum, _maxprint(*kruskal())\n\nPrim\n\n\n\n模板题——繁忙的都市import osimport sysn,m=map(int,input().split())e=[]for  _ in range(m):  u,v,w=map(int,input().split())  e.append((w,u,v))#边按照权重进行排序e.sort()#需要一个并查集p=list(range(n+1))def findroot(x):  if x==p[x]:return x  else:    p[x]=findroot(p[x])    return p[x]ans=0#进行遍历所有的边，进行合并：for w,u,v in e:  #只要u和v不在同一集合内就可以进行合并：  rootu=findroot(u)  rootv=findroot(v)  if rootu!=rootv:    p[rootu]=rootv    ans=max(ans,w)print(n-1,ans)\n\n\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]组合数学","url":"/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","content":"组合数学计数原理：加法原理\n加法原理： 集合  被分成两两不相交的部分 ，那么  的对象数目等于：\n\n例： 一个学生想学一门数学课，一门文化课，但不能同时选，现在从  门数学课和  门文化课中选，一共有  种方法选一门课。\n\n加法原理的关键是将计数分解为若干个独立（不相容）的部分，保证既不重复也不遗漏地进行计数。 加法原理是利用完备事件组的一个体现，我们可以利用一个集合的补记做题。\n\n\n例题：分割立方体 lanqiaoOJ 题号 1620题目描述： 一个立方体，边长为 ，分割成  个单位立方体。任意两个单位立方体，或者有  个公共点，或者有  个公共点，或者没有公共点。请问，没有公共点和有  个公共点的立方体，共有多少对？\n输入描述： 一个整数 ，\n思路： 反过来计算，先算出有  个公共点的立方体有多少对，然后用总对数减去。分几种情况讨论：\n\n正方体和周围  个正方体相邻，这种情况共有  个，就是顶角上的  个，总个数 ；\n正方体和周围  个正方体相邻，这种情况共有  个 （棱）总个数 ；\n正方体和周围  个正方体相邻，这种情况共有  个，总个数 ；\n正方体和周围  个正方体相邻，这种情况共有  个，总个数 ； 最后把这  个情况求和再除以 。\n\n正方体一共  个，共有  种关系\n\n正方体和周围  个正方体相邻，总个数 ；\n正方体和周围  个正方体相邻，总个数 ；\n正方体和周围  个正方体相邻，总个数 ；\n正方体和周围  个正方体相邻，总个数 ；\n最后把这  个情况求和再除以 。\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n; cin &gt;&gt; n;    if(n == 1){             // 边长为 1 时特判        cout &lt;&lt; 0 &lt;&lt; endl;        return 0;    }    long long sum = n * n * n * (n * n * n - 1) / 2;     //总数    int edge3 = 8;    int ans3 = 3 * edge3;    int edge4 = (n - 2) * 12;    int ans4 = 4 * edge4;    int edge5 = n * n - 4 * n + 4;    int ans5 = 5 * 6 * edge5;    int edge6 = n * n * n - n * n * 6 + n * 12 - 8;    int ans6 = 6 * edge6;    cout &lt;&lt; sum - (ans3 + ans4 + ans5 + ans6) / 2 &lt;&lt; endl;    return 0;}\n\nn = int(input())if n == 1: # 边长为 1 时特判    print(0)else:    sum = n * n * n * (n * n * n - 1) // 2 # 总数    edge3 = 8    ans3 = 3 * edge3    edge4 = (n - 2) * 12    ans4 = 4 * edge4    edge5 = n * n - 4 * n + 4    ans5 = 5 * 6 * edge5    edge6 = n * n * n - n * n * 6 + n * 12 - 8    ans6 = 6 * edge6    print(sum - (ans3 + ans4 + ans5 + ans6) // 2)\n\nimport java.util.*;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        if (n == 1) { // 边长为 1 时特判            System.out.println(0);            return;        }        long sum = (long) n * n * n * (n * n * n - 1) / 2; // 总数        int edge3 = 8;        int ans3 = 3 * edge3;        int edge4 = (n - 2) * 12;        int ans4 = 4 * edge4;        int edge5 = n * n - 4 * n + 4;        int ans5 = 5 * 6 * edge5;        int edge6 = n * n * n - n * n * 6 + n * 12 - 8;        int ans6 = 6 * edge6;        System.out.println(sum - (ans3 + ans4 + ans5 + ans6) / 2);    }}\n\n计数原理：乘法原理令  是对象的有序对  的集合，其中第一个对象  来自大小为  的一个集合，对于对象  的每个选择，对象  有  个选择，那么  的大小：\n例：中性笔的长度有  种，颜色有  种，直径有  种。不同种类的中性笔有： 种。\n例： 的正整数因子有多少？答：这是算数基本定理的概念。 有  ~  这  种选择， 有  个选择， 有  个选择， 有  个选择，因子总数是  种。\n排列数排列是有序的。\n不可重复排列数：从  个不同的物品中取出  个，排列数为：\n\n可重复排列数，从  个不同的物品中可重复地取出  个的排列数为：。\n组合数排列是有序的，组合是无序的。\n如果  中的元素都不相同，组合数：\n\n糊涂人寄信 lanqiaoOJ 题号 1622题目描述： 有一个糊涂人，写了  封信和  个信封，到了邮寄的时候，把所有的信都装错了信封。求装错信封可能的种类数。\n输入描述： 每行输入一个正整数 ，表示一种情况。\n输出描述： 输出相应的答案。\n解题思路：题目建模为：有  个数字，分别放在  个位置，问都放错的情况有多少种。\n用 DP 来做。定义 ， 表示数字  都放错的种类数。 是答案。\n下面考虑状态转移方程，从  递推到 。\n数字  如果放错，有  个位置可以放，假设其放在第  个位置。对于数字 ，可以放在  位置也可以不放在  位置。\n如果  放在  位置，那么对于剩下  个数字放的次数，就是  个数字都放错的方法数 。\n如果  不放在  位置，和  个数字放错的情况相同，为 。\n状态转移方程：\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll dp[30];int main(){    dp[1]= dp[0]=0;    dp[2]=1;    for(int i=3;i&lt;=22;i++) dp[i]=(i-1)*(dp[i-1]+dp[i-2]);    int n;    while(cin&gt;&gt;n) cout&lt;&lt;dp[n]&lt;&lt;endl;    return 0;}\n\nimport sysdef f(n):    if n==0 or n==1: return 0    elif n==2:  return 1    else:  return (n-1)*(f(n-1)+f(n-2))for n in sys.stdin:   #读入n，和C++代码的while(cin&gt;&gt;n)功能一样    n = int(n)    print(f(n))\n\nimport java.util.Scanner;public class Main {    static long[] dp = new long[30];    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        dp[1] = dp[0] = 0;        dp[2] = 1;        for (int i = 3; i &lt;= 22; i++) {            dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]);        }        while (sc.hasNext()) {            int n = sc.nextInt();            System.out.println(dp[n]);        }        sc.close();    }}\n\n鸽巢原理鸽巢原理，又称抽屉原理。\n鸽巢原理： 把  个物体放进  个盒子，至少有一个盒子包含  个或更多的物体。\n\n例：在  人中，至少有  人生日相同；\n例： 个人互相握手，一定有  个人握手次数相同。\n\n例： 个人互相握手，一定有  个人握手次数相同。 每人跟其他人握手，最少可以是  次，最多可以是次。 如果握手最少的是  次，那么剩下的人中，握手最多的人不会超过次。 共种情况。 如果握手最少的张三是  次，那么剩下的人中，握手最多的李四除了跟张三握手一次，跟其他人最多握手次，李四最多握手次。 共种情况。 如果握手最少的张三是  次，那么剩下的人中，握手最多的李四除了跟张三握手一次，跟其他人最多握手次，李四最多握手次。 共种情况。 …… 所以握手次数最多有种情况，最少只有  种情况。 把最多的种情况看成个抽屉，个人放进这个抽屉，至少有一个抽屉里面有  人。\n例题：小蓝吃糖果 lanqiaoOJ 题号 1624题目描述： Gardon 有  种糖果，每种数量已知。Gardon 不喜欢连续  次吃同样的糖果。问有没有可行的吃糖方案。\n输入： 第一行是整数 N，，第二行是  个数，表示  种糖果的数量 ，\n输出： 输出一行，包含一个 “Yes” 或 “no”。\n解题思路继续处理格式，鸽巢原理，用“隔板法”求解。\n找出最多的一种糖果，把它的数量  看成  个隔板，隔成  个空间（把每个隔板的右边看成一个空间）；其它所有糖果的数量为 。\n最多的一种糖果，把它的数量  看成  个隔板，隔成  个空间（把每个隔板的右边看成一个空间）；其它所有糖果的数量为 。\n\n（1）如果 ，把  个糖果放到隔板之间，这  个隔板不够放，必然至少有 2 个隔板之间没有糖果，由于这 2 个隔板是同一种糖果，所以无解。\n（2） 时，肯定有解。其中一个解是：把  个糖果排成一个长队，其中同种类的糖果是挨在一起的，然后每次取  个糖果，按顺序一个一个地放进  个空间。由于隔板数量比每一种糖果的数量都多，所以不可能有  个同样的糖果被放进一个空间里。把  个糖果放完，就是一个解，一些隔板里面可能放好几种糖果。\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int a[1005000];int main(){    long long sum=0;    int Max=0;    int n; scanf(\"%d\",&amp;n);    for(int i=1;i&lt;=n;i++){        scanf(\"%d\",&amp;a[i]);        sum += a[i];              //所有糖果数量        if(a[i]&gt;Max)  Max=a[i];   //最多的一种糖果    }    if(sum-Max+1&gt;=Max) printf(\"Yes\\n\");    else               printf(\"No\\n\");return 0;}\n\nn=int(input())a=list(map(int,input().split()))if sum(a)-max(a) &lt; max(a)-1:    print(\"No\")else:    print(\"Yes\")\n\nimport java.util.*;public class Main {    public static void main(String[] args) {        Scanner input = new Scanner(System.in);        long sum = 0;        int max = 0;        int n = input.nextInt();        for (int i = 1; i &lt;= n; i++) {            int x = input.nextInt();            sum += x;            if (x &gt; max) {                max = x;            }        }        if (sum - max + 1 &gt;= max) {            System.out.println(\"Yes\");        } else {            System.out.println(\"No\");        }    }}\n\n二项式定理和杨辉三角杨辉三角：排列成如下三角形的数字\n      1    1   1   1  2  1 1   3  3  11  4   6  4  1\n\n每个数是它上面  个数的和。\n求杨辉三角第  行的数字，可以模拟这个推导过程，逐级递推，复杂度 。\n用数学公式计算，可以直接得到结果，这个公式是。\n\n二项式系数就是 展开后第  项的系数。\n\n对应杨辉三角的第  行第  个数是\n例：杨辉三角的第  行是“”，\n、、、\n理解： 的第  项，就是从  个  中选出  个，这就是组合数的定义\n当 n 较大，且需要取模时，二项式系数有两种计算方法：\n（1）递推公式：\n公式是杨辉三角的定义，即“每个数是它上面  个数的和”。计算复杂度是 。\n（2）用逆直接计算\n因为输出取模，那么不用递推公式，直接用公式计算更快。不过，由于除法不能直接取模，需要用到逆。用逆计算二项式系数，有：\n\n\n用逆计算二项式系数，复杂度是  的。\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]蓝桥习题","url":"/2024/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%93%9D%E6%A1%A5%E4%B9%A0%E9%A2%98/","content":"门牌制作题目描述本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。\n小蓝要为一条街的住户制作门牌号。\n这条街一共有  位住户，门牌号从  到  编号。\n小蓝制作门牌的方法是先制作  到  这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 、、、，即需要  个字符 ， 个字符 ， 个字符 。\n请问要制作所有的  到  号门牌，总共需要多少个字符 ？\n运行限制\n最大运行时间：1s\n最大运行内存: 128M\n\n常规思路s=[]for i in range(1,2021):    s.append(i)s=str(s)print(s.count(\"2\"))\n\ns=''for i in range(1,2021):s+=str(i)print(s.count(\"2\"))\n\n似乎熟悉了python之后，用python求解也很快。\n简单方法使用excel的功能\n使用序列\n使用快捷键CTRL+H，唤出替换，替换所有的2。\n\n可以快速得到结果624，准确又省时间。\n迷宫题目描述本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。\nX 星球的一处迷宫游乐场建在某个小山坡上。它是由  相互连通的小房间组成的。\n房间的地板上写着一个很大的字母。我们假设玩家是面朝上坡的方向站立，则：\n\n 表示走到左边的房间，\n 表示走到右边的房间，\n 表示走到上坡方向的房间，\n 表示走到下坡方向的房间。\n\nX 星球的居民有点懒，不愿意费力思考。他们更喜欢玩运气类的游戏。这个游戏也是如此！\n开始的时候，直升机把  名玩家放入一个个小房间内。玩家一定要按照地上的字母移动。\n迷宫地图如下：\nUDDLUULRUL  UURLLLRRRU  RRUURLDLRD  RUDDDDUUUU  URUDLLRRUU  DURLRLDLRL  ULLURLLRDU  RDLULLRDDD  UUDDUDUDLL  ULRDLUURRR  \n\n请你计算一下，最后，有多少玩家会走出迷宫，而不是在里边兜圈子？\n如果你还没明白游戏规则，可以参看下面一个简化的 4x4 迷宫的解说图：\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n解题思路str='UDDLUULRULUURLLLRRRURRUURLDLRDRUDDDDUUUUURUDLLRRUUDURLRLDLRLULLURLLRDURDLULLRDDDUUDDUDUDLLULRDLUURRR'sum=0 #计算有几个人出来for i in range(100):  a=i//10 #一个点的坐标（a，b）  b=i%10  c = [{a:b}] #用于存放经过的点，若重复经过，说明走不出去了  while(1):    if(str[a*10+b]=='U'):      a=a-1    elif (str[a*10+b]=='D'):      a=a+1    elif (str[a*10+b]=='L'):      b=b-1    else:      b=b+1    if({a:b} in c):      break    if({a:b} not in c):      c.append({a:b})    if(a&lt;0 or a&gt;9 or b&lt;0 or b&gt;9):      sum+=1      breakprint(sum)\n\nDFS解法：\ndef dfs(x,y):  if 0&lt;=x&lt;10 and 0&lt;=y&lt;10:     if v[x][y] == 0:      v[x][y] = 1   #打上标识，证明此处已走过      if map[x][y] == 'U':        flag = dfs(x-1,y)      elif map[x][y] == 'D':        flag = dfs(x+1,y)      elif map[x][y] == 'L':        flag = dfs(x,y-1)      elif map[x][y] == 'R':        flag = dfs(x,y+1)      v[x][y] = 0  #按层返回，清除标识      return flag      else:  #如果回到已经走过的地方，说明发生循环，直接返回0标识走不出去      return 0  else:      #超限说明走出去了  返回1    return 1n = 0map = [list(input()) for i in range(10)] #读入迷宫v = [[0]*10 for i in range(10)]  #列表v用来标识该点是否重复经过，避免循环for i in range(10):  for j in range(10):    n += dfs(i,j)   #对每一个人进行走出迷宫的模拟，n记录最后能走出的人的总数print(n)\n\n#深度dfs递归map = ['UDDLUULRUL',       'UURLLLRRRU',       'RRUURLDLRD',       'RUDDDDUUUU',       'URUDLLRRUU',       'DURLRLDLRL',       'ULLURLLRDU',       'RDLULLRDDD',       'UUDDUDUDLL',       'ULRDLUURRR']#这里字符串元素要用单引号括起，用双引号，后面会提示数组越界count = 0tablist = [[0] * 10 for i in range(10)]def find(x, y):    if x &lt; 0 or x &gt; 9 or y &lt; 0 or y &gt; 9:  # 走出迷宫        global count        count += 1        return True    if tablist[x][y] == 1:  # 已走过        return False    tablist[x][y] = 1  # 若之前没走过，则标记走过    if map[x][y] == \"U\":        find(x - 1, y)#递归    elif map[x][y] == \"D\":        find(x + 1, y)    elif map[x][y] == \"L\":        find(x, y - 1)    elif map[x][y] == \"R\":        find(x, y + 1)    return Falsefor i in list(range(10)):    for j in list(range(10)):        tablist = [[0] * 10 for i in range(10)]#遍历每个坐标起点开始前都先清零        find(i, j)print(count)\n\n星期一题目描述本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。\n整个  世纪（ 年  月  日至  年  月  日之间），一共有多少个星期一？(不要告诉我你不知道今天是星期几)\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n解题思路直接用 Python datetime 库求解，第 6 行可以输出某个日期是星期几。\nfrom datetime import* dt1=datetime(1901,1,1) dt2=datetime(2000,12,31) print(dt1.weekday()) # 周一为0，周二为1... td=dt2-dt1 print(td.days//7)\n\n乘积尾零题目描述本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。\n如下的  行数据，每行有  个整数，请你求出它们的乘积的末尾有多少个零？\n5650 4542 3554 473 946 4114 3871 9073 90 4329 2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 1486 5722 3135 1170 4014 5510 5120 729 2880 9019 2049 698 4582 4346 4427 646 9742 7340 1230 7683 5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 6701 6645 1671 5978 2704 9926 295 3125 3878 6785 2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 689 5510 8243 6114 337 4096 8199 7313 3685 211\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n解题思路将字符串转换成表格，先计算乘积，然后结果由int整数型转换成str字符型，再存入列表中，这时候使用pop方法和列表切片，简单的遍历一下，就能得到结果。\ns=\"\"\"5650 4542 3554 473 946 4114 3871 9073 90 4329 2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 1486 5722 3135 1170 4014 5510 5120 729 2880 9019 2049 698 4582 4346 4427 646 9742 7340 1230 7683 5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 6701 6645 1671 5978 2704 9926 295 3125 3878 6785 2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 689 5510 8243 6114 337 4096 8199 7313 3685 211 \"\"\"cnt=1for i in s.split():cnt*=int(i)cnt,res = list(str(cnt)),0for i in cnt[::-1]:    if i == '0':        cnt.pop()        res+=1    else:breakprint(res)\n\n当然，也可以不使用列表\n\n付账问题题目描述几个人一起出去吃饭是常有的事。但在结帐的时候，常常会出现一些争执。\n现在有  个人出去吃饭，他们总共消费了  元。其中第  个人带了 元。幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？\n为了公平起见，我们希望在总付钱量恰好为  的前提下，最后每个人付的钱的标准差最小。这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 1 分钱的整数倍。你需要输出最小的标准差是多少。\n标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的”偏差有多大”。形式化地说，设第  个人付的钱为  元，那么标准差为 :\n\n输入描述第一行包含两个整数 、；\n第二行包含  个非负整数 。\n其中， 。\n输出描述输出最小的标准差，四舍五入保留 4 位小数。\n保证正确答案在加上或减去  后不会导致四舍五入的结果发生变化。\n输入输出样例示例\n输入\n\n5 2333 666 666 666 666 666\n\n\n输出\n\n0.0000\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n解题思路from math import *n, s = map(int,input().split())a = list(map(int,input().split()))a.sort()avg = s/nsum = 0for i in range(n):     if a[i]*(n-i) &lt; s:          sum += pow(a[i]-avg,2)          s -= a[i]     else:          cur_avg = s/(n-i);      #更新平均出钱数          sum += pow(cur_avg-avg,2)*(n-i)          breakprint(\"{:.4f}\".format(sqrt(sum/(n))))\n\n数字三角形题目描述\n上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和（路径上的每一步只可沿左斜线向下或右斜线向下走）。\n输入描述输入的第一行包含一个整数 ，表示三角形的行数。\n下面的  行给出数字三角形。数字三角形上的数都是  至  之间的整数。\n输出描述输出一个整数，表示答案。\n输入输出样例示例\n输入\n\n5 7 3 88 1 02 7 4 44 5 2 6 5\n\n\n输出\n\n30\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n42点问题题目描述请你设计一个程序对该问题进行解答。\n众所周知在扑克牌中，有一个老掉牙的游戏叫做  点，选取  张牌进行加减乘除，看是否能得出  这个答案。\n现在小蓝同学发明了一个新游戏，他从扑克牌中依次抽出6张牌，注意不是一次抽出，进行计算，看是否能够组成  点,满足输出 YES，反之输出 NO。\n最先抽出来的牌作为第一个操作数，抽出牌做第二个操作数，运算结果再当作第一个操作数，继续进行操作。\n注：除不尽的情况保留整数，而且扑克牌的四张  都丢了，不会出现 。\n请设计一个程序对该问题进行解答。\n输入描述输出仅一行包含  个字符。\n保证字符  3 4 5 6 7 8 9 10 J Q K A 2。\n输出描述若给出到字符能够组成  点 , 满足输出 YES，反之输出 NO。\n输入输出样例示例\n输入\n\nK A Q 6 2 3\n\n\n输出\n\nYES\n\n样例说明\n 即 \n 保留整数\n\n\n\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n数的划分题目描述将整数  分成  份，且每份不能为空，任意两份不能相同(不考虑顺序)。\n例如：，，下面三种分法被认为是相同的。\n，，，，，，\n问有多少种不同的分法。\n输入描述输入一行， 个整数 ，。\n输出描述输出一个整数，即不同的分法。\n输入输出样例示例 1\n输入\n\n7 3\n\n\n输出\n\n4\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n数的计算题目描述输入一个自然数 ，我们对此自然数按照如下方法进行处理:\n\n不作任何处理;\n\n在它的左边加上一个自然数,但该自然数不能超过原数的一半;\n\n加上数后,继续按此规则进行处理,直到不能再加自然数为止。\n\n\n问总共可以产生多少个数。\n输入描述输入一个正整数 。\n输出描述输出一个整数，表示答案。\n输入输出样例示例 1\n输入\n\n6\n\n\n输出\n\n6\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\nN皇后问题题目描述在  的方格棋盘放置了  个皇后，使得它们不相互攻击（即任意  个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成  角的斜线上。你的任务是，对于给定的 ，求出有多少种合法的放置方法。\n输入描述输入中有一个正整数 ，表示棋盘和皇后的数量\n输出描述为一个正整数，表示对应输入行的皇后的不同放置数量。\n输入输出样例示例 1\n输入\n\n5\n\n\n输出\n\n10\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n路径之谜题目描述小明冒充  星球的骑士，进入了一个奇怪的城堡。\n城堡里边什么都没有，只有方形石头铺成的地面。\n假设城堡地面是  个方格。如下图所示。\n\n按习俗，骑士要从西北角走到东南角。可以横向或纵向移动，但不能斜着走，也不能跳跃。每走到一个新方格，就要向正北方和正西方各射一箭。（城堡的西墙和北墙内各有  个靶子）同一个方格只允许经过一次。但不必走完所有的方格。如果只给出靶子上箭的数目，你能推断出骑士的行走路线吗？有时是可以的，比如上图中的例子。\n本题的要求就是已知箭靶数字，求骑士的行走路径（测试数据保证路径唯一）\n输入描述第一行一个整数  ()，表示地面有  个方格。\n第二行  个整数，空格分开，表示北边的箭靶上的数字（自西向东）\n第三行  个整数，空格分开，表示西边的箭靶上的数字（自北向南）\n输出描述输出一行若干个整数，表示骑士路径。\n为了方便表示，我们约定每个小格子用一个数字代表，从西北角开始编号: 0,1,2,3 \n比如，上图中的方块编号为：\n0 1 2 3\n4 5 6 7\n8 9 10 11\n12 13 14 15\n输入输出样例示例\n输入\n\n42 4 3 44 3 3 3\n\n\n输出\n\n0 4 5 1 2 3 7 11 10 9 13 14 15\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n5s\n256M\n\n\nC\n5s\n256M\n\n\nPython3\n5s\n256M\n\n\nJava\n5s\n256M\n\n\n最大数字问题描述给定一个正整数  。你可以对  的任意一位数字执行任意次以下 2 种操 作：\n\n将该位数字加 1 。如果该位数字已经是 9 , 加 1 之后变成 0 。\n\n将该位数字减 1 。如果该位数字已经是 0 , 减 1 之后变成 9 。\n\n\n你现在总共可以执行 1 号操作不超过  次, 2 号操作不超过  次。 请问你最大可以将  变成多少?\n输入格式第一行包含 3 个整数:  。\n输出格式一个整数代表答案。\n样例输入123 1 2\n\n样例输出933\n\n样例说明对百位数字执行 2 次 2 号操作, 对十位数字执行 1 次 1 号操作。\n评测用例规模与约定对于  的数据, 。\n对于  的数据, \n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n512M\n\n\nC\n1s\n512M\n\n\nPython3\n1s\n512M\n\n\nJava\n1s\n512M\n\n\n长草题目描述小明有一块空地，他将这块空地划分为  行  列的小块，每行和每列的长度都为 1。\n小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。\n这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，\n这四小块空地都将变为有草的小块。请告诉小明， 个月后空地上哪些地方有草。\n输入描述输入的第一行包含两个整数 。\n接下来  行，每行包含  个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 ，表示种了草。\n接下来包含一个整数 。 其中，，。\n输出描述输出  行，每行包含  个字母，表示  个月后空地的状态。如果为小数点，表示为空地，如果字母为 ，表示长了草。\n输入输出样例示例\n输入\n\n4 5 .g..........g.......2\n\n\n输出\n\ngggg.gggg.ggggg .ggg.\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n走迷宫题目描述给定一个  的网格迷宫 。 的每个格子要么是道路，要么是障碍物（道路用  表示，障碍物用  表示）。\n已知迷宫的入口位置为 ，出口位置为 。问从入口走到出口，最少要走多少个格子。\n输入描述输入第  行包含两个正整数 ，分别表示迷宫的大小。\n接下来输入一个  的矩阵。若  表示其为道路，否则表示其为障碍物。\n最后一行输入四个整数 ，表示入口的位置和出口的位置。\n，，，。\n输出描述输出仅一行，包含一个整数表示答案。\n若无法从入口到出口，则输出 。\n输入输出样例示例 1\n输入\n\n5 51 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 1 1 1 0 0 0 11 1 5 5\n\n\n输出\n\n8\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n迷宫题目描述本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。\n下图给出了一个迷宫的平面图，其中标记为  的为障碍，标记为  的为可以通行的地方。\n010000 000100001001 110000\n\n迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。\n对于上面的迷宫，从入口开始，可以按 DRRURRDDDR 的顺序通过迷宫， 一共  步。其中 、、、 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（ 行  列），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。\n请注意在字典序中 。\n01010101001011001001010110010110100100001000101010 00001000100000101010010000100000001001100110100101 01111011010010001000001101001011100011000000010000 01000000001010100011010000101000001010101011001011 00011111000000101000010010100010100000101100000000 11001000110101000010101100011010011010101011110111 00011011010101001001001010000001000101001110000000 10100000101000100110101010111110011000010000111010 00111000001010100001100010000001000101001100001001 11000110100001110010001001010101010101010001101000 00010000100100000101001010101110100010101010000101 11100100101001001000010000010101010100100100010100 00000010000000101011001111010001100000101010100011 10101010011100001000011000010110011110110100001000 10101010100001101010100101000010100000111011101001 10000000101100010000101100101101001011100000000100 10101001000000010100100001000100000100011110101001 00101001010101101001010100011010101101110000110101 11001010000100001100000010100101000001000111000010 00001000110000110101101000000100101001001000011101 10100101000101000000001110110010110101101010100001 00101000010000110101010000100010001001000100010101 10100001000110010001000010101001010101011111010010 00000100101000000110010100101001000001000000000010 11010000001001110111001001000011101001011011101000 00000110100010001000100000001000011101000000110011 10101000101000100010001111100010101001010000001000 10000010100101001010110000000100101010001011101000 00111100001000010000000110111000000001000000001011 10000001100111010111010001000110111010101101111000\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n公共抽签题目描述小的学校，蓝桥杯的参赛名额非常有限，只有  个名额，但是共有  个人报名。\n作为老师非常苦恼，他不知道该让谁去，他在寻求一个绝对公平的方式。\n于是他准备让大家抽签决定，即  个签是去，剩下的是不去。\n小  非常想弄明白最后的抽签结果会有多少种不同到情况，请你设计一个程序帮帮小 ！\n输入描述输入第一行包含两个字符 ，其含义如题所述。\n接下来第二行到第  行每行包含一个字符串  ，表示个人名。\n。\n输出描述输出共若干行，每行包含  个字符串，表示该结果被选中到人名（需按字符串的输入顺序大小对结果进行排序）。\n输入输出样例示例\n输入\n\n3 2 xiaowangxiaoA xiaoli\n\n\n输出\n\nxiaowang xiaoAxiaowang xiaolixiaoA xiaoli\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n座次问题题目描述小  的学校，老师好不容易解决了蓝桥杯的报名问题，现在老师又犯愁了。\n现在有  位同学参加比赛，但是老师想给他们排座位，但是排列方式太多了。\n老师非常想弄明白最后的排座次的结果是什么样子的，到底有多少种结果。\n请设计一个程序帮助老师。\n最后输出各种情况的人名即可，一行一种情况，每种情况的名字按照报名即输入顺序排序。\n输入描述输入第一行包含一个整数 。\n接下来  行每行包含一个字符串 ，表示人名。\n，。\n输出描述输出共若干行，每行输出各种情况的人名。一行一种情况，每种情况的名字按照报名即输入顺序排序。\n输入输出样例示例\n输入\n\n3 xiaowangxiaoA xiaoli\n\n\n输出\n\nxiaowang xiaoA xiaolixiaowang xiaoli xiaoA xiaoA xiaowang xiaolixiaoA xiaoli xiaowang xiaoli xiaowang xiaoAxiaoli xiaoA xiaowang\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\nCLZ银行问题题目描述 银行只有两个接待窗口， 窗口和普通窗口， 用户进入  窗口排队，剩下的进入普通窗口排队。现有  次操作，操作有四种类型，如下：\n\nIN name V：表示一名叫 name 的用户到  窗口排队\nOUT V：表示  窗口队头的用户离开排队\nIN name N：表示一名叫 name 的用户到普通窗口排队\nOUT N：表示普通窗口队头的用户离开排队\n\n求  次操作结束后  窗口队列和普通窗口队列中的姓名。\n输入描述第一行是一个整数 （），表示一共有  次操作。\n第二行到第  行输入操作，格式如下：\n\nIN name V\nOUT V\nIN name N\nOUT N\n\n输出描述输出  次操作后  窗口队列和普通窗口队列中的姓名（从头到尾），先输出  窗口队列后输出普通窗口队列。\n输入输出样例示例 1\n输入\n\n5 IN xiaoming N IN Adel V IN laozhao NOUT N IN CLZ V\n\n\n输出\n\nAdelCLZlaozhao\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n费里的语言题目描述小发明家弗里想创造一种新的语言，众所周知，发明一门语言是非常困难的，首先你就要克服一个困难就是，有大量的单词需要处理，现在弗里求助你帮他写一款程序，判断是否出现重复的两个单词。\n输入描述第  行，输入 ，代表共计创造了多少个单词。\n第  行至第  行，输入  个单词。\n，保证字符串的总输入量不超过 。\n输出描述输出仅一行。若有重复的单词，就输出重复单词，没有重复单词，就输出 NO，多个重复单词输出最先出现的。\n输入输出样例示例1\n输入\n\n61fagas dsafa32j lkiuopybncvhfgdjytr cncxfg sdhrest\n\n\n输出\n\nNO\n\n示例2\n输入\n\n5 sdfggfdsfgsdhsdfdsfhsdhr sdfhdfh sdfggfds\n\n\n输出\n\nsdfggfds\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n3s\n512M\n\n\nC\n3s\n512M\n\n\nPython3\n3s\n512M\n\n\nJava\n3s\n512M\n\n\n快递分拣题目描述蓝桥王国的每个快递都包含两个参数：1.快递单号 2.快递城市。\n小李是蓝桥王国的一名快递员，每天的快递分拣让他苦不堪言。\n于是他想要你帮他设计一个程序用于快递的分拣（将不同快递按城市信息分开）。\n输入描述输入第一行包含一个整数 ,表示快递的个数。\n接下来第  行每行包含一个字符串  和一个字符串 ，分别快递单号以及快递对应的城市。\n，保证数据量不超过 。\n输出描述输出共若干行。按城市的输入顺序依次输出城市的名称以及城市的快递个数，以及该城市的所有快递单号（单号按照输入顺序排序）。\n输入输出样例示例\n输入\n\n10 10124214 北京12421565 上海sdafasdg213 天津fasdfga124 北京 145252 上海 235wtdfsg 济南 3242356fgdfsg 成都23423 武汉 23423565f 沈阳 1245dfwfs 成都\n\n\n输出\n\n北京 2 10124214 fasdfga124 上海 2 12421565 145252 天津 1 sdafasdg213济南 1 235wtdfsg 成都 2 3242356fgdfsg 1245dfwfs 武汉 1 23423 沈阳 1 23423565f\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n大学里到树木要打药题目描述教室外有  棵树（树的编号从 ），根据不同的位置和树种，学校要对其上不同的药。\n因为树的排列成线性，且非常长，我们可以将它们看作一条直线给他们编号。\n对于树的药是成区间分布，比如  号的树靠近下水道，所以他们要用驱蚊虫的药，  号的树，他们排水不好，容易涝所以要给他们用点促进根系的药 诸如此类。\n每种不同的药要花不同的钱。\n现在已知共有  个这样的区间，并且给你每个区间花的钱，问最后这些树木要花多少药费。\n输入描述每组输入的第一行有两个整数 和 。 代表马路的共计多少棵树， 代表区间的数目， 和  之间用一个空格隔开。\n接下来的  行每行包含三个不同的整数，用一个空格隔开，分别表示一个区域的起始点  和终止点  的坐标，以及花费。\n，保证花费总和不超过 int 范围。\n输出描述输出包括一行，这一行只包含一个整数，所有的花费。\n输入输出样例示例\n输入\n\n500 3 150 300 4100 200 20 470 471 19\n\n\n输出\n\n2662\n\n运行限制\n\n\n语言\n最大运行时间\nxxxxxxxxxx15 1import os2import sys34# 请在此输入您的代码5n = int(input())6a = list(map(int, input().split()))7a.sort()8b = []9c = []10for i in range(n):11    if a[i] % 2 == 0:12        b.append(a[i])13    else:14        c.append(a[i])15print(“ “.join(map(str, c)),” “.join(map(str,b)))python\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n大学里的树木要维护题目描述教室外有  棵树（树的编号从 ），根据不同的位置和树种，学校已经对其进行了多年的维护。\n因为树的排列成线性，且非常长，我们可以将它们看作一条直线给他们编号。\n由于已经维护了多年，每一个树都由学校的园艺人员进行了维护费用的统计。\n每棵树的前期维护费用各不相同，但是由于未来需要要打药，所以有些树木的维护费用太高的话，就要重新种植。\n由于维护费用也称区间分布，所以常常需要统一个区间里的树木的维护开销。\n现给定一个长度为  的数组  以及  个查询， 表示第  棵树到维护费用。对于每个查询包含一个区间，园艺人员想知道该区间内的树木维护的开销是多少。\n请你编写程序帮帮他！\n输入描述每组输入的第一行有两个整数 和 。 代表马路的共计多少棵树， 代表区间的数目， 和  之间用一个空格隔开。\n接下来的一行，包含  个数 ，分别表示每棵树的维护费用，每个数之间用空格隔开。\n接下来的  行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点  和终止点  的坐标。\n输出描述输出包括  行，每一行只包含一个整数，表示维护的开销。\n输入输出样例示例\n输入\n\n10 37 5 6 4 2 5 0 8 5 31 52 63 7\n\n\n输出\n\n242217\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n合根植物题目描述 星球的一个种植园，被分成  个小格子（东西方向  行，南北方向  列）。每个格子里种了一株合根植物。\n这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。\n如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？\n输入描述第一行，两个整数 ，用空格分开，表示格子的行数、列数（）。\n接下来一行，一个整数  ( )，表示下面还有  行数据。\n接下来  行，每行两个整数 ，，表示编号为  的小格子和编号为  的小格子合根了。\n格子的编号一行一行，从上到下，从左到右编号。\n比如： 的小格子，编号：\n1 2 3 4 5 6 7 89 10 11 1213 14 15 16 17 18 19 20\n\n输出描述输出植物数量。\n输入输出样例示例\n输入\n\n5 416 2 3 1 55 94 8 7 89 1010 1111 12 10 1412 16 14 1817 1815 1919 209 1313 17\n\n\n输出\n\n5\n\n\n样例说明\n\n其合根情况参考下图：\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n2s\n256M\n\n\nC\n2s\n256M\n\n\nPython3\n2s\n256M\n\n\nJava\n2s\n256M\n\n\n修改数组题目描述给定一个长度为  的数组 ，数组中有可能有重复出现的整数。\n现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改。\n当修改  时，小明会检查  是否在  ∼  中出现过。如果出现过，则小明会给  加上 1 ；如果新的  仍在之前出现过，小明会持续给  加 1 ，直 到  没有在  ∼  中出现过。\n当  也经过上述修改之后，显然  数组中就没有重复的整数了。\n现在给定初始的  数组，请你计算出最终的  数组。\n输入描述第一行包含一个整数 。\n第二行包含  个整数 。\n其中，，。\n输出描述输出  个整数，依次是最终的 。\n输入输出样例示例\n输入\n\n5 2 1 1 3 4\n\n\n输出\n\n2 1 3 4 5\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n分巧克力题目描述儿童节那天有 K 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。\n小明一共有  块巧克力，其中第  块是  的方格组成的长方形。为了公平起见，\n小明需要从这  块巧克力中切出 K 块巧克力分给小朋友们。切出的巧克力需要满足：\n\n形状是正方形，边长是整数;\n\n大小相同;\n\n\n例如一块 6x5 的巧克力可以切出 6 块 2x2 的巧克力或者 2 块 3x3 的巧克力。\n当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？\n输入描述第一行包含两个整数  ()。\n以下 N 行每行包含两个整数  ()。\n输入保证每位小朋友至少能获得一块 1x1 的巧克力。\n输出描述输出切出的正方形巧克力最大可能的边长。\n输入输出样例示例\n输入\n\n2 10 6 55 6\n\n\n输出\n\n2\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n2s\n256M\n\n\nC\n2s\n256M\n\n\nPython3\n2s\n256M\n\n\nJava\n2s\n256M\n\n\nM次方根题目描述小最近在学高等数学，他发现了一道题，求三次根号下 。\n现在已知，小开始计算， 的三次方得 ，  的三次方得  ， 的三次方得 ，然后他很高兴的填上了 。接着他要求  次根号下 。\n然后他开始  的三次方得 ，  的三次方得  ， 的三次方得\n直到他算到了秃头，也没有找到答案。\n这时一旁的小看不下去了，说这题答案又不是个整数。\n小震惊，原来如此。\n作为程序高手的小，打算设计一个程序用于求解  次跟下  的值。\n但是由于要考虑精度范围，答案必须要保留  位小数，三次根号下  都要掰手指的小又怎么会设计呢。\n请你帮小设计一个程序用于求解  次根号 。\n输入描述每组输入的第一行有两个整数  和 ，数据间用空格隔开。\n，，。\n输出描述输出一个实数表示答案（请保留小数点后  位）。\n输入输出样例示例\n输入\n\n27 3\n\n\n输出\n\n3.0000000\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n找零问题题目描述蓝桥商店的老板需要找零  元钱。\n钱币的面额有： 元、 元、 元、 元、 元，问如何找零使得所需钱币的数量最少？\n注意： 可能为 ，也能为几百元（别问，问就是来着里微信提现来了）\n输入描述在第一行给出测试例个数 ，代表需要找零的钱数。\n。\n输出描述输出共有  行，每一行输出数据输出找零的金额与数量，详情看样例。\n示例\n输入\n\n365\n\n\n输出\n\n100:3 50:1 20:0 5:3 1:0\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n小B的宿舍题目描述小B的宿舍楼沿着走廊南北向的两边各有  个房间，如下所示：\n[房间1][房间3][房间5][房间7][房间9 ]...[房间399]---------------------------------------------- 走廊 ---------------------------------------------- [房间2][房间4][房间6][房间8][房间10]...[房间400]\n\n最近，由于转专业和专业分流的原因，宿舍将迎来新的调整，以便组成新的班级后方便管理。\n但是由于走廊狭窄，走廊里只能通过一个搬运的物品（可以同向也可以反向），因此必须指定高效的搬运计划。\n老师给了每位同学下达了以下要求，让同学们体现收拾好行李，然后给每位同学  分钟的时间搬运。\n当从房间  搬运行李到  时， 与  之间的走廊都会被占用。所以， 分钟之内同一段走廊最多  个人同时搬运，不重叠的走廊也可以同时搬运。\n小B的老师是个数学老师，经过运筹学一通计算他得到了最优的搬运计划。\n虽然计划不唯一，但是最优值唯一，请问这个最短时间是多少？\n输入描述输入数据有  组测试例，在第一行给出测试例个数 。\n每个测试例的第一行是一个整数 （)，表示要搬运行李的人数。\n接下来  行，每行两个正整数  和 ，表示一个人，要将行李是从房间  移到到房间 。\n输出描述每组输入都有一行输出数据，为一整数 ，表示完成任务所花费的最小时间。\n示例\n输入\n\n3 410 2030 4050 6070 80 21 32 200310 100 20 8030 50\n\n\n输出\n\n101020\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n数字三角形题目描述\n上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。\n路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。\n输入描述输入的第一行包含一个整数 ，表示三角形的行数。\n下面的  行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。\n输出描述输出一个整数，表示答案。\n输入输出样例示例\n输入\n\n5 7 3 88 1 02 7 4 4 4 5 2 6 5\n\n\n输出\n\n27\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n游戏中的学问题目描述大家应该都见过很多人手拉手围着篝火跳舞的场景吧？一般情况下，大家手拉手跳舞总是会围成一个大圈，每个人的左手拉着旁边朋友的右手，右手拉着另一侧朋友的左手。\n不过，如果每一个人都随机的拉住两个不同人的手，然后再慢慢散开，事情就变得有趣多了——此时大家依旧会形成圈，不过却可能会形成多个独立的圈。当然这里我们依然要求一个人的右手只能拉另一个人的左手，反之亦然。\n班里一共有  个同学，由  到  编号。Will 想知道，究竟有多少种本质不同的拉手方案，使得最终大家散开后恰好形成  个圈呢？\n给定两种方案，若存在一个人和他的一只手，满足在这两种方案中，拉着这只手的人的编号不同，则这两种方案本质不同。\n输入描述输入一行包含三个正整数。\n其中，，。\n输出描述输出一行一个整数，表示本质不同的方案数对  的余数。保证  一定是一个质数。\n输入输出样例示例 1\n输入\n\n3 1 1000000009\n\n\n输出\n\n2\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n2s\n128M\n\n\nC\n2s\n128M\n\n\nPython3\n2s\n128M\n\n\nJava\n2s\n128M\n\n\n跳跃题目描述小蓝在一个  行  列的方格图中玩一个游戏。\n开始时，小蓝站在方格图的左上角，即第  行第  列。\n小蓝可以在方格图上走动，走动时，如果当前在第  行第  列，他不能走到行号比  小的行，也不能走到列号比  小的列。同时，他一步走的直线距离不超过 。\n例如，如果当前小蓝在第  行第  列，他下一步可以走到第  行第  列、第  行第  列、第  行第  列、第  行第  列、第  行第  列、第  行第  列、第  行第  列、第  行第  列、第  行第  列之一。\n小蓝最终要走到第  行第  列。\n在图中，有的位置有奖励，走上去即可获得，有的位置有惩罚，走上去就要接受惩罚。奖励和惩罚最终抽象成一个权值，奖励为正，惩罚为负。\n小蓝希望，从第  行第  列走到第  行第  列后，总的权值和最大。请问最大是多少？\n输入描述输入的第一行包含两个整数 ，表示图的大小。\n接下来  行，每行  个整数，表示方格图中每个点的权值。\n其中，，权值。\n输出描述输出一个整数，表示最大权值和。\n输入输出样例示例 1\n输入\n\n3 5-4 -5 -10 -3 17 5 -9 3 -1010 -2 6 -10 -4\n\n\n输出\n\n15\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n小明的背包1题目描述小明有一个容量为  的背包。\n这天他去商场购物，商场一共有  件物品，第  件物品的体积为 ，价值为 。\n小明想知道在购买的物品总体积不超过  的情况下所能获得的最大价值为多少，请你帮他算算。\n输入描述输入第  行包含两个正整数 ，表示商场物品的数量和小明的背包容量。\n第  行包含  个正整数 ，表示物品的体积和价值。\n，，。\n输出描述输出一行整数表示小明所能获得的最大价值。\n输入输出样例示例 1\n输入\n\n5 20 1 62 53 85 153 3\n\n\n输出\n\n37\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n小明的背包2题目描述小明有一个容量为  的背包。\n这天他去商场购物，商场一共有  种物品，第  种物品的体积为 ，价值为 ，每种物品都有无限多个。\n小明想知道在购买的物品总体积不超过  的情况下所能获得的最大价值为多少，请你帮他算算。\n输入描述输入第  行包含两个正整数 ，表示商场物品的数量和小明的背包容量。\n第  行包含  个正整数 ，表示物品的体积和价值。\n，，。\n输出描述输出一行整数表示小明所能获得的最大价值。\n输入输出样例示例 1\n输入\n\n5 201 6 2 53 85 15 3 3\n\n\n输出\n\n120\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n小明的背包3题目描述小明有一个容量为  的背包。\n这天他去商场购物，商场一共有  种物品，第  种物品的体积为 ，价值为 ，数量为 。\n小明想知道在购买的物品总体积不超过  的情况下所能获得的最大价值为多少，请你帮他算算。\n输入描述输入第  行包含两个正整数 ，表示商场物品的数量和小明的背包容量。\n第  行包含  个正整数 ，表示物品的体积和价值。\n，，。\n输出描述输出一行整数表示小明所能获得的最大价值。\n输入输出样例示例 1\n输入\n\n3 30 1 2 3 4 5 67 8 9\n\n\n输出\n\n39\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n蓝肽子序列题目描述L 星球上的生物由蛋蓝质组成，每一种蛋蓝质由一类称为蓝肽的物资首尾连接成一条长链后折叠而成。\n生物学家小乔正在研究 L 星球上的蛋蓝质。她拿到两个蛋蓝质的蓝肽序列，想通过这两条蓝肽序列的共同特点来分析两种蛋蓝质的相似性。\n具体的，一个蓝肽可以使用  至  个英文字母表示，其中第一个字母大写，后面的字母小写。一个蛋蓝质的蓝肽序列可以用蓝肽的表示顺序拼接而成。\n在一条蓝肽序列中，如果选取其中的一些位置，把这些位置的蓝肽取出，并按照它们在原序列中的位置摆放，则称为这条蓝肽的一个子序列。蓝肽的子序列不一定在原序列中是连续的，中间可能间隔着一些未被取出的蓝肽。\n如果第一条蓝肽序列可以取出一个子序列与第二条蓝肽序列中取出的某个子序列相等，则称为一个公共蓝肽子序列。\n给定两条蓝肽序列，找出他们最长的那个公共蓝肽子序列的长度。\n输入描述输入两行，每行包含一个字符串，表示一个蓝肽序列。字符串中间没有空格等分隔字符。\n其中有 ，两个字符串的长度均不超过 。\n输出描述输出一个整数，表示最长的那个公共蓝肽子序列的长度。\n输入输出样例示例\n输入\n\nLanQiaoBei LanTaiXiaoQiao\n\n\n输出\n\n2\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n合唱队形题目描述 位同学站成一排，音乐老师要请其中的  位同学出列，使得剩下的  位同学排成合唱队形。\n合唱队形是指这样的一种队形：设  位同学从左到右依次编号为 ，，，他们的身高分别为 ，，，， 则他们的身高满足 。\n你的任务是，已知所有  位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。\n输入描述输入两行。\n第一行是一个整数 ，表示同学的总数。\n第二行有  个整数，用空格分隔，第  个整数  是第  位同学的身高(厘米)。\n输出描述输出一个整数，就是最少需要几位同学出列。\n输入输出样例示例 1\n输入\n\n8186 186 150 200 160 130 197 220\n\n\n输出\n\n4\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n最优包含题目描述我们称一个字符串  包含字符串  是指  是  的一个子序列，即可以从字符串  中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与  完全一样。\n给定两个字符串  和 ，请问最少修改  中的多少个字符，能使  包含  ？\n其中，。\n输入描述输入两行，每行一个字符串。\n第一行的字符串为 ，第二行的字符串为 。\n两个字符串均非空而且只包含大写英文字母。\n输出描述输出一个整数，表示答案。\n输入输出样例示例\n输入\n\nABCDEABCDXAABZ\n\n\n输出\n\n3\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n路径本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。\n小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图 中的最短路径。\n小蓝的图由 2021 个结点组成，依次编号 1 至 2021。\n对于两个不同的结点 a, b，如果 a 和 b 的差的绝对值大于 21，则两个结点 之间没有边相连；如果 a 和 b 的差的绝对值小于等于 21，则两个点之间有一条 长度为 a 和 b 的最小公倍数的无向边相连。\n例如：结点 1 和结点 23 之间没有边相连；结点 3 和结点 24 之间有一条无 向边，长度为 24；结点 15 和结点 25 之间有一条无向边，长度为 75。\n请计算，结点 1 和结点 2021 之间的最短路径长度是多少。\n提示：建议使用计算机编程解决问题。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n蓝桥王国题目描述小明是蓝桥王国的王子，今天是他登基之日。\n在即将成为国王之前，老国王给他出了道题，他想要考验小明是否有能力管理国家。\n题目的内容如下：\n蓝桥王国一共有  个建筑和  条单向道路，每条道路都连接着两个建筑，每个建筑都有自己编号，分别为  。（其中皇宫的编号为 ）\n国王想让小明回答从皇宫到每个建筑的最短路径是多少，但紧张的小明此时已经无法思考，请你编写程序帮助小明回答国王的考核。\n输入描述输入第一行包含三个正整数 。\n第  到  行每行包含三个正整数 ，表示  之间存在一条距离为  的路。\n，，，。\n输出描述输出仅一行，共  个数，分别表示从皇宫到编号为  建筑的最短距离，两两之间用空格隔开。（如果无法到达则输出 ）\n输入输出样例示例 1\n输入\n\n3 31 2 1 1 3 52 3 2\n\n\n输出\n\n0 1 3\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n2s\n512M\n\n\nC\n2s\n512M\n\n\nPython3\n2s\n512M\n\n\nJava\n2s\n512M\n\n\n随机数据下的最短路问题题目描述给定  个点和  条单向道路，每条道路都连接着两个点，每个点都有自己编号，分别为  。\n问你从  点出发，到达每个点的最短路径为多少。\n输入描述输入第一行包含三个正整数 。\n第  到  行每行包含三个正整数 ，表示  之间存在一条距离为  的路。\n，，，。\n本题数据随机生成。\n输出描述输出仅一行，共  个数，分别表示从编号  到编号为  点的最短距离，两两之间用空格隔开。（如果无法到达则输出 ）\n输入输出样例示例 1\n输入\n\n3 3 11 2 1 1 3 52 3 2\n\n\n输出\n\n0 1 3\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n出差问题描述 国有  个城市, 编号为  。小明是编号为 1 的城市中一家公司的员 工, 今天突然接到了上级通知需要去编号为  的城市出差。\n由于疫情原因, 很多直达的交通方式暂时关闭, 小明无法乘坐飞机直接从 城市 1 到达城市 , 需要通过其他城市进行陆路交通中转。小明通过交通信息 网, 查询到了  条城市之间仍然还开通的路线信息以及每一条路线需要花费的 时间。\n同样由于疫情原因, 小明到达一个城市后需要隔离观察一段时间才能离开 该城市前往其他城市。通过网络, 小明也查询到了各个城市的隔离信息。(由于 小明之前在城市 1 , 因此可以直接离开城市 1 , 不需要隔离）\n由于上级要求, 小明希望能够尽快赶到城市 , 因此他求助于你, 希望你 能帮他规划一条路线, 能够在最短时间内到达城市  。\n输入格式第 1 行: 两个正整数  表示 A 国的城市数量,  表示末关闭的路 线数量\n第 2 行:  个正整数, 第  个整数  表示到达编号为  的城市后需要隔离 的时间\n第  行: 每行 3 个正整数, , 表示有一条城市  到城市  的 双向路线仍然开通着, 通过该路线的时间为 \n输出格式第 1 行: 1 个正整数, 表示小明从城市 1 出发到达城市  的最短时间（到 达城市 , 不需要计算城市  的隔离时间）\n样例输入4 4 5 7 3 41 2 4 1 3 52 4 33 4 5\n\n样例输出13\n\n样例说明\n评测用例规模与约定对于  的数据,  \n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n512M\n\n\nC\n1s\n512M\n\n\nPython3\n1s\n512M\n\n\nJava\n1s\n512M\n\n\n聪明的猴子题目描述在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。\n现在，在这个地区露出水面的有  棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。\n在这个地区住着的猴子有  个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。\n现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。\n输入描述第  行为一个整数，表示猴子的个数 ；\n第  行为  个整数，依次表示猴子的最大跳跃距离（每个整数值在 之间）；\n第  行为一个整数表示树的总棵数 ；\n第  行至第  行为  棵树的坐标（横纵坐标均为整数，范围为：）。\n（同一行的整数间用空格分开）\n输出描述输出一个整数，表示可以在这个地区的所有树冠上觅食的猴子数。\n输入输出样例示例 1\n输入\n\n41 2 3 4 60 0 1 01 2 -1 -1-2 0 2 2\n\n\n输出\n\n3\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n通电题目描述2015 年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。\n这一次，小明要帮助  个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。\n现在，这  个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。\n小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为() 高度为  的村庄与坐标为 () 高度为  的村庄之间连接的费用为\n\n高度的计算方式与横纵坐标的计算方式不同。\n由于经费有限，请帮助小明计算他至少要花费多少费用才能使这  个村庄都通电。\n输入描述输入的第一行包含一个整数  ，表示村庄的数量。\n接下来  行，每个三个整数 ，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。\n其中，，。\n输出描述输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。\n输入输出样例示例\n输入\n\n4 1 1 3 9 9 7 8 8 6 4 5 4\n\n\n输出\n\n17.41\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n机房问题描述这天, 小明在机房学习。\n他发现机房里一共有  台电脑, 编号为 1 到 , 电脑和电脑之间有网线连 接, 一共有  根网线将  台电脑连接起来使得任意两台电脑都直接或者间 接地相连。\n小明发现每台电脑转发、发送或者接受信息需要的时间取决于这台电脑和 多少台电脑直接相连, 而信息在网线中的传播时间可以忽略。比如如果某台电脑 用网线直接连接了另外  台电脑, 那么任何经过这台电脑的信息都会延迟  单 位时间 (发送方和接收方也会产生这样的延迟, 当然如果发送方和接收方都是 同一台电脑就只会产生一次延迟)。\n小明一共产生了  个疑问: 如果电脑  向电脑  发送信息, 那么信息从  传到  的最短时间是多少?\n输入格式输入共  行, 第一行为两个正整数  。\n后面  行, 每行两个正整数  表示编号为  和  的两台电脑用网线 直接相连。\n后面  行, 每行两个正整数  表示小明的第  个疑问。\n输出格式输出共  行, 第  行一个正整数表示小明第  个疑问的答案。\n样例输入4 3 1 2 1 32 4 2 33 43 3\n\n样例输出561\n\n样例说明这四台电脑各自的延迟分别为  。\n对于第一个询问, 从 2 到 3 需要经过 , 所以时间和为  。\n对于第二个询问, 从 3 到 4 需要经过 , 所以时间和为 。\n对于第三个询问, 从 3 到 3 只会产生一次延迟, 所以时间为 1 。\n评测用例规模与约定对于  的数据, 保证 ;\n对于  的数据, 保证  。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n512M\n\n\nC\n1s\n512M\n\n\nPython3\n1s\n512M\n\n\nJava\n1s\n512M\n\n\n环境治理问题描述LQ 国拥有  个城市, 从 0 到  编号, 这  个城市两两之间都有且仅有 一条双向道路连接, 这意味着任意两个城市之间都是可达的。每条道路都有一 个属性 , 表示这条道路的灰尘度。当从一个城市  前往另一个城市  时, 可 能存在多条路线, 每条路线的灰尘度定义为这条路线所经过的所有道路的灰尘 度之和, LQ 国的人都很讨厌灰尘, 所以他们总会优先选择灰尘度最小的路线。\nLQ 国很看重居民的出行环境, 他们用一个指标  来衡量 LQ 国的出行环 境,  定义为:\n\n其中  表示城市  到城市  之间灰尘度最小的路线对应的灰尘度的值。 为了改善出行环境, 每个城市都要有所作为, 当某个城市进行道路改善时, 会将与这个城市直接相连的所有道路的灰尘度都减少 1 , 但每条道路都有一个 灰尘度的下限值 , 当灰尘度达到道路的下限值时, 无论再怎么改善, 道路的 灰尘度也不会再减小了。\n具体的计划是这样的:\n第 1 天, 0 号城市对与其直接相连的道路环境进行改善;\n第 2 天, 1 号城市对与其直接相连的道路环境进行改善;\n\n第  天,  号城市对与其直接相连的道路环境进行改善;\n第  天, 0 号城市对与其直接相连的道路环境进行改善;\n第  天, 1 号城市对与其直接相连的道路环境进行改善;\nLQ 国想要使得  指标满足  。请问最少要经过多少天之后,  指标 可以满足  。如果在初始时就已经满足条件, 则输出 0 ; 如果永远不可能 满足, 则输出  。\n输入格式输入的第一行包含两个整数 , 用一个空格分隔, 分别表示城市个数和 期望达到的  指标。\n接下来  行, 每行包含  个整数, 相邻两个整数之间用一个空格分隔, 其 中第  行第  列的值  表示城市  与城市  之间直接相连 的那条道路的灰尘度。\n接下来  行, 每行包含  个整数, 相邻两个整数之间用一个空格分隔, 其 中第  行第  列的值  表示城市  与城市  之间直接相连的 那条道路的灰尘度的下限值。\n输出格式输出一行包含一个整数表示答条。\n样例输入3 10 0 2 4 2 0 14 1 0 0 2 22 0 0 2 0 0\n\n样例输出2\n\n评测用例规模与约定对于  的评测用例, ， ；\n对于  的评测用例, ，;\n对于所有评测用例,  。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n10s\n512M\n\n\nC\n10s\n512M\n\n\nPython3\n10s\n512M\n\n\nJava\n10s\n512M\n\n\n刷题统计问题描述小明决定从下周一开始努力刷题准备蓝桥杯竞赛。他计划周一至周五每天 做  道题目, 周六和周日每天做  道题目。请你帮小明计算, 按照计划他将在 第几天实现做题数大于等于  题?\n输入格式输入一行包含三个整数  和 .\n输出格式输出一个整数代表天数。\n样例输入10 20 99\n\n样例输出8\n\n评测用例规模与约定对于  的评测用例, .\n对于  的评测用例, .\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n快速幂题目描述输入 ，， 的值，求  的值。其中  。\n输入描述三个整数 。\n输出描述输出 ， 为运算结果。\n输入输出样例示例\n输入\n\n2 10 9\n\n\n输出\n\n7\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n核桃的数量题目描述小张是软件项目经理，他带领 3 个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是：\n\n各组的核桃数量必须相同\n\n各组内必须能平分核桃（当然是不能打碎的）\n\n尽量提供满足 1,2 条件的最小数量（节约闹革命嘛）\n\n\n输入描述输入一行 ，都是正整数，表示每个组正在加班的人数，用空格分开。\n输出描述输出一个正整数，表示每袋核桃的数量。\n输入输出样例示例\n输入\n\n2 4 5\n\n\n输出\n\n20\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n64M\n\n\nC\n1s\n64M\n\n\nPython3\n1s\n64M\n\n\nJava\n1s\n64M\n\n\n质数题目描述给定一个正整数 ，请你输出  以内（不包含 ）的质数以及质数的个数。\n输入描述输入一行，包含一个正整数 。 \n输出描述共两行。\n第  行包含若干个素数，每两个素数之间用一个空格隔开，素数从小到大输出。\n第  行包含一个整数，表示N以内质数的个数。\n输入输出样例示例\n输入\n\n10\n\n\n输出\n\n2 3 5 7 4\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n128M\n\n\nC\n1s\n128M\n\n\nPython3\n1s\n128M\n\n\nJava\n1s\n128M\n\n\n分割立方体题目描述给定一个立方体，边长为 ，现将其分割成  个单位立方体。\n分割后任意两个单位立方体，或者有  个公共点，或者有  个公共点，或者没有公共点。\n请问，没有公共点和有  个公共点的立方体，共有多少对？\n输入描述输入一行包含一个整数 。\n输出描述输出一个整数表示答案。\n输入输出样例示例1\n输入\n\n1\n\n\n输出\n\n0\n\n示例2\n输入\n\n2\n\n\n输出\n\n16\n\n示例3\n输入\n\n3\n\n\n输出\n\n297\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n糊涂人寄信题目描述有一个糊涂人，写了  封信和  个信封，到了邮寄的时候，把所有的信都装错了信封。求装错信封可能的种类数。\n输入描述有多行读入，每行输入一个正整数 ，表示一种情况。()\n输出描述输出相应的答案。\n输入输出样例示例\n输入\n\n134\n\n\n输出\n\n0 29\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n小蓝吃糖果题目描述小蓝有  种糖果，每种数量已知。\n小蓝不喜欢连续  次吃同样的糖果。问有没有可行的吃糖方案。\n输入描述第一行是整数 。\n第二行包含  个数，表示  种糖果的数量 ，。\n输出描述输出一行，包含一个 Yes 或 No。\n输入输出样例示例\n输入\n\n34 1 1\n\n\n输出\n\nNo\n\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nPython3\n1s\n256M\n\n\nJava\n1s\n256M\n\n\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]蓝桥国赛","url":"/2024/05/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%93%9D%E6%A1%A5%E5%9B%BD%E8%B5%9B/","content":"第十四届Python大学C组跑步计划问题描述小蓝计划在某天的日期中出现  时跑  千米，否则只跑  千米。注意日期中出现  不仅指年月日也指星期。\n请问按照小蓝的计划， 年小蓝总共会跑步锻炼多少千米?例如， 月  日、 月  日、 月  日、 月  日 (星期一) 小蓝会跑  千米，而  月  日小蓝会跑  千米 (示例日期均为  年)\n答案提交这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 714  |  总提交次数: 778  |  通过率: 91.8%\n难度: 中等   标签: 2023, 国赛, 日期问题\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n解题思路import datetimebt = datetime.date(2023, 1, 1)c = 0for i in range(1, 366):    bt += datetime.timedelta(days=1)    if '1' in bt.isoformat() or bt.isoweekday() == 1:        c += 5    else:        c += 1print(c)\n\nsun = 0import datetimea = datetime.date(2023,1,1)for i in range(1,366):  if '1' in a.strftime(\"%m%d%w\") :sun+=4  sun+=1  a += datetime.timedelta(days = 1)print(sun)\n\n混乘数字问题描述混乘数字的定义如下: 对于一个正整数 ，如果存在正整数 ，使得 ，而且  和  的十进制数位中每个数字出现的次数之和与  中对应数字出现次数相同，则称  为混乘数字。\n例如，对于正整数 ，存在 ,  满足条件，因此  是一个混乘数字。\n又如，对于正整数 ，存在 ,  满足条件，因此  是一个混乘数字。\n请你帮助计算出， (含)之间一共有多少个数字是混乘数字。\n答案提交这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n5s\n256M\n\n\nPyPy3\n5s\n256M\n\n\nGo\n5s\n256M\n\n\nJavaScript\n5s\n256M\n\n\n解题思路import mathfrom collections import defaultdict# 混乘数字：# 条件1：a * b == n# 条件2：a、b一定是n的因子# 条件3：且a、b中各个数字出现次数 == n中各个数字出现次数def isHunc(n):    \"\"\"返回True代表是混乘数字\"\"\"    # 1. 求n中每个数字出现次数    nums = defaultdict(int)    for kwd in list(str(n)):        nums[kwd] += 1    # 2. 开启暴力美学    for a in range(1, int(math.sqrt(n)) + 1):    # 两个因子相乘，绝对有一个因子&lt;= 开平方后的值        # 判断是否符合条件1、2        if n % a == 0:            b = n // a            # 判断是否符合条件3            if cnt_dy(a, b, nums):                return Truedef cnt_dy(a, b, nums):    \"\"\"符合条件3 返回 True\"\"\"    # nums是可变对象，形参改变实参也会改变，我们需要将他的值复制，这样才不对原始数据造成更改    now = nums.copy()    for k in str(a):        now[k] -= 1        if now[k] &lt; 0:            return False    for k in str(b):        now[k] -= 1        if now[k] &lt; 0:            return False    # 判断字典中是否还有值    if sum(now.values()) != 0:        return False    return Trueans = 0for i in range(125, 1000001):     if isHunc(i):         ans += 1print(ans)\n\nimport osimport sysimport mathcount=0for i in range(1,1000001):  for j in range(2,int(math.sqrt(i))+1):    if i % j == 0:      if sorted(str(i)) == sorted(str(j)+str(i//j)):        count += 1        break  if i % 100000 == 0:    print(i,count)print(count)print(590)\n\n整数变换问题描述小蓝有一个整数 。每分钟，小蓝的数都会发生变化，变为上一分钟的数减去上一分钟的数的各个数位和。\n例如，如果小蓝开始时的数为 ，则下一分钟变为 ，再下一分钟变为 ，再下一分钟变为 ，共经过了  分钟变为 。\n给定一个正整数，请问这个数多少分钟后变为 。\n输入格式输入一行包含一个整数 。\n输出格式输出一个整数，表示答案。\n样例输入23\n\n样例输出3\n\n评测用例规模与约定对于  的评测用例，;\n对于  的评测用例，;\n对于所有评测用例，。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n解题思路这道题目需要使用pypy3，否则会超时\nn = input()int_n = int(n)ans = 0while int_n &gt; 0:    s = sum(map(int,list(str(int_n))))    int_n -= s    ans += 1print(ans)\n\n定时任务问题描述Cron 表达式在定时任务中经常被使用，在这里我们用了一种简化后的版本 SimpleCron 表达式：SimpleCron 表达式是一个具有时间含义的字符串，字符串以  个空格隔开，分为  个域，格式为 ，其中  是一个域的占位符。 个域从左至右依次为秒 、分钟 、小时 、日期 、月份 ，其中括号内为他们各自的取值范围。同时域内取值也可以使用一些特殊字符（每个域内只能使用一种特殊字符）:\n\n特殊字符  （ASCII 码为 ）表示所有可能的值。例如：在分钟域内表示每一分钟；在日期域内表示月内的每一天。\n特殊字符  （ASCII 码为 ）表示列出枚举值。例如：在秒域内， 表示分别在  秒和  秒执行一次任务。\n特殊字符  （ASCII 码为 ）表示范围，可以视为连续的若干个枚举值。例如： 等价于 。\n\n例如， 表示的含义是每个月份中的每一天中的 、、 这三个时刻各执行一次，在  年一共会执行  次。\n现在给出你一个合法的 SimpleCron 表达式，其中用到的所有数字均没有前导零。请问在  一整年当中，使用了这个表达式的定时任务总计会执行多少次?\n输入格式输入一行，包含一个 SimpleCron 字符串。\n输出格式输出一行，包含一个整数表示答案。\n样例输入4 2 1,3,15 1-31 *\n样例输出1095\n评测用例规模与约定对于所有评测用例， 秒域的取值 ， 分钟域的取值 ， 小时域的取值 ， 日期域的取值 ， 月份域的取值 。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 181  |  总提交次数: 251  |  通过率: 72.1%\n难度: 中等   标签: 2023, 国赛, 日期问题\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n解题思路import datetimetime = input().split()a = [[0, 59], [0, 59], [0, 23], [1, 31], [1, 12]]for i in range(5): # 先得到对应时间点，哪些时间有任务    if '*' in time[i]:        time[i] = range(a[i][0], a[i][1] + 1)    elif '-' in time[i]:        l, r = map(int, time[i].split('-'))        time[i] = range(l, r + 1)    elif ',' in time[i]:        time[i] = list(map(int, time[i].split(',')))    else:        time[i] = [int(time[i])]s, f, h, d, m = timedays = len(s) * len(f) * len(h) #一天的任务次数可以直接求得start = datetime.date(2023, 1, 1)end = datetime.date(2024, 1, 1)t = datetime.timedelta(days=1)cnt = 0while start &lt; end: #按天遍历    _, M, D = map(int, str(start).split('-'))    if M in m and D in d:#满足累加每天的任务        cnt += days    start += tprint(cnt)\n\n2023问题描述给定 , ，请求出所有  位十进制整数中有多少个数中恰好出现了  个 。\n例如  是一个  位的出现了  个  的十进制整数。由于结果可能很大，请输出答案对  取模的结果。\n输入格式输入一行包含两个整数 , ，用一个空格分隔。\n输出格式输出一行包含一个整数表示答案。\n样例输入5 1\n样例输出20\n\n评测用例规模与约定对于  的评测用例，，；\n对于所有评测用例，，。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 34  |  总提交次数: 232  |  通过率: 14.7%\n难度: 中等   标签: 2023, 国赛, 排列组合, 二项式定理\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n解题思路def quickpow(a, n, mod):    \"\"\"    快速幂算法，计算 a 的 n 次幂对 mod 取模的结果    \"\"\"    ans = 1    while n:        if n &amp; 1:            ans = ans * a % mod        a = a * a % mod        n &gt;&gt;= 1    return ansdef C(m, n, fact, inv, mod):    \"\"\"    计算组合数 C(m, n) % mod 的值    \"\"\"    return fact[n] * inv[m] % mod * inv[n - m] % moddef fact_init(mod):    \"\"\"    初始化阶乘数组和逆元数组    \"\"\"    fact = [0] * (100001)    inv = [0] * (100001)    fact[0] = inv[0] = 1    for i in range(1, 100001):        fact[i] = fact[i - 1] * i % mod        inv[i] = inv[i - 1] * quickpow(i, mod - 2, mod) % mod    return fact, invn, m = map(int, input().split())k = n // 4ans = 0mod = 998244353fact, inv = fact_init(mod)for i in range(m, k + 1):    ans += (-1 if (i - m) % 2 else 1) * C(m, i, fact, inv, mod) * C(i, n - 3 * i, fact, inv, mod) * quickpow(10, n - 4 * i, mod)    ans %= modprint(ans)\n\n\n最大算式问题描述给定  个非负整数  ，你可以在不改变这些数顺序的前提下任意在他们之间插入  四种符号 。\n请问在得到的算式合法的前提下，算式的结果最大可以是多少?\n由于结果很大，你只需要输出答案对  取模的结果即可。\n输入描述输入的第一行包含一个整数  。\n第二行包含  个整数，分别表示  ，相邻两个整数之间使用一个空格分隔。\n输出描述输出一行包含一个整数表示答案。\n样例输入7 1 2 1 1 1 2 1\n\n样例输出27\n\n样例说明 .\n评测用例规模对于  的评测用例，  ；\n对于所有评测用例，  ，  。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 22  |  总提交次数: 38  |  通过率: 57.9%\n难度: 中等   标签: 2023, 贪心, 国赛, 数学\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n解题思路import osimport sysdef find(x):    if m[i]==1:        if s[-1]==2:            s[-1]+=1        elif s[-1]&gt;m[i+1] and m[i+1]!=0:            m[i+1]+=1        else:            s[-1]+=1    else:        s.append(m[i])n=int(input())m=list(map(int,input().split()))s=[]if m[0]==1:    m[1]+=1else:    s.append(m[0])for i in range(1,n-1):    if m[i]!=0:        find(i)if m[-1]==1:    s[-1]+=1elif m[-1]!=0:    s.append(m[-1])k=1num=0for j in s:    k=k*jnum+=kprint(num%1000000007)\n\n躲炮弹问题描述小蓝正在玩一个躲炮弹的游戏。游戏中有一个人物和一个炮塔，它们的初始距离为 。\n炮塔可能选择在区间  上的任意一个整数 ，然后发射的炮弹会飞向小蓝操控的人物。但炮弹只会在飞出  的倍数的距离()时落地，然后弹回到空中。如果小蓝操控的人物恰好站在了炮弹落地的位置，那么游戏就会结束。\n小蓝只能在炮弹发射前移动他的人物，每移动一步，可以使得人物和炮塔的距离增加  或者减少 。他想知道最少要移动多少步才能保证自己的人物一定能躲过炮弹。\n输入格式输入一行包含三个整数 ，相邻的整数之间使用一个空格分隔。\n输出格式输出一行包含一个整数，表示小蓝操纵的人物最少需要移动的步数。\n样例输入10 2 13\n样例输出7\n\n评测用例规模与约定对于  的评测用例，；\n对于所有评测用例，，。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 38  |  总提交次数: 94  |  通过率: 40.4%\n难度: 中等   标签: 2023, 国赛, 质因子分解\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n解题思路n, L, R = map(int, input().split())'''case 1: ans在n的右边 或者就是ncase 2: n大于R ans在n-1到R+1之间case 3: ans在l-1这个位置'''# 找出当前数的所有质因数def pr_(xx):    pr = []    for i in range(2, int(xx ** 0.5) + 1):        while xx % i == 0:            pr.append(i)            xx //= i    if xx &gt; 1: pr.append(xx)    return pr# 如果当前x是质数或者x除以x的质因子的值小于low 则当前位置是安全位置def judge(x, low):    nums = pr_(x)    if len(nums) == 1:        return x    else:        for j in nums:            # 安全位置一定满足这一个条件 但是满足条件的不一定是安全位置            # 但我们可以保证最近的一个安全位置的前面一定不存在错误位置            if x // j &lt; low:                return x            else:                return -1ans = 0# case 1res = max(R + 1, n)while True:    new_seat = judge(res, L)    if new_seat != -1:        ans = res - n        break    res += 1# case 2res = n - 1while res &gt; R:    new_seat = judge(res, L)    if new_seat != -1:        ans = min(n - res, ans)        break    res -= 1# case 3 and 1, 2# 如果n在L的特别左边是会返回负数的 所以要特判if n &lt; L:    print('0')elif n == L:    print('1')else:      print(min(n - L + 1, ans))\n\n走方格问题描述给定一个  行  列的方格，第  行第  列的方格坐标为 ，高度为 。小蓝从左上角坐标  出发，目的地是右下角坐标 。\n当小蓝位于第  行第  列时，他有如下的移动方式:\n\n若 ，可以移动到 ，花费  秒;\n若 ，可以移动到 ，花费  秒;\n对于任意整数 ，若 ，可以移动到 ，花费  秒;\n对于任意整数 ，若 ，可以移动到 ，花费  秒。\n\n现在给出方格，请问小蓝从  移动到  最少需要多少秒?\n输入格式输入的第一行包含一个整数  表示方格大小。\n接下来  行，每行包含  个整数，表示每个方格上的数字。\n输出格式输出一个整数表示答案。\n样例输入40 1 9 32 9 3 78 4 8 99 8 0 7\n样例输出5\n\n样例说明移动顺序为: ，其中坐标 、、 处的数字分别为 ，所以可以花费  秒从  移动到 。\n评测用例规模与约定对于  的评测用例，；\n对于  的评测用例，；\n对于所有评测用例，，。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n3s\n256M\n\n\nPython3\n5s\n256M\n\n\nPyPy3\n5s\n256M\n\n\nGo\n5s\n256M\n\n\nJavaScript\n5s\n256M\n\n\n解题思路import osimport sysfrom math import *# 请在此输入您的代码n = int(input())nums = [[0 for _ in range(n)] for _ in range(n) ]f = [[inf for _ in range(n+1)] for _ in range(n+1)]for i in range(n):  nums[i] = list(map(int,input().split()))#可以倒着走f[n-1][n] = -1f[n][n-1] = -1for i in range(n-1,-1,-1):  for j in range(n-1,-1,-1):    #先更新自己    f[i][j] = min(f[i][j],f[i+1][j]+1,f[i][j+1]+1)    #然后更新捷径，要连续大于两个的才算捷径    #看横向有无捷径,跳过你左边的,i不变    for l in range(j,-1,-1):      if l-1 &gt;= 0 and nums[i][l-1] &gt; nums[i][l]:        f[i][l-1] = min(f[i][l-1],f[i][j] +1)      else:        break    #看纵向有无捷径，j不变    # for r in range(i,-1,-1):    #   if r-1 &gt;= 0 and nums[r-1][j] &gt; nums[r][j]:    #     f[r-1][j] = min(f[r-1][j],f[i][j] +1)    #   else:    #     breakprint(f[0][0])\n\nimport osimport sysn=int(input())mp=[list(map(int,input().split())) for _ in range(n)]inf=float('inf')dp=[[0]*n for _ in range(n)] #到x,y花费的最少步数for i in range(n):    dp[i][0]=i #第i行第一个数为ifor i in range(n):    for j in range(1,n):        dp[i][j]=inf        if i&gt;0:            dp[i][j]=min(dp[i][j],dp[i-1][j]+1) #从上往下走一格                    k=j        while mp[i][k]&lt;mp[i][k-1] and k&gt;=1:            dp[i][j]=min(dp[i][j],dp[i][k-1]+1) #从左往右走，且判断是否满足题目第三个条件            k-=1                    dp[i][j]=min(dp[i][j],dp[i][j-1]+1) #从左往右走一格print(dp[-1][-1])#题目第四个条件会增加步数，不能减少，会多走一步\n\n\n\n等腰三角形问题描述给定一个包含  个数的序列  ，每次操作可以选择其中任意一个数将其  或  。\n我们要让这个序列满足能够从中任选三个数，这三个数对应长度的三条边总能组成一个等腰三角形。问最少需要多少次操作才能让序列满足条件。\n输入描述输入的第一行包含一个整数  。\n第二行包含  个整数，分别表示  ，相邻两个整数之间使用一个空格分隔。\n输出描述输出一行包含一个整数，表示最少的操作次数。\n样例输入5 3 3 5 7 7\n\n样例输出3\n\n样例说明将原序列修改为  即可。\n评测用例规模对于  的评测用例，  ，  ；\n对于  的评测用例，  ，  ；\n对于所有评测用例，  ，  。w\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 7  |  总提交次数: 69  |  通过率: 10.1%\n难度: 中等   标签: 2023, 国赛, 数学, 分类讨论\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n单词分类问题描述在遥远的  国，只存在三种字符：、和  (ASCII 码分别为 、、)，所有的单词都由这三种字符组合而来。小蓝为了更加快速的记忆单词，决定将词典上所有的单词按照单词前缀将其分为  类，具体的要求是:\n\n选出  个不同的单词前缀作为  类；\n对于字典上的每个单词，只能属于  类中的某一个类，不能同时属于多个类；\n对于  类中的每个类，至少包含有一个单词。\n\n现在已知字典上一共有  个单词，小蓝想要知道将这  个单词按照上述要求分为  类，一共有多少种不同的方案。两个方案不同指的是两个方案各自选出的  个单词前缀不完全相同。答案可能过大，所以你需要将答案对  (即 )取模后输出。\n输入格式输入的第一行包含两个整数  和 ；\n接下来  行，每行包含一个单词，由 、、 三种字符组成。\n输出格式输出一个整数表示答案。答案可能很大，请输出答案对  取模的值。\n样例输入4 2lqblqlqqqqql\n样例输出4\n\n样例说明方案 1：、; 方案 2：、; 方案 3：、; 方案 4：、。\n以方案 1 为例，他表示选出的两类对应的前缀分别是  和 ，属于前缀  的单词有 、，属于前缀  的单词有 、，方案 1 将四个单词按照前缀分成了两类，且每类至少包含一个单词，每个单词仅属于一类，所以方案 1 满足题意。\n评测用例规模与约定对于  的评测用例，，；\n对于  的评测用例，，；\n对于所有评测用例，，， 单词长度 。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 9  |  总提交次数: 28  |  通过率: 32.1%\n难度: 中等   标签: 2023, 字典树, 国赛, 动态规划\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n第十四届Python大学B组弹珠堆放问题描述小蓝有 20230610 颗磁力弹珠，他对金字塔形状尤其感兴趣，如下图所示：\n\n高度为  的金字塔需要  颗弹珠；\n高度为  的金字塔需要  颗弹珠；\n高度为  的金字塔需要  颗弹珠；\n高度为  的金字塔需要  颗弹珠。\n小蓝想要知道用他手里的弹珠可以摆出的最高的金字塔的高度是多少？\n答案提交这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 723  |  总提交次数: 767  |  通过率: 94.3%\n难度: 中等   标签: 2023, 前缀和, 国赛\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n解题思路import osimport sysn=20230610dp=[1]for i in range(2,500):    num=0    for j in range(1,i+1):      num+=j    dp.append(num+dp[i-2])for i,j in enumerate(dp):  if n&gt;dp[i]:    continue  else:    print(i)    break print(494)\n\n\n\n划分问题描述给定  个数，请将其任意划分成两组，每组至少一个元素。每组的权值为组内所有元素的和。划分的权值为两组权值的乘积。请问对于以下  个数，划分的权值最大为多少。\n5160 9191 6410 4657 7492 1531 8854 1253 4520 9231 1266 4801 3484 4323 5070 1789 2744 5959 9426 4433 4404 5291 2470 8533 7608 2935 8922 5273 8364 8819 7374 8077 5336 8495 5602 6553 3548 5267 9150 3309\n\n在试题包中有一个名为 \\verb|nums.txt| 的文本文件，文件中的数与题面上的数相同。\n答案提交这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 186  |  总提交次数: 248  |  通过率: 75%\n难度: 中等   标签: 2023, 国赛, 动态规划, 背包问题\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n解题思路#根据题意可知分成两个集合的权值差要最小#可以看成背包问题，背包大小为所有元素和的一半，最后看背包装了多少ss = \"\"\"5160 9191 6410 4657 7492 1531 8854 1253 4520 9231 1266 4801 3484 4323 5070 1789 2744 5959 9426 4433 4404 5291 2470 8533 7608 2935 8922 5273 8364 8819 7374 8077 5336 8495 5602 6553 3548 5267 9150 3309\"\"\"nums = list(map(int, ss.split(\" \")))bag = sum(nums) // 2n = 40dp = [[0] * (bag + 1) for i in range(n + 1)]for i in range(1, n + 1):    cur = nums[i - 1]    for j in range(1, bag + 1):        if j - cur &gt;= 0:            dp[i][j] = max(dp[i - 1][j - cur] + cur, dp[i - 1][j])a = max(dp[40])b = sum(nums) - aprint(a * b)\n\n偶串问题描述小蓝特别喜欢偶数，当他看到字符串时，他总数要检查一下是不是每种字符都是出现偶数次。给定一个字符串，请帮助小蓝检查一下该字符串是否满足要求。\n输入描述输入一行包含一个字符串，由小写英文字母组成。\n输出描述如果字符串中的每种字符都是出现偶数次，输出大写英文单词  ，否则输出大写英文单词  。\n样例输入banana\n\n样例输出NO\n\n样例输入bbnana\n\n样例输出YES\n\n评测用例规模对于  的评测用例，  字符串长度 ；\n对于所有评测用例， 字符串长度  。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 386  |  总提交次数: 429  |  通过率: 90%\n难度: 中等   标签: 2023, 国赛, 语法\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n解题思路常规思路直接模拟直接求\nfrom collections import Counters = list(input())d = Counter(s)mark = 1for k, v in d.items():    if v % 2 != 0:        mark = 0        breakprint(\"YES\" if mark == 1 else \"NO\")\n\n使用异或根据异或的性质我们可以知道：任意两个相同的数异或的值为0，故偶数个相同的数异或的值也是0\n所以最后我们走一遍循环，最后异或值只要为0那说明所有数字出现的次数为偶数次，反之则存在一个数字出现了奇数次\n最后由于异或只能在数字之间，所以我们用字符的ascii码(ord)来代表这个字符\nans = 0for i in input():    ans ^= ord(i)print(\"NO\" if ans else \"YES\")\n\n\n\n交易账本问题描述小蓝最近研发了一种新的记账方式，并邀请了一些用户参加测试。交易账本可以看作是交易记录的集合，每条交易记录都有着一个独一无二的交易编号  （编号大小反映了交易记录产生的时间顺序，  小的交易记录先发生于  大的交易记录），每条交易记录包含一个或多个输入信息以及一个或多个输出信息。\n其中输入来自于已经发生过的某比交易的某个输出，可以理解为这笔钱从某比交易输出后继续输入到了当前这比交易中，输入信息主要包含以下数据：、 ，这表示当前输入来自于交易编号为  的第   个输出；输出信息主要包含以下数据：、 ，表示将  数目的钱转移到了账户编号为  的账户上。注意，当  和  都为  时，表明这是一笔特殊交易，由系统账户直接产生输出，特殊交易只含有一个输入和一个输出，可以认为系统账户拥有无限多数目的钱，特殊交易一定可以成功。\n一个合法的账本应满足以下条件：1）对于每笔交易记录，所有的输入中涉及到的钱的总数目应和所有输出中钱的总数目相等；2）交易中的一个输出要么不使用，要使用的话输出中的钱应该全部分配给下一个输入，而不能分配给多个输入（特殊交易除外）；3）交易按照顺序进行，不可以在某比交易中引用还未发生的交易。\n现在已知一共有  个不同的账户，初始时所有账户钱数目都为  ，账本上总计有  条交易记录（按照交易完成的顺序进行记录），请你来判断下账本上的记录是否是合法的。\n输入描述输入的第一行包含一个整数  ，表示有  组输入数据。\n对于每组输入数据：\n第一行包含两个整数  ，用一个空格分隔，分别表示账户的数目和账本的交易记录数目，其中账户编号为  ，交易记录编号为  。\n接下来  行，每行包含一条交易记录的信息，交易记录编号依次为  。第一个整数  表示输入的个数，接下来包含  个输入信息，每个输入信息包含  和  两个整数；接下来包含一个整数  表示输出的个数，然后接着包含  个输出信息，每个输出信息包含  和  两个整数。\n输出描述对于每组输入数据输出一行，如果账本记录合法则输出英文单词  ，否则输出英文单词 。\n样例输入43 31 -1 -1 1 0 1001 0 0 2 1 50 2 502 1 0 1 1 1 2 1003 31 -1 -1 1 0 1001 0 0 2 1 50 2 502 1 0 1 1 1 2 1503 31 -1 -1 1 0 1001 0 0 2 1 50 2 503 0 0 1 0 1 1 1 2 2003 31 -1 -1 1 0 1002 0 0 2 0 2 1 100 2 1001 -1 -1 1 2 100\n\n样例输出YES NO NO NO\n\n样例说明对于第一个数据：第一条交易  为特殊交易，给账户  转入了 ；第二条交易  将上一条交易的唯一一个输出作为当前交易的输入，有两个输出，分别给账户  和  转入了  ；最后一条交易  将上一条交易的两个输出作为当前交易的输入，给账户  转入了  。\n对于第二个数据，第三条交易中输入与输出总额不相等。\n对于第三个数据，第一条交易中的输出被使用了超过一次。\n对于第四个数据，第二条交易中引用了还未发生的交易的输出。\n评测用例规模对于所有评测用例，  ，  ，  ，  ，  交易中涉及到钱的数目 ，  ，  。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n解题思路import sysimport osread=sys.stdin.readlinedef judge():    n,m=list(map(int,input().split()))#    print(f'n={n},{m}')    vis=[[0]*m for _ in range(m)]    flag=True    for idx in range(m):        record=list(map(int,read().split()))        money=0        for i in range(1,2*record[0]+1,2):            if record[i]==-1:                money=float('inf')            else:                if vis[record[i]][record[i+1]]==0:                    flag=False                else:                    money+=vis[record[i]][record[i+1]]                    vis[record[i]][record[i+1]]=0        out=2*record[0]+1        for i in range(out+2,len(record),2):            j=(i-out)//2-1#            print(f'out={out},i={i},j={j}')            vis[idx][j]=record[i]            if money!=float('inf'):                money-=record[i]        if money!=float('inf') and money!=0:            flag=False    return 'YES' if flag==True else 'NO'def main():    t=int(input())    for _ in range(t):        print(judge())    returnmain()\n\n\n\n背包问题问题描述小蓝是一位狂热的积木爱好者，家里堆满了自己用积木组装的建筑模型。最近，有两款新出的积木组件上市，小蓝自然不会错过，他带上了自己的三个背包来到了积木商城，打算将尽可能多的积木组件带回家，每个背包都有一个固定的空间大小。小蓝只会购买这两种新出的积木组件  和  ，  和  各自会占用背包的一部分空间，但对于同一种类型的积木占用的空间是相同的。小蓝想知道自己最多能带走多少数量的积木组件。\n可以认为小蓝有足够的货币，只要背包可以装下的积木他都有能力购买。商场内的积木数量也是有限制的。\n输入描述输入的第一行包含一个整数  ，表示有  组独立的询问。\n每一组询问由三行组成。\n每组询问的第一行包含三个整数  ，相邻的整数之间使用一个空格分隔，表示三个背包的空间大小。\n每组询问的第二行包含两个整数  ，用一个空格分隔，分别表示商场内积木组件  和  的总量。\n每组询问的第三行包含两个整数  ，用一个空格分隔，分别表示每个积木组件  和  所占用的空间大小。\n输出描述输出  行，每行包含一个整数表示答案。\n样例输入3 2 2 3 1 2 1 2 3 8 3 3 4 4 2 6 8 7 10 10 5 1\n\n样例输出3 5 12\n\n样例说明对于第一组询问，第一个背包装一个 B 积木，无剩余空间；第二个背包装一个 B 积木，无剩余空间；第三个背包装一个 A 积木，剩余 2 空间，但积木已经没有了；最终答案是  ，可以带走所有的积木。\n对于第二组询问，第一个背包和第三个背包各自装一个 B 组件，第二个背包装两个 B 组件和一个 A 组件，答案是  。\n对于第三组询问，第一个背包：1A+1B；第二个背包：8B；第三个背包：1A+1B。答案是  。\n评测用例规模对于  的评测用例，  ；\n对于所有评测用例，  ，  ，  ，  。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n解题思路def solve():    a = LII()  # 3个背包    A, B = MII()  # 1e3    va, vb = MII()    if va &gt; vb:        va, vb = vb, va        A, B = B, A    res = 0    for i in range(min(A, a[0] // va) + 1):        for j in range(min(A - i, a[1] // va) + 1):            cnta, cntb = A, B            mx1 = min((a[0] - i * va) // vb, cntb)  # 更新B的剩余数量            cntb -= mx1            mx2 = min((a[1] - j * va) // vb, cntb)            cntb -= mx2            t = i + j + mx1 + mx2   # B1和B2的数量和            leftA = cnta - i - j            mi = min(leftA, a[2] // va)  # B3最多能装多少个A            left_v = a[2] - mi * va            t += mi + min(left_v // vb, cntb)  # 剩下的装B            res = max(res, t)    print(res)if __name__ == '__main__':    # 1多组数据，0单组数据    t = 1     if t:        t = II()        for _ in range(t):            solve()    else:        solve()\n\n\n\n翻转问题描述小蓝制作了  个工件，每个工件用一个由小写英文字母组成的，长度为  的字符串表示，第  个工件表示为  。小蓝想把  个工件拼接到一起，方便转移到另一个地方完成下一道工序，而拼接后的工件用字符串  表示，其中  表示一种奇特的拼接方式：对于  来说，如果  的第二个字符和  的第一个字符相同，则拼接后的结果  长度为  而不是  ，中间相同的字符可以省略一个，比如  而  。小蓝为了让拼接后的字符串  的长度尽量小，可以将若干个工件进行左右翻转之后再进行拼接，请问拼接后的字符串  的最小长度是多少？\n请注意所有工件必须按出现顺序依次拼接，可以翻转任意工件。\n输入描述输入的第一行包含一个正整数  。\n接下来  行，每行包含一个长度为  字符串，依次表示  。\n输出描述输出一行，包含一个整数表示答案。\n样例输入3 ab cb zz\n\n样例输出5\n\n样例说明将  翻转后，拼接结果为  ，长度为  。\n评测用例规模对于  的评测用例， ；\n对于所有评测用例， 。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n2s\n256M\n\n\nPython3\n3s\n256M\n\n\nPyPy3\n3s\n256M\n\n\nGo\n3s\n256M\n\n\nJavaScript\n3s\n256M\n\n\n总通过次数: 204  |  总提交次数: 253  |  通过率: 80.6%\n难度: 中等   标签: 2023, 国赛, 动态规划\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n解题思路import osimport sys# 请在此输入您的代码n = int(input())s = [input() for _ in range(n)]dp1 = [2] * n # dp1[i] 第i个字符串不翻转的最小长度dp2 = [2] * n # dp2[i] 第i个字符串翻转的最小长度for i in range(1, n): # 枚举每一个字符串    # 1.dp1[i]从dp1[i-1]或dp2[i-1]转移    k1 = dp1[i-1] + 2 - (s[i-1][1] == s[i][0])    k2 = dp2[i-1] + 2 - (s[i-1][0] == s[i][0])    dp1[i] = min(k1, k2)    # 2.dp1[i]从dp1[i-1]或dp2[i-1]转移    k3 = dp1[i-1] + 2 - (s[i-1][1] == s[i][1])    k4 = dp2[i-1] + 2 - (s[i-1][0] == s[i][1])    dp2[i] = min(k3, k4)print(min(dp1[n-1], dp2[n-1]))\n\n最大阶梯问题描述小蓝特别喜爱阶梯图案，阶梯图案可以看做是由若干个大小和颜色都相同的方格组成的，对于大小为  的阶梯图案，包含了  个连续的列，其中第  列恰好有 （）个方格，将这  列的底部对齐后便组成了一个阶梯图案，将其按照  度旋转若干次后仍是阶梯图案，下图展示了几个不同大小的阶梯图案：\n\n小蓝有一块大小为  的布匹，由  个大小相同的方格区域组成，每一个方格都有自己的颜色。小蓝可以沿着方格的边缘对布匹进行裁剪，他想要知道自己能得到的最大的同色阶梯图案的大小是多少？\n输入描述输入的第一行包含一个整数  表示布匹大小。\n接下来输入  行，每行包含  个整数，相邻的整数之间使用一个空格分隔，表示每个方格的颜色。\n输出描述输出一行包含一个整数表示答案。\n样例输入5 0 2 1 1 0 0 0 2 2 0 0 0 1 1 1 0 0 1 1 1 2 1 1 0 2\n\n样例输出3\n\n样例说明如下图所示，最大的同色阶梯图案用红色边框标出。\n\n评测用例规模对于  的评测用例， ；\n对于  的评测用例， ；\n对于所有评测用例，  ，  方格颜色 。\n运行限制\n\n\n语言\n最大运行时间\n最大运行内存\n\n\n\nC++\n1s\n256M\n\n\nC\n1s\n256M\n\n\nJava\n5s\n256M\n\n\nPython3\n5s\n256M\n\n\nPyPy3\n5s\n256M\n\n\nGo\n5s\n256M\n\n\nJavaScript\n5s\n256M\n\n\n总通过次数: 96  |  总提交次数: 158  |  通过率: 60.8%\n难度: 中等   标签: 2023, 国赛, 动态规划\n版权声明\n部分题目由用户贡献，若您是著作权持有人，请与我们联系。\n解题思路import osimport sys# 既然是动态规划，就要找转移来源，发现 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1# 图形可以旋转 90 度，对应的图形就有 4 种# 有两种解决思路: 1. 将原始图形进行旋转，用 同一个 方法 解决#                2. 原始图不动，写 四 种寻找方法 解决# 时间复杂度都是 O(n ^ 2)h = int(input())matrix = [[] for _ in range(h)]matrix_fan = [[] for _ in range(h)]matrix_col = [[0] * h for _ in range(h)]matrix_col_fan = [[0] * h for _ in range(h)]for i in range(h):  l = list(map(int, input().split()))  matrix[i].extend(l)  matrix_fan[h-i-1].extend(l[::-1])  for j, v in enumerate(l):    matrix_col[h-j-1][i] = v    matrix_col_fan[j][h-i-1] = vdef check(l: list):  ans = 1  dp = [[1] * h for _ in range(h)]  for i in range(1, h):    for j in range(1, h):      if l[i][j] == l[i-1][j] == l[i][j-1]:        dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1        ans = max(ans, dp[i][j])    return ansprint(max(check(matrix), check(matrix_fan), check(matrix_col), check(matrix_col_fan)))\n\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]递推与递归","url":"/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/","content":"递推法与递归法递推法：\n递推法是一种在数学和其他领域广泛应用的重要方法，它在计算机科学中被用作一种关键的数值求解算法。\n知识点：\n\n递推算法\n递归算法\n\n递推算法的特点递推法的核心在于找到递推关系式。这种方法可以将复杂的计算过程转化为简单的重复步骤，充分利用计算机在运行程序时的时间局部性和空间局部性。\n递推算法的思想：\n\n首先找到各个相邻数据项之间的递推关系；\n递推关系避开了求通项公式的麻烦，尤其是对于那些难以或无法求解通项公式的题目；\n将复杂问题分解为若干步骤的简单运算；\n一般来说，递推算法可以视为一种特殊的迭代算法。\n\n递推算法解题的基本思路：\n\n将复杂计算转换为简单重复运算；\n通过找到递推关系式进行简化运算；\n利用计算机的特性，减少运行时间。\n\n递推算法的一般步骤：\n\n根据题目确定数据项，并找到符合要求的递推关系式；\n根据递推关系式设计递推程序；\n根据题目找到递推的终点；\n单次查询可以不进行存储，多次查询都要进行存储；\n按要求输出答案即可。\n\n递归算法：\n递归算法是一种自顶向下的算法，它通过不断地直接或间接调用自身的函数，通过每次改变变量完成多个过程的重复计算，直到到达边界之后，结束调用。\n与递推法相似的是，递归与递推都是将一个复杂过程分解为几个简单重复步骤进行计算。\n递归算法的实现的核心是分治策略，即分而治之，将复杂过程分解为规模较小的同类问题，通过解决若干个小问题，进而解决整个复杂问题。\n递归算法的思想：\n\n将复杂计算过程转换为简单重复子过程；\n找到递归公式，即能够将大问题转化为小问题的公式；\n自上而下计算，在返回完成递归过程。\n\n递归算法设计的一般步骤：\n\n根据题目设计递归函数中的运算部分；\n根据题目找到递归公式，题目可能会隐含给出，也可能需要自己进行推导；\n找到递归出口，即递归的终止条件。\n\n递归法和递推法的思路已经给大家讲解得差不多了，接下来我们将结合真实的大赛题目进行讲解。这将有助于我们更好地理解和应用这两种方法。\n斐波纳契数列 fibonacci 问题在一定情况下，同一个问题可以使用用递归也可以使用递推解答。一般一个问题的递推关系和递归关系都好求的话就都可以解题。\n当然如果题目只有一个关系好求，那就最好采用关系好求的办法。\n题目描述:\n斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。\n指的是这样一个数列：、、、、、、、、、、\n在数学上，斐波那契数列以如下被以递推的方法定义：，，（，）\n请求出该数列中第  个数字（ 从开始计数）是多少。\n样例:\n输入样例样例1输入6样例2输入4输出样例样例1输出8样例2输出3\n\n对于上面的样例我们进行了如下计算；\n[0]=0[1]=1[2]=0+1[3]=1+1=2[4]=1+2=3[5]=2+3=5[6]=5+3=8 \n\n运行限制:\n1. 最大运行时间：1s2. 最大运行内存：128M\n\n题目解析：\n\n这个题给出递推式 \n转化为可用的递推关系，即\n\n这一通过从  开始循环即可完成递推，当然也可以使用递归法。\n首先我们写找出递归式，。\nF(n)= F(n-1) + F(n-2)    = F(n-2)+F(n-3)+F(n-3)+F(n-4)//重复调用\n\n这样我们找到了递归式，然后我们应该找到递归出口。\n我们可以知道  这就是递归出口，能让递归停止的条件。\n递归算法的通用框架如下：\ndo(a,b,c...){    //递归终止条件，即出口    if(a==? ,b==? ,....) return    //递归条件    if(条件1)        do(参数1)    else(条件2)        do(参数2)}如本题，各子式间存在计算关系，可以化为：do(a){    if(a==0) return 0;    if(a==1) return 1;    return do(a-1)+do(a-2);}\n\n这道题不是多次询问问题，不需要存储直接计算的复杂度是最低的。\n答案解析C++ 代码：\n\n递推算法代码\n\n#include &lt;iostream&gt;using namespace std;int main(){    int n; //第几个数    int x=0; //F(n)    int y=1; //F(n+1)    int ans; //F(n+2）    cin&gt;&gt;n;    if(n==0) ans=0;    else if(n==1) ans=1;    else {        for(int i=2;i&lt;=n;i++)        {            ans=x+y;            x=y;            y=ans;        }    }    cout&lt;&lt;ans&lt;&lt;endl;}\n\n\n递归算法代码\n\n#include &lt;iostream&gt;using namespace std;int fn(int n){    //递归出口1    if(n==0)        return 0;    //递归出口2    else if(n==1 )        return 1;    else        return fn(n-1)+fn(n-2); //递归关系式}int main(){    int n; //第几个数    int ans;    cin&gt;&gt;n;    ans=fn(n);    cout&lt;&lt;ans&lt;&lt;endl;}\n\nPython 解题代码\n\n递推算法代码：\n\nif __name__ == '__main__':    n =int( input())    x=0 # F(n)    y=1 #F(n+1)    ans=0 #F(n+2）    if n==0 :        ans=0    elif n==1:        ans=1    else:        for i in range (n-1):            ans=x+y            x=y            y=ans    print(ans)\n\n\n递归算法代码：\n\ndef f(n):    # 递归出口1    if n == 0:        return 0    # 递归出口2    elif n == 1:        return 1    else:        return f(n - 1) + f(n - 2)  # 递归关系式if __name__ == '__main__':    n = int(input())    ans = f(n)    print(ans)\n\nJava 解题代码\n递推算法：\nimport java.util.Scanner;public class Main {    public static void main(String[] args) {        int n; //第几个数        int x=0; //F(n)        int y=1; //F(n+1)        int ans = 0; //F(n+2）        Scanner in = new Scanner(System.in);        n = in.nextInt();        if(n==0) ans=0;        else if(n==1) ans=1;        else {            for(int i=2;i&lt;=n;i++)            {                ans=x+y;                x=y;                y=ans;            }        }        System.out.println(ans);    }}\n\n递归算法代码：\nimport java.util.Scanner;public class Main {    static  int fn(int n)    {        if(n==0)            return 0;            //递归出口2        else if(n==1 )            return 1;        else            return fn(n-1)+fn(n-2); //递归关系式    }    public static void main(String[] args) {        int n; //第几个数        int ans = 0;        Scanner in = new Scanner(System.in);        n = in.nextInt();        ans=fn(n);        System.out.println(ans);    }}\n\n存储型的递推与递归我们在开始就讲过题目十分存储和非存储的，上面那个题目就是此询问，如果改为多次询问我们该怎么办，我们会采用存储的方式，存储的方式适用于大部分的的多次查询问题。\n我们看一下修改后的题目。\n题目描述：\n斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。\n指的是这样一个数列：、、、、、、、、、、\n在数学上，斐波那契数列以如下被以递推的方法定义：，，（，）\n我们将进行M次查询，每次输入一个，其中小于。\n请求出该数列中第个数字（从开始计数）是多少?\n样例:\n输入样例样例1输入：64278810样例2输入：81323141724161011输出样例样例1输出：3113212155样例2输出：233286573771597463689875589\n\n运行限制:\n1. 最大运行时间：1s 2. 最大运行内存：128M\n\n题目解析：\n这道题跟上面一道题的算法原理相同，只是增加了多次查询的复杂度，所以仅需修改这一点即可。\n再有的是有的同学担心自己的输入输出是在一个屏幕上的，评测的时候会不会出现问题。\n\n类似这样的情况，这一点是不用担心的，只要不是交互题，评测机的输入与输出是分开的，只有你的输出会用来跟答案比较，所以我们只用关心我们的输出即可。\n比如有一道题让你计算  的值，如果你知道每答案，就可以直接输出，都不用进行读入。\n然后我们来看一下需要多次询问的题目该怎么解决。\n答案解析C++ 代码：\n\n递推算法代码\n\n#include &lt;iostream&gt;using namespace std;int F[35];void init(){    F[0]=0;    F[1]=1;    for(int i=2;i&lt;=30;i++)    {        F[i]=F[i-1]+F[i-2];    }}int main(){    int m; //m次查询    int n; //第几个数    init();    cin&gt;&gt;m;    while(m&gt;0){        m-=1;        cin&gt;&gt;n;        cout&lt;&lt;F[n]&lt;&lt;endl;    }}\n\n存储答案的递推法，才是最常使用的递推法。\n\n递归算法代码\n\n#include &lt;iostream&gt;using namespace std;int F[35];int fn(int n){    //递归出口1    if(n==0)    {        F[0]=0;        return 0;    }    //递归出口2    else if(n==1 )    {        F[1]=1;        return 1;    }    else    {        F[n]=fn(n-1)+fn(n-2);        return F[n]; //递归关系式    }}int main(){    int m; //m次查询    int n; //第几个数    fn(30);    cin&gt;&gt;m;    while(m&gt;0){        m-=1;        cin&gt;&gt;n;        cout&lt;&lt;F[n]&lt;&lt;endl;    }}\n\nPython 解题代码\n递推算法代码：\nF = [0]*35def init():    F[0] = 0    F[1] = 1    for i in range(2, 30):        F[i] = F[i-1]+F[i-2]if __name__ == '__main__':    m = int(input())    init()    while m &gt; 0:        m -= 1        n = int(input())        print(F[n])    # print(F)\n\n递归算法代码：\nF = [0] * 35def f(n):    # 递归出口1    if n == 0:        F[0] = 0        return 0    # 递归出口2    elif n == 1:        F[1] = 1        return 1    else:        F[n] = f(n - 1) + f(n - 2) # 递归关系式        return F[n]if __name__ == '__main__':    m = int(input())    f(30)    while m &gt; 0:        m -= 1        n = int(input())        print(F[n])    # print(F)\n\nJava 解题代码\n递推算法：\nimport java.util.Scanner;public class Main {    static int []F=new int [35];    static  void init()    {        F[0]=0;        F[1]=1;        for(int i=2;i&lt;=30;i++)        {            F[i]=F[i-1]+F[i-2];        }    }    public static void main(String[] args) {        int m; //m次查询        int n; //第几个数        init();        Scanner in = new Scanner(System.in);        m = in.nextInt();        while(m&gt;0){            m-=1;            n= in.nextInt();            System.out.println(F[n]);        }    }}\n\n递归算法代码：\npackage com.company;import java.util.Scanner;public class Main {    static int []F=new int [35];    static int fn(int n)    {        //递归出口1        if(n==0)        {            F[0]=0;            return 0;        }        //递归出口2        else if(n==1 )        {            F[1]=1;            return 1;        }        else        {            F[n]=fn(n-1)+fn(n-2);            return F[n]; //递归关系式        }    }    public static void main(String[] args) {        int m; //m次查询        int n; //第几个数        fn(30);        Scanner in = new Scanner(System.in);        m = in.nextInt();        while(m&gt;0){            m-=1;            n= in.nextInt();            System.out.println(F[n]);        }    }}\n\n数字三角形问题题目描述:\n如图数字三角形。如下所示为一个数字三角形。请编一个程序计算从顶到底的某处的一条路径，使该路径所经过的数字总和最大。只要求输出总和。 　\n\n一步可沿左斜线向下或右斜线向下走；\n三角形行数小于等于 ；\n三角形中的数字为 ，，，；\n\n测试数据通过键盘逐行输入。\n如上例数据应以样例所示格式输入：\n样例:\n输入：573 88 1 02 7 4 44 5 2 6 5\n\n输出：30\n\n运行限制:\n1. 最大运行时间：1s2. 最大运行内存：128M\n\n题目分析:\n解决该题目的方式有很多，包括动态规划， 枚举都可以解决这个问题。\n我们从递推的思想出发，假设我们从顶层沿着某条路径已经走到了第  层，正向着  层前进， 两条可行路径中我们肯定会选择最大的方向前进，为此我们可以采用递推中的反向递推，即逆推的方式解决，设  存放从  出发到达第  层的最大值。\n我们可以写出递推式：\na[i][j] = max{a[i][j]+a[i+1][j]，a[i][j]+a[i+1][j+1]}\n\n则 逆推到出发点  为题目所求答案，即第一层到第  层的最大值。\n答案解析C++ 代码：\n#include&lt;iostream&gt;using namespace std;int main(){    int n; //n层    int a[101][101]; //路径矩阵    cin&gt;&gt;n;    //输入数字三角形的值    for (int i=1; i&lt;=n; i++)    {        for (int j=1; j&lt;=i; j++)        {        cin&gt;&gt;a[i][j]; //输入原始数据        }    }    //递推开始    for (int i=n-1; i&gt;=1; i--)//从最后一层逆推    {        for (int j=1; j&lt;=i; j++)        {            if (a[i+1][j]&gt;=a[i+1][j+1])                a[i][j]+=a[i+1][j];     //路径选择            else                a[i][j]+=a[i+1][j+1];        }    }    cout&lt;&lt;a[1][1]&lt;&lt;endl;}\n\nPython 解题代码\na = [[0] * 101] * 101if __name__ == '__main__':  n = int(input())  # 输入数字三角形的值  for i in range(1, n+1):      a[i] = input().split()      a[i] = list(map(int, a[i]))  # split 分割后都是 字符 这里是转化成数字  #  # for i in range(1, n + 1):  #     print(a[i]) # a = list(map(int, a)) # split 分割后都是 字符 这里是转化成数字  # 递推开始  for i in range(n - 1, 0, -1):      # 最后一层逆推      for j in range(0, i):          # 路径选择          if a[i + 1][j] &gt;= a[i + 1][j + 1]:              a[i][j] += a[i + 1][j]          else:              a[i][j] += a[i + 1][j + 1]  # for i in range(1, n + 1):  #     print(a[i])  print(a[1][0])\n\nJava 解题代码\npackage com.company;import java.util.Scanner;public class Main {  static int [][]a=new int [101][101];  public static void main(String[] args) {      int n;      Scanner in = new Scanner(System.in);      n = in.nextInt();      //输入数字三角形的值      for (int i=1; i&lt;=n; i++)      {          for (int j=1; j&lt;=i; j++)          {              a[i][j]=in.nextInt(); //输入原始数据          }      }      //递推开始      for (int i=n-1; i&gt;=1; i--)//从最后一层逆推      {          for (int j=1; j&lt;=i; j++)          {              if (a[i+1][j]&gt;=a[i+1][j+1])                  a[i][j]+=a[i+1][j];     //路径选择              else  a[i][j]+=a[i+1][j+1];          }      }      System.out.println(a[1][1]);  }}\n\n总结我们这节课讲了递推与递归的知识点，并且也讲了何时采用递归设计程序，何时采用递推设计程序。对于多次询问的题目，也为大家展示了一种解决方法。\n对于递推算法，我们覆盖了正推和逆推两种方式。无论是递推和递归的关键在于找到关系式。\n希望同学能够独立完成题目进行练习。并且在后面的学习中会多次用到递归与递推设计其他算法。\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[数据结构与算法]贪心","url":"/2024/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/","content":"贪心算法贪心算法（Greedy algorithm），又称贪婪算法。是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而使得问题得到全局最优解。\n贪心的算法的设计就是要遵循某种规则，不断地选取当前最优解的算法设计方法。这节实验将会通过多个问题的来讲解贪心算法。\n知识点\n贪心算法的基本概念\n贪心算法的适用范围\n贪心算法的设计步骤\n贪心算法的题目讲解\n\n贪心算法基本概念贪心算法与枚举法的不同之处在于每个子问题都选择最优的情况，然后向下继续进行，且不能回溯。枚举法是将所有情况都考虑然后选出最优的情况。\n贪心算法，在解决问题时，不从整体考虑，而是采用一种一眼看到局部最优解的选择方式。并且，贪心算法没有固定的模板可以遵循，每个题目都有不同的贪心策略，所以算法设计的关键在于贪心策略的选择。\n贪心算法有一个必须注意的事情。贪心算法对于问题的要求是，所有的选择必须是无后效性的，即当前的选择不能影响后续选择对于结果的影响。\n贪心算法主要适用于最优化问题，例如：最小生成树问题。有时候贪心算法并不能得到最优答案，但是能得到精确答案的近似结果。有时可以辅助其他算法得到不那么精确的结果。\n适用范围符合贪心策略：\n所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。\n贪心选择性质就是指，该问题的每一步选择都在选择最优的情况下能够导致最终问题的答案也是最优。\n或者说是无后效性，如果该问题的每一步选择都对后续的选择没有影响，就可以应用贪心算法。\n贪心算法的设计步骤按照定义设计：\n\n证明原问题的最优解之一可以由贪心选择得到。\n将最优化问题转化为这样一个问题，即先做出选择，再解决剩下的一个子问题。\n对每一子问题一一求解，得到子问题的局部最优解；\n将子问题的解局部最优解合成原问题的一个解。\n\n伪代码：\n关于 Question Q：\nwhile(Q.hasNextStep){    Select(Q.nowBestSelect);    Q.NextStep}Select(Q.nowBestSelect);\n\n贪心相关题目讲解我们在正式将题目前，聊一个大家都懂的常见的知识，也是一个常见的题目。\n找零问题题目如下：\n假设商店老板需要找零  元钱。\n钱币的面额有： 元、 元、 元、 元、 元、如何找零使得所需钱币的数量最少？\n注意： 可能为 ，也能为几百元（别问，问就是来着里微信提现来了）\n输入:\n输入解法:\n在第一行给出测试例个数 。\n代表需要找零的钱数。\n输入样例：\n365\n\n输出：\n输出解法\n有  行输出数据，每一行输出数据输出找零的金额与数量，详情看样例。\n输出样例：\n100:350:120:05:31:0\n\n运行限制:\n最大运行时间：1s最大运行内存：128M\n\n题目解析：\n关于这个题，如果是正常人都知道从大的钱开始找钱。这就是一种贪心的思想，将大问题转化为一个个小的子问题，每次选择最大的钱数使得总量最小。\n其实再生活中贪心思想的例子还有很多，像是“自助餐“这种的都是贪心算法的印证。贪心算法其实离我们很近，掌握不会很困难的。\n我们先看一下上一道题目的代码题解是什么。\n答案解析：\nC++ 解法：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;//面值int t[5]={100, 50, 20, 5, 1};//张数int m[5];void change(int n){    for(int i=0;i&lt;5;i++)    {        m[i]=n/t[i];        n=n%t[i];        //print(\"%d\",n);    }}int main(){    int N;    cin&gt;&gt;N;    change(N);    for(int i=0;i&lt;5;i++)    {        printf(\"%d:%d\\n\",t[i],m[i]);    }}\n\nPython 解法\nt = [100, 50, 20, 5, 1]# 钱的面值def change(t, n):  # m是张数  m = [0 for _ in range(len(t))]  # print(m) #[0, 0, 0, 0]  for i, money in enumerate(t):      # print(i) #0 1 2 3      # print(money)      # i是当前的编号  举个例子 n是376 money是100      m[i] = n // money  # 商3      # n还剩多少取余      n = n % money  # 取余76 76不够100的      # print(m)      # print(n)  return mif __name__ == '__main__':  N = int(input())  m = change(t,N)  for i in range(len(m)):      print(t[i], end=':')      print(m[i])\n\nJava 解法\nimport java.util.Arrays;import java.util.Comparator;import java.util.Scanner;import static java.lang.Integer.max;public class Main {  //面值  static  int t[] = new int[]{100, 50, 20, 5, 1};  //张数  static int m[] = new int[5];  static void change(int n) {      for (int i = 0; i &lt; 5; i++) {          m[i] = n / t[i];          n = n % t[i];          //print(\"%d\",n);      }  }  public static void main(String[] args) {      int N;      Scanner in = new Scanner(System.in);      N = in.nextInt();      change(N);      for (int i = 0; i &lt; 5; i++) {          System.out.println(String.format(\"%d:%d\", t[i], m[i]));      }  }}\n\n蓝桥大学的小 B 同学宿舍题目如下:\n小 B 的宿舍楼沿着走廊南北向的两边各有  个房间。\n如图所示：\n[房间1][房间3][房间5][房间7][房间9 ]...[房间399]----------------------------------------------                   走廊----------------------------------------------[房间2][房间4][房间6][房间8][房间10]...[房间400]\n\n最近，由于转专业和专业分流的原因，宿舍将迎来新的调整，以便组成新的班级后方便管理。\n但是由于走廊狭窄，走廊里只能通过一个搬运的物品（可以同向也可以反向），因此必须指定高效的搬运计划。\n老师给了每位同学下达了以下要求，让同学们体现收拾好行李，然后给每位同学  分钟的时间搬运。\n当房间  搬运行李到  时， 与  之间的走廊都会被占用。所以， 分钟之内同一段走廊最多个人同时搬运，不重叠的走廊也可以同时搬运。\n小  的老师是个数学老师，经过运筹学一通计算他得到了最优的搬运计划。\n虽然计划不唯一，但是最优值唯一，请问这个最短时间是多少？\n输入:\n输入解法:\n输入数据有  组测试例，在第一行给出测试例个数 。\n每个测试例的第一行是一个整数 （)，表示要搬运行李的人数。接下来  行，每行两个正整数  和 ，表示一个人，将行李是从房间号码  移到到房间号码 。\n输入样例:\n3410 2030 4050 6070 8021 32 200310 10020 8030 50\n\n输出：\n输出解法\n每组输入都有一行输出数据，为一整数 ，表示完成任务所花费的最小时间。\n输出样例:\n102030\n\n运行限制:\n最大运行时间：1s 最大运行内存：128M\n\n题目解析：\n不难发现，相对应的两个房间其实是占用一段走廊的，我们可以将将房间号映射为走廊号，然后再考虑上面的解析。\n该题属于贪心算法，因为它尽可能使搬运办公桌同时进行，以便使单独安排的搬运次数最少。这样用的时间最少，即所用最少时间为不能同时搬运桌子的次数，即某一段走廊使用次数最多（贪心标准）即为即为最少搬运时间。 答案解析：\nC++ 解法：\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int move[200];//搬运次数    int N;    int T;    cin&gt;&gt;T;    while(T--)    {        //每次搬运的起点和终点        int from, to;        int maxAns=0;        scanf(\"%d\", &amp;N);        memset(move, 0, sizeof(move));        for(int i = 0; i &lt; N; i++)        {            scanf(\"%d%d\", &amp;from, &amp;to);//将房间号映射为走廊号            from = (from - 1)/2;            to = (to - 1)/2;//确保from&lt;to，C++使用：swap(from, to)            if(from &gt; to)            {                int temp = from;                from = to;                to = temp;            }//统计占用走廊情况，并统计最大值            for(int j = from; j &lt;= to; j++)            {                move[j]++;                maxAns=max(maxAns,move[j]);            }        }        cout&lt;&lt;maxAns*10&lt;&lt;endl;    }}\n\nPython 解法\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int move[200];//搬运次数    int N;    int T;    cin&gt;&gt;T;    while(T--)    {        //每次搬运的起点和终点        int from, to;        int maxAns=0;        scanf(\"%d\", &amp;N);        memset(move, 0, sizeof(move));        for(int i = 0; i &lt; N; i++)        {            scanf(\"%d%d\", &amp;from, &amp;to);//将房间号映射为走廊号            from = (from - 1)/2;            to = (to - 1)/2;//确保from&lt;to，C++使用：swap(from, to)            if(from &gt; to)            {                int temp = from;                from = to;                to = temp;            }//统计占用走廊情况，并统计最大值            for(int j = from; j &lt;= to; j++)            {                move[j]++;                maxAns=max(maxAns,move[j]);            }        }        cout&lt;&lt;maxAns*10&lt;&lt;endl;    }}\n\nJava 解法\nimport java.util.Scanner;import static java.lang.Integer.max;public class Main {  public static void main(String[] args) {      Scanner in = new Scanner(System.in);//搬运次数      int N;      int T;      T = in.nextInt();      while (T &gt; 0) {          T--;          //每次搬运的起点和终点          int from, to;          int maxAns = 0;          N = in.nextInt();          int[] move = new int[205];          for (int i = 0; i &lt; N; i++) {              from=in.nextInt();              to=in.nextInt();//将房间号映射为走廊号              from = (from - 1) / 2;              to = (to - 1) / 2;//确保from&lt;to，C++使用：swap(from, to)              if (from &gt; to) {                  int temp = from;                  from = to;                  to = temp;              }//统计占用走廊情况，并统计最大值              for (int j = from; j &lt;= to; j++) {                  move[j]++;                  maxAns = max(maxAns, move[j]);              }          }          System.out.println( maxAns * 10);      }  }}\n\n可拆分背包问题之贪心的自助餐题目如下:\n小  同学呢，想去吃自助餐，但是他是那种比较节俭的的人，既不想浪费食物，又想尽可能吃的贵一点，他于是私下里做了调查。\n小蓝餐厅的自助餐有  种食材，每种食材都有它的价格。\n而且也能估计出每一份的重量，所以他列了一个表格。\n红烧牛肉  30元    300g油闷大虾  8元     5g四喜丸子  4元     8g三文鱼    5元     3g排骨      18元    200g麻辣兔头  20元    120g高汤海参  40元    70g扇贝粉丝  8元     32g牛排      79元    240g...\n\n现在小  想知道在他到底最多吃多少钱的菜品。\n假设自助餐厅的菜品供应同样的菜品每个人只能取一份。\n小B的饭量假设为 ，单位为 。\n现在请你设计一个程序帮助小  计算他的最多吃了多少钱。\n输入:\n输入解法\n第一行输入 （）（）\n其中  为菜品数量， 为小  的肚子容量。\n第二行输入两个数 ，\n第一个数  是第  个菜品的价值（）\n第二个数  是第  个菜品的质量（）\n输入样例:\n20 10001 222 43123 21412 2123 43221 22322 1677 4934 7834 943 67721 3423 2312 56332 5621 99123 545389 3312 99923 88\n\n输出：\n输出一行数据，表示最大的价值，保留三位小数。\n输出样例：\n1204.114\n\n运行限制:\n最大运行时间：1s 最大运行内存：128M\n\n题目解析：\n可拆分背包的一般解法为：\n这里有 n 种不同值  和权重  的对象（如果选择该对象的  可以获得值 ）。\n你有一个容器来挑选它们。你可以根据自己的需要把它们分成任意大小的碎片。可以拾取的对象的最大重量给定为 。请计算您能得到的最大值。\n就像是这个题目，要想吃回本就要捡着贵的吃，但是贵只是一方面，人会饱，所以用价格除以质量所获的价格商才是贪心准则，应按照价格商优先进行选取。\n于是这个题，就要用的我们之前学的知识了。这里因为要整体排序，所以要先创建一个类，然后自定义 cmp 函数，在使用 sort 排序。\n答案解析：\nC++ 解法：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;iomanip&gt;using namespace std;//需要一个结构体，通过性价比，能够查找到重量和价值。//做一个排序，需要将性价比由高到底排序，排序的过程中重量和（价值）要对应上struct Food{    double w;    double v;    double aver;};//C++一般用 struct，因为默认都是public的bool cmp(Food a, Food b){    return a.aver &gt; b.aver;    //助记大于号就是从大到小排序，小于号就是从小到大排序}int main(){    Food foods[1009];    int n;    double C;    double Value = 0;    cin &gt;&gt; n &gt;&gt; C;    for (int i = 0; i &lt; n; i++)    {        cin &gt;&gt; foods[i].v&gt;&gt;foods[i].w;        //求性价比        foods[i].aver = foods[i].v / foods[i].w;        //cout &lt;&lt; foods[i].aver &lt;&lt; endl;    }    //性价比排序    sort(foods, foods + n, cmp);    //当背包（肚子）能装下所有物品（菜）时，直接输出所有的物品（菜品）价值之和    //    int sum = 0;    for (int i = 0; i &lt; n; i++)    {        sum += foods[i].w;    }    if (sum &lt;= C)    {        for (int j = 0; j &lt; n; j++)            Value += foods[j].v;        //V = floor(V * 1000.0) / 1000.0;        cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt;Value &lt;&lt; endl;        return 0;    }    //当背包（肚子）不能装下所有物品时应该由性价比的顺序，选择装入的物品    for (int i = 0; i &lt; n; i++)    {        if (foods[i].w &lt;= C)        {            Value =Value + foods[i].v;            C = C - foods[i].w;        }        else        {            //直接将剩余的C加入即可            Value =Value + C * foods[i].aver;            C = 0;        }        if (C == 0)            break;    }    //V = floor(V * 1000.0) / 1000.0;    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt;Value &lt;&lt; endl;    return 0;}\n\nPython 解法\nclass Food:   def __init__(self, w, v, aver):       self.w = w       self.v = v       self.aver = aver   def __repr__(self):       # print(11)       return repr((self.w, self.v, self.aver))# def cmp(foodA: Food, foodB: Food):#     if foodA.aver &gt;= foodB.aver:#         return True##     else:#         return False### 当然 python 的 sort 是不需要写 cmp 函数的，这里我们使用 sorted 就不用 cmp 函数了if __name__ == '__main__':   foods = []   C = 0.0   Value = 0.0   n, C = map(int, input().split())   for i in range(n):       food = Food(0, 0, 0)       food.v, food.w = map(int, input().split())       food.aver = food.v / food.w       foods.append(food)       # print(food.aver)       # print(foods)   # 性价比排序   foods.sort(key=lambda f: f.aver, reverse=True)   # for i in range(n):   #     print(foods[i].aver)   sum=0   for i in range(n):       sum+= foods[i].w   # 当背包（肚子）能装下所有物品（菜）时，直接输出所有的物品（菜品）价值之和   if sum&lt;=C :       for i in range(n):           Value+=foods[i].v;       print(Value)   # 当背包（肚子）不能装下所有物品时应该由性价比的顺序，选择装入的物品   else:       for i in range(n):           if foods[i].w&lt;=C:               Value=Value+foods[i].v               C=C-foods[i].w           #     直接将剩余的C加入即可           else:               Value+=C*foods[i].aver               C=0           if C==0:               break       print(\"%.3f\" % Value)\n\nJava 解法\nclass Food:   def __init__(self, w, v, aver):       self.w = w       self.v = v       self.aver = aver   def __repr__(self):       # print(11)       return repr((self.w, self.v, self.aver))# def cmp(foodA: Food, foodB: Food):#     if foodA.aver &gt;= foodB.aver:#         return True##     else:#         return False### 当然 python 的 sort 是不需要写 cmp 函数的，这里我们使用 sorted 就不用 cmp 函数了if __name__ == '__main__':   foods = []   C = 0.0   Value = 0.0   n, C = map(int, input().split())   for i in range(n):       food = Food(0, 0, 0)       food.v, food.w = map(int, input().split())       food.aver = food.v / food.w       foods.append(food)       # print(food.aver)       # print(foods)   # 性价比排序   foods.sort(key=lambda f: f.aver, reverse=True)   # for i in range(n):   #     print(foods[i].aver)   sum=0   for i in range(n):       sum+= foods[i].w   # 当背包（肚子）能装下所有物品（菜）时，直接输出所有的物品（菜品）价值之和   if sum&lt;=C :       for i in range(n):           Value+=foods[i].v;       print(Value)   # 当背包（肚子）不能装下所有物品时应该由性价比的顺序，选择装入的物品   else:       for i in range(n):           if foods[i].w&lt;=C:               Value=Value+foods[i].v               C=C-foods[i].w           #     直接将剩余的C加入即可           else:               Value+=C*foods[i].aver               C=0           if C==0:               break       print(\"%.3f\" % Value)\n\n实验总结贪心算法的最主要的特征就是无后效性，就像是自助餐那个题目，如果说吃了某一样食物，就不能吃另一个食物了，那么这就有了后效性，那就不能使用贪心算法进行解决问题了。\n本节课举了三个贪心算法的例子进行讲解，贪心算法是算法竞赛中最入门的算法。没接触过感觉很深奥，接触过了也就那样，简单的贪心伸伸手就可以写出来，其实非常简单，大家也不要过分的担心。\n","categories":["数据结构与算法"],"tags":["蓝桥杯"]},{"title":"[服务器搭建]Ubuntu安装","url":"/2024/07/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA-Ubuntu%E5%AE%89%E8%A3%85/","content":"ubuntu-20.04.6-live-server-amd64安装部署1. 制作一个U盘启动盘Ubuntu iso下载地址\n清华大学开源软件镜像站\n官网下载\n制作工具下载\n推荐使用rufus，因为免费\n安装地址\n准备一个U盘，插上U盘，打开rufus，选择镜像文件，具体配置如下：\n\n然后点击开始就行了\n等U盘制作完成就可以开始下一步了\n2. 设置开机启动项对于不同的电脑，开机boot方法不同，根据主板品牌，大致如下：\n笔记本电脑主要按键：Delete, ESC, F1, F2, F10\n品牌笔记本电脑ibm/thinkpad（冷开机按f1，部分新型号可以在重新启动时启动按f1，少数机型是Fn+F1或F2）\n惠普hp（启动和重新启动时按f2或者F10，或者先按ESC再按F10）\n索尼sony（启动和重新启动时按f2或者ASSIST键）\n戴尔dell（启动和重新启动时按f2）\n宏碁acer（启动和重新启动时按f2）\n东芝toshiba（冷开机时按esc然后按f1，或者F2）\n惠普康柏hp compaq（开机到右上角出现闪动光标时按f10，或者开机时按f10）\n富士通fujitsu（启动和重新启动时按f2）\n三星Samsung（启动和重新时按f2）\n联想Lenovo(启动时按F2或Fn+F2，部分机型需关机时按Novo恢复键)\n华硕Asus（启动时按F2）\n微星msi（启动时按Delete）\n神舟Hasee（启动时按F2）\n小米、海尔、明基、技嘉、方正、清华同方、雷神、未来人类、外星人、七喜等品牌笔记本也是F2\n台式电脑主要按键：DEL, ESC, F1, F2, F8, F9, F10, F12\n组装机不同主板台式机Award BIOS：按“Del”键\nAMI BIOS：按“Del”或“ESC”键\nPhoenix BIOS：按“F2”键\n品牌台式机ibm/thinkpad（冷开机按f1，部分新型号可以在重新启动时启动按f1）\n惠普hp（启动和重新启动时按f2或者F10）\n索尼sony（启动和重新启动时按f2）\n戴尔dell（启动和重新启动时按f2）\n宏碁acer（启动和重新启动时按f2）\n东芝toshiba（冷开机时按esc然后按f1）\n惠普康柏hp compaq（开机到右上角出现闪动光标时按f10，或者开机时按f10）\n富士通fujitsu（启动和重新启动时按f2）\n三星Samsung（启动和重新时按f2）\n联想Lenovo(启动时按F2或Fn+F2，部分机型需关机时按Novo恢复键)\n华硕Asus（启动时按F2）\n大多数中国大陆国产和台湾品牌（启动和重新启动时按f2）\n进入BIOS之后，设置启动方式为移动盘启动用u盘装系统bios怎么设置u盘启动_快启动官网 (kqidong.com)\n我测试的时候使用的电脑不支持UEFI,所以选择的是下面这个：（Remouable Dev.移动盘启动)\n\n设置好之后，按F10进行保存重启，进入下一步\n3. 系统安装参考文章\n4. 设置允许ssh使用22端口连接参考文章\nubuntu-20.04.6-desktop-amd64.iso参考文章\n桌面版安装比较简单，制作U盘启动盘前面有样例，故不在记录\n使用宝塔面板进行管理宝塔面板官网\n安装脚本\nwget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh ed8484bec\n\n在ubuntu命令行中运行即可安装\n使用1panel面板进行管理1panel官网链接\ncurl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh &amp;&amp; sudo bash quick_start.sh\n","categories":["服务器搭建"],"tags":["Ubuntu"]}]